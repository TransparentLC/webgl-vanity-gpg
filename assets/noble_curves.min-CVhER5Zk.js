import{p as me,g as Zt,b as Be,l as Ve,c as we,U as Ut,$ as Ee,T as xe,x as Ke,i as Ye,u as Me,n as Qt,s as We}from"./sha3.min-Dxc9pZ0t.js";/*! OpenPGP.js v6.0.0 - 2024-11-04 - this is LGPL licensed code, see LICENSE/our website https://openpgpjs.org/ for more information. */class Ie extends Ke{constructor(t,e){super(),this.finished=!1,this.destroyed=!1,Ye(t);const r=Me(e);if(this.iHash=t.create(),typeof this.iHash.update!="function")throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const c=this.blockLen,i=new Uint8Array(c);i.set(r.length>c?t.create().update(r).digest():r);for(let g=0;g<i.length;g++)i[g]^=54;this.iHash.update(i),this.oHash=t.create();for(let g=0;g<i.length;g++)i[g]^=106;this.oHash.update(i),i.fill(0)}update(t){return Qt(this),this.iHash.update(t),this}digestInto(t){Qt(this),We(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:c,destroyed:i,blockLen:g,outputLen:d}=this;return t.finished=c,t.destroyed=i,t.blockLen=g,t.outputLen=d,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const ve=(n,t,e)=>new Ie(n,t).update(e).digest();ve.create=(n,t)=>new Ie(n,t);const kt=BigInt(0),St=BigInt(1),De=BigInt(2);function ct(n){return n instanceof Uint8Array||n!=null&&typeof n=="object"&&n.constructor.name==="Uint8Array"}function It(n){if(!ct(n))throw Error("Uint8Array expected")}function ft(n,t){if(typeof t!="boolean")throw Error(`${n} must be valid boolean, got "${t}".`)}const _e=Array.from({length:256},(n,t)=>t.toString(16).padStart(2,"0"));function dt(n){It(n);let t="";for(let e=0;e<n.length;e++)t+=_e[n[e]];return t}function pt(n){const t=n.toString(16);return 1&t.length?"0"+t:t}function Gt(n){if(typeof n!="string")throw Error("hex string expected, got "+typeof n);return BigInt(n===""?"0":"0x"+n)}const et={_0:48,_9:57,_A:65,_F:70,_a:97,_f:102};function Xt(n){return n>=et._0&&n<=et._9?n-et._0:n>=et._A&&n<=et._F?n-(et._A-10):n>=et._a&&n<=et._f?n-(et._a-10):void 0}function Bt(n){if(typeof n!="string")throw Error("hex string expected, got "+typeof n);const t=n.length,e=t/2;if(t%2)throw Error("padded hex string expected, got unpadded hex of length "+t);const r=new Uint8Array(e);for(let c=0,i=0;c<e;c++,i+=2){const g=Xt(n.charCodeAt(i)),d=Xt(n.charCodeAt(i+1));if(g===void 0||d===void 0){const s=n[i]+n[i+1];throw Error('hex string expected, got non-hex character "'+s+'" at index '+i)}r[c]=16*g+d}return r}function at(n){return Gt(dt(n))}function ot(n){return It(n),Gt(dt(Uint8Array.from(n).reverse()))}function mt(n,t){return Bt(n.toString(16).padStart(2*t,"0"))}function wt(n,t){return mt(n,t).reverse()}function j(n,t,e){let r;if(typeof t=="string")try{r=Bt(t)}catch(i){throw Error(`${n} must be valid hex string, got "${t}". Cause: ${i}`)}else{if(!ct(t))throw Error(n+" must be hex string or Uint8Array");r=Uint8Array.from(t)}const c=r.length;if(typeof e=="number"&&c!==e)throw Error(`${n} expected ${e} bytes, got ${c}`);return r}function ut(...n){let t=0;for(let r=0;r<n.length;r++){const c=n[r];It(c),t+=c.length}const e=new Uint8Array(t);for(let r=0,c=0;r<n.length;r++){const i=n[r];e.set(i,c),c+=i.length}return e}const Rt=n=>typeof n=="bigint"&&kt<=n;function At(n,t,e){return Rt(n)&&Rt(t)&&Rt(e)&&t<=n&&n<e}function J(n,t,e,r){if(!At(t,e,r))throw Error(`expected valid ${n}: ${e} <= n < ${r}, got ${typeof t} ${t}`)}function Se(n){let t;for(t=0;n>kt;n>>=St,t+=1);return t}const Ct=n=>(De<<BigInt(n-1))-St,qt=n=>new Uint8Array(n),te=n=>Uint8Array.from(n);function Ae(n,t,e){if(typeof n!="number"||n<2)throw Error("hashLen must be a number");if(typeof t!="number"||t<2)throw Error("qByteLen must be a number");if(typeof e!="function")throw Error("hmacFn must be a function");let r=qt(n),c=qt(n),i=0;const g=()=>{r.fill(1),c.fill(0),i=0},d=(...o)=>e(c,r,...o),s=(o=qt())=>{c=d(te([0]),o),r=d(),o.length!==0&&(c=d(te([1]),o),r=d())},y=()=>{if(i++>=1e3)throw Error("drbg: tried 1000 values");let o=0;const B=[];for(;o<t;){r=d();const A=r.slice();B.push(A),o+=r.length}return ut(...B)};return(o,B)=>{let A;for(g(),s(o);!(A=B(y()));)s();return g(),A}}const Je={bigint:n=>typeof n=="bigint",function:n=>typeof n=="function",boolean:n=>typeof n=="boolean",string:n=>typeof n=="string",stringOrUint8Array:n=>typeof n=="string"||ct(n),isSafeInteger:n=>Number.isSafeInteger(n),array:n=>Array.isArray(n),field:(n,t)=>t.Fp.isValid(n),hash:n=>typeof n=="function"&&Number.isSafeInteger(n.outputLen)};function lt(n,t,e={}){const r=(c,i,g)=>{const d=Je[i];if(typeof d!="function")throw Error(`Invalid validator "${i}", expected function`);const s=n[c];if(!(g&&s===void 0||d(s,n)))throw Error(`Invalid param ${c+""}=${s} (${typeof s}), expected ${i}`)};for(const[c,i]of Object.entries(t))r(c,i,!1);for(const[c,i]of Object.entries(e))r(c,i,!0);return n}function Et(n){const t=new WeakMap;return(e,...r)=>{const c=t.get(e);if(c!==void 0)return c;const i=n(e,...r);return t.set(e,i),i}}var Qe=Object.freeze({__proto__:null,aInRange:J,abool:ft,abytes:It,bitGet:function(n,t){return n>>BigInt(t)&St},bitLen:Se,bitMask:Ct,bitSet:function(n,t,e){return n|(e?St:kt)<<BigInt(t)},bytesToHex:dt,bytesToNumberBE:at,bytesToNumberLE:ot,concatBytes:ut,createHmacDrbg:Ae,ensureBytes:j,equalBytes:function(n,t){if(n.length!==t.length)return!1;let e=0;for(let r=0;r<n.length;r++)e|=n[r]^t[r];return e===0},hexToBytes:Bt,hexToNumber:Gt,inRange:At,isBytes:ct,memoized:Et,notImplemented:()=>{throw Error("not implemented")},numberToBytesBE:mt,numberToBytesLE:wt,numberToHexUnpadded:pt,numberToVarBytesBE:function(n){return Bt(pt(n))},utf8ToBytes:function(n){if(typeof n!="string")throw Error("utf8ToBytes expected string, got "+typeof n);return new Uint8Array(new TextEncoder().encode(n))},validateObject:lt});/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const M=BigInt(0),V=BigInt(1),st=BigInt(2),Xe=BigInt(3),zt=BigInt(4),ee=BigInt(5),ne=BigInt(8);function k(n,t){const e=n%t;return e>=M?e:t+e}function Oe(n,t,e){if(e<=M||t<M)throw Error("Expected power/modulo > 0");if(e===V)return M;let r=V;for(;t>M;)t&V&&(r=r*n%e),n=n*n%e,t>>=V;return r}function U(n,t,e){let r=n;for(;t-- >M;)r*=r,r%=e;return r}function $t(n,t){if(n===M||t<=M)throw Error(`invert: expected positive integers, got n=${n} mod=${t}`);let e=k(n,t),r=t,c=M,i=V;for(;e!==M;){const g=r%e,d=c-i*(r/e);r=e,e=g,c=i,i=d}if(r!==V)throw Error("invert: does not exist");return k(c,t)}function tn(n){if(n%zt===Xe){const t=(n+V)/zt;return function(e,r){const c=e.pow(r,t);if(!e.eql(e.sqr(c),r))throw Error("Cannot find square root");return c}}if(n%ne===ee){const t=(n-ee)/ne;return function(e,r){const c=e.mul(r,st),i=e.pow(c,t),g=e.mul(r,i),d=e.mul(e.mul(g,st),i),s=e.mul(g,e.sub(d,e.ONE));if(!e.eql(e.sqr(s),r))throw Error("Cannot find square root");return s}}return function(t){const e=(t-V)/st;let r,c,i;for(r=t-V,c=0;r%st===M;r/=st,c++);for(i=st;i<t&&Oe(i,e,t)!==t-V;i++);if(c===1){const d=(t+V)/zt;return function(s,y){const o=s.pow(y,d);if(!s.eql(s.sqr(o),y))throw Error("Cannot find square root");return o}}const g=(r+V)/st;return function(d,s){if(d.pow(s,e)===d.neg(d.ONE))throw Error("Cannot find square root");let y=c,o=d.pow(d.mul(d.ONE,i),r),B=d.pow(s,g),A=d.pow(s,r);for(;!d.eql(A,d.ONE);){if(d.eql(A,d.ZERO))return d.ZERO;let P=1;for(let a=d.sqr(A);P<y&&!d.eql(a,d.ONE);P++)a=d.sqr(a);const I=d.pow(o,V<<BigInt(y-P-1));o=d.sqr(I),B=d.mul(B,I),A=d.mul(A,o),y=P}return B}}(n)}BigInt(9),BigInt(16);const en=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Re(n,t){const e=t!==void 0?t:n.toString(2).length;return{nBitLength:e,nByteLength:Math.ceil(e/8)}}function tt(n,t,e=!1,r={}){if(n<=M)throw Error("Expected Field ORDER > 0, got "+n);const{nBitLength:c,nByteLength:i}=Re(n,t);if(i>2048)throw Error("Field lengths over 2048 bytes are not supported");const g=tn(n),d=Object.freeze({ORDER:n,BITS:c,BYTES:i,MASK:Ct(c),ZERO:M,ONE:V,create:s=>k(s,n),isValid:s=>{if(typeof s!="bigint")throw Error("Invalid field element: expected bigint, got "+typeof s);return M<=s&&s<n},is0:s=>s===M,isOdd:s=>(s&V)===V,neg:s=>k(-s,n),eql:(s,y)=>s===y,sqr:s=>k(s*s,n),add:(s,y)=>k(s+y,n),sub:(s,y)=>k(s-y,n),mul:(s,y)=>k(s*y,n),pow:(s,y)=>function(o,B,A){if(A<M)throw Error("Expected power > 0");if(A===M)return o.ONE;if(A===V)return B;let P=o.ONE,I=B;for(;A>M;)A&V&&(P=o.mul(P,I)),I=o.sqr(I),A>>=V;return P}(d,s,y),div:(s,y)=>k(s*$t(y,n),n),sqrN:s=>s*s,addN:(s,y)=>s+y,subN:(s,y)=>s-y,mulN:(s,y)=>s*y,inv:s=>$t(s,n),sqrt:r.sqrt||(s=>g(d,s)),invertBatch:s=>function(y,o){const B=Array(o.length),A=o.reduce((I,a,l)=>y.is0(a)?I:(B[l]=I,y.mul(I,a)),y.ONE),P=y.inv(A);return o.reduceRight((I,a,l)=>y.is0(a)?I:(B[l]=y.mul(I,B[l]),y.mul(I,a)),P),B}(d,s),cmov:(s,y,o)=>o?y:s,toBytes:s=>e?wt(s,i):mt(s,i),fromBytes:s=>{if(s.length!==i)throw Error(`Fp.fromBytes: expected ${i}, got ${s.length}`);return e?ot(s):at(s)}});return Object.freeze(d)}function qe(n){if(typeof n!="bigint")throw Error("field order must be bigint");const t=n.toString(2).length;return Math.ceil(t/8)}function re(n){const t=qe(n);return t+Math.ceil(t/2)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const nn=BigInt(0),Pt=BigInt(1),Lt=new WeakMap,fe=new WeakMap;function ze(n,t){const e=(i,g)=>{const d=g.negate();return i?d:g},r=i=>{if(!Number.isSafeInteger(i)||i<=0||i>t)throw Error(`Wrong window size=${i}, should be [1..${t}]`)},c=i=>(r(i),{windows:Math.ceil(t/i)+1,windowSize:2**(i-1)});return{constTimeNegate:e,unsafeLadder(i,g){let d=n.ZERO,s=i;for(;g>nn;)g&Pt&&(d=d.add(s)),s=s.double(),g>>=Pt;return d},precomputeWindow(i,g){const{windows:d,windowSize:s}=c(g),y=[];let o=i,B=o;for(let A=0;A<d;A++){B=o,y.push(B);for(let P=1;P<s;P++)B=B.add(o),y.push(B);o=B.double()}return y},wNAF(i,g,d){const{windows:s,windowSize:y}=c(i);let o=n.ZERO,B=n.BASE;const A=BigInt(2**i-1),P=2**i,I=BigInt(i);for(let a=0;a<s;a++){const l=a*y;let v=Number(d&A);d>>=I,v>y&&(v-=P,d+=Pt);const O=l,E=l+Math.abs(v)-1,$=a%2!=0,q=v<0;v===0?B=B.add(e($,g[O])):o=o.add(e(q,g[E]))}return{p:o,f:B}},wNAFCached(i,g,d){const s=fe.get(i)||1;let y=Lt.get(i);return y||(y=this.precomputeWindow(i,s),s!==1&&Lt.set(i,d(y))),this.wNAF(s,y,g)},setWindowSize(i,g){r(g),fe.set(i,g),Lt.delete(i)}}}function Pe(n,t,e,r){if(!Array.isArray(e)||!Array.isArray(r)||r.length!==e.length)throw Error("arrays of points and scalars must have equal length");r.forEach((o,B)=>{if(!t.isValid(o))throw Error("wrong scalar at index "+B)}),e.forEach((o,B)=>{if(!(o instanceof n))throw Error("wrong point at index "+B)});const c=Se(BigInt(e.length)),i=c>12?c-3:c>4?c-2:c?2:1,g=(1<<i)-1,d=Array(g+1).fill(n.ZERO),s=Math.floor((t.BITS-1)/i)*i;let y=n.ZERO;for(let o=s;o>=0;o-=i){d.fill(n.ZERO);for(let A=0;A<r.length;A++){const P=r[A],I=Number(P>>BigInt(o)&BigInt(g));d[I]=d[I].add(e[A])}let B=n.ZERO;for(let A=d.length-1,P=n.ZERO;A>0;A--)P=P.add(d[A]),B=B.add(P);if(y=y.add(B),o!==0)for(let A=0;A<i;A++)y=y.double()}return y}function jt(n){return lt(n.Fp,en.reduce((t,e)=>(t[e]="function",t),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),lt(n,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...Re(n.n,n.nBitLength),...n,p:n.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function oe(n){n.lowS!==void 0&&ft("lowS",n.lowS),n.prehash!==void 0&&ft("prehash",n.prehash)}const{bytesToNumberBE:rn,hexToBytes:fn}=Qe,nt={Err:class extends Error{constructor(n=""){super(n)}},_tlv:{encode:(n,t)=>{const{Err:e}=nt;if(n<0||n>256)throw new e("tlv.encode: wrong tag");if(1&t.length)throw new e("tlv.encode: unpadded data");const r=t.length/2,c=pt(r);if(c.length/2&128)throw new e("tlv.encode: long form length too big");const i=r>127?pt(c.length/2|128):"";return`${pt(n)}${i}${c}${t}`},decode(n,t){const{Err:e}=nt;let r=0;if(n<0||n>256)throw new e("tlv.encode: wrong tag");if(t.length<2||t[r++]!==n)throw new e("tlv.decode: wrong tlv");const c=t[r++];let i=0;if(128&c){const d=127&c;if(!d)throw new e("tlv.decode(long): indefinite length not supported");if(d>4)throw new e("tlv.decode(long): byte length is too big");const s=t.subarray(r,r+d);if(s.length!==d)throw new e("tlv.decode: length bytes not complete");if(s[0]===0)throw new e("tlv.decode(long): zero leftmost byte");for(const y of s)i=i<<8|y;if(r+=d,i<128)throw new e("tlv.decode(long): not minimal encoding")}else i=c;const g=t.subarray(r,r+i);if(g.length!==i)throw new e("tlv.decode: wrong value length");return{v:g,l:t.subarray(r+i)}}},_int:{encode(n){const{Err:t}=nt;if(n<rt)throw new t("integer: negative integers are not allowed");let e=pt(n);if(8&Number.parseInt(e[0],16)&&(e="00"+e),1&e.length)throw new t("unexpected assertion");return e},decode(n){const{Err:t}=nt;if(128&n[0])throw new t("Invalid signature integer: negative");if(n[0]===0&&!(128&n[1]))throw new t("Invalid signature integer: unnecessary leading zero");return rn(n)}},toSig(n){const{Err:t,_int:e,_tlv:r}=nt,c=typeof n=="string"?fn(n):n;It(c);const{v:i,l:g}=r.decode(48,c);if(g.length)throw new t("Invalid signature: left bytes after parsing");const{v:d,l:s}=r.decode(2,i),{v:y,l:o}=r.decode(2,s);if(o.length)throw new t("Invalid signature: left bytes after parsing");return{r:e.decode(d),s:e.decode(y)}},hexFromSig(n){const{_tlv:t,_int:e}=nt,r=`${t.encode(2,e.encode(n.r))}${t.encode(2,e.encode(n.s))}`;return t.encode(48,r)}},rt=BigInt(0),Y=BigInt(1);BigInt(2);const ie=BigInt(3);function on(n){const t=function(I){const a=jt(I);lt(a,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:l,Fp:v,a:O}=a;if(l){if(!v.eql(O,v.ZERO))throw Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof l!="object"||typeof l.beta!="bigint"||typeof l.splitScalar!="function")throw Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...a})}(n),{Fp:e}=t,r=tt(t.n,t.nBitLength),c=t.toBytes||((I,a,l)=>{const v=a.toAffine();return ut(Uint8Array.from([4]),e.toBytes(v.x),e.toBytes(v.y))}),i=t.fromBytes||(I=>{const a=I.subarray(1);return{x:e.fromBytes(a.subarray(0,e.BYTES)),y:e.fromBytes(a.subarray(e.BYTES,2*e.BYTES))}});function g(I){const{a,b:l}=t,v=e.sqr(I),O=e.mul(v,I);return e.add(e.add(O,e.mul(I,a)),l)}if(!e.eql(e.sqr(t.Gy),g(t.Gx)))throw Error("bad generator point: equation left != right");function d(I){const{allowedPrivateKeyLengths:a,nByteLength:l,wrapPrivateKey:v,n:O}=t;if(a&&typeof I!="bigint"){if(ct(I)&&(I=dt(I)),typeof I!="string"||!a.includes(I.length))throw Error("Invalid key");I=I.padStart(2*l,"0")}let E;try{E=typeof I=="bigint"?I:at(j("private key",I,l))}catch{throw Error(`private key must be ${l} bytes, hex or bigint, not ${typeof I}`)}return v&&(E=k(E,O)),J("private key",E,Y,O),E}function s(I){if(!(I instanceof B))throw Error("ProjectivePoint expected")}const y=Et((I,a)=>{const{px:l,py:v,pz:O}=I;if(e.eql(O,e.ONE))return{x:l,y:v};const E=I.is0();a==null&&(a=E?e.ONE:e.inv(O));const $=e.mul(l,a),q=e.mul(v,a),S=e.mul(O,a);if(E)return{x:e.ZERO,y:e.ZERO};if(!e.eql(S,e.ONE))throw Error("invZ was invalid");return{x:$,y:q}}),o=Et(I=>{if(I.is0()){if(t.allowInfinityPoint&&!e.is0(I.py))return;throw Error("bad point: ZERO")}const{x:a,y:l}=I.toAffine();if(!e.isValid(a)||!e.isValid(l))throw Error("bad point: x or y not FE");const v=e.sqr(l),O=g(a);if(!e.eql(v,O))throw Error("bad point: equation left != right");if(!I.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0});class B{constructor(a,l,v){if(this.px=a,this.py=l,this.pz=v,a==null||!e.isValid(a))throw Error("x required");if(l==null||!e.isValid(l))throw Error("y required");if(v==null||!e.isValid(v))throw Error("z required");Object.freeze(this)}static fromAffine(a){const{x:l,y:v}=a||{};if(!a||!e.isValid(l)||!e.isValid(v))throw Error("invalid affine point");if(a instanceof B)throw Error("projective point not allowed");const O=E=>e.eql(E,e.ZERO);return O(l)&&O(v)?B.ZERO:new B(l,v,e.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(a){const l=e.invertBatch(a.map(v=>v.pz));return a.map((v,O)=>v.toAffine(l[O])).map(B.fromAffine)}static fromHex(a){const l=B.fromAffine(i(j("pointHex",a)));return l.assertValidity(),l}static fromPrivateKey(a){return B.BASE.multiply(d(a))}static msm(a,l){return Pe(B,r,a,l)}_setWindowSize(a){P.setWindowSize(this,a)}assertValidity(){o(this)}hasEvenY(){const{y:a}=this.toAffine();if(e.isOdd)return!e.isOdd(a);throw Error("Field doesn't support isOdd")}equals(a){s(a);const{px:l,py:v,pz:O}=this,{px:E,py:$,pz:q}=a,S=e.eql(e.mul(l,q),e.mul(E,O)),R=e.eql(e.mul(v,q),e.mul($,O));return S&&R}negate(){return new B(this.px,e.neg(this.py),this.pz)}double(){const{a,b:l}=t,v=e.mul(l,ie),{px:O,py:E,pz:$}=this;let q=e.ZERO,S=e.ZERO,R=e.ZERO,L=e.mul(O,O),m=e.mul(E,E),h=e.mul($,$),p=e.mul(O,E);return p=e.add(p,p),R=e.mul(O,$),R=e.add(R,R),q=e.mul(a,R),S=e.mul(v,h),S=e.add(q,S),q=e.sub(m,S),S=e.add(m,S),S=e.mul(q,S),q=e.mul(p,q),R=e.mul(v,R),h=e.mul(a,h),p=e.sub(L,h),p=e.mul(a,p),p=e.add(p,R),R=e.add(L,L),L=e.add(R,L),L=e.add(L,h),L=e.mul(L,p),S=e.add(S,L),h=e.mul(E,$),h=e.add(h,h),L=e.mul(h,p),q=e.sub(q,L),R=e.mul(h,m),R=e.add(R,R),R=e.add(R,R),new B(q,S,R)}add(a){s(a);const{px:l,py:v,pz:O}=this,{px:E,py:$,pz:q}=a;let S=e.ZERO,R=e.ZERO,L=e.ZERO;const m=t.a,h=e.mul(t.b,ie);let p=e.mul(l,E),u=e.mul(v,$),f=e.mul(O,q),b=e.add(l,v),w=e.add(E,$);b=e.mul(b,w),w=e.add(p,u),b=e.sub(b,w),w=e.add(l,O);let x=e.add(E,q);return w=e.mul(w,x),x=e.add(p,f),w=e.sub(w,x),x=e.add(v,O),S=e.add($,q),x=e.mul(x,S),S=e.add(u,f),x=e.sub(x,S),L=e.mul(m,w),S=e.mul(h,f),L=e.add(S,L),S=e.sub(u,L),L=e.add(u,L),R=e.mul(S,L),u=e.add(p,p),u=e.add(u,p),f=e.mul(m,f),w=e.mul(h,w),u=e.add(u,f),f=e.sub(p,f),f=e.mul(m,f),w=e.add(w,f),p=e.mul(u,w),R=e.add(R,p),p=e.mul(x,w),S=e.mul(b,S),S=e.sub(S,p),p=e.mul(b,u),L=e.mul(x,L),L=e.add(L,p),new B(S,R,L)}subtract(a){return this.add(a.negate())}is0(){return this.equals(B.ZERO)}wNAF(a){return P.wNAFCached(this,a,B.normalizeZ)}multiplyUnsafe(a){J("scalar",a,rt,t.n);const l=B.ZERO;if(a===rt)return l;if(a===Y)return this;const{endo:v}=t;if(!v)return P.unsafeLadder(this,a);let{k1neg:O,k1:E,k2neg:$,k2:q}=v.splitScalar(a),S=l,R=l,L=this;for(;E>rt||q>rt;)E&Y&&(S=S.add(L)),q&Y&&(R=R.add(L)),L=L.double(),E>>=Y,q>>=Y;return O&&(S=S.negate()),$&&(R=R.negate()),R=new B(e.mul(R.px,v.beta),R.py,R.pz),S.add(R)}multiply(a){const{endo:l,n:v}=t;let O,E;if(J("scalar",a,Y,v),l){const{k1neg:$,k1:q,k2neg:S,k2:R}=l.splitScalar(a);let{p:L,f:m}=this.wNAF(q),{p:h,f:p}=this.wNAF(R);L=P.constTimeNegate($,L),h=P.constTimeNegate(S,h),h=new B(e.mul(h.px,l.beta),h.py,h.pz),O=L.add(h),E=m.add(p)}else{const{p:$,f:q}=this.wNAF(a);O=$,E=q}return B.normalizeZ([O,E])[0]}multiplyAndAddUnsafe(a,l,v){const O=B.BASE,E=(q,S)=>S!==rt&&S!==Y&&q.equals(O)?q.multiply(S):q.multiplyUnsafe(S),$=E(this,l).add(E(a,v));return $.is0()?void 0:$}toAffine(a){return y(this,a)}isTorsionFree(){const{h:a,isTorsionFree:l}=t;if(a===Y)return!0;if(l)return l(B,this);throw Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:a,clearCofactor:l}=t;return a===Y?this:l?l(B,this):this.multiplyUnsafe(t.h)}toRawBytes(a=!0){return ft("isCompressed",a),this.assertValidity(),c(B,this,a)}toHex(a=!0){return ft("isCompressed",a),dt(this.toRawBytes(a))}}B.BASE=new B(t.Gx,t.Gy,e.ONE),B.ZERO=new B(e.ZERO,e.ONE,e.ZERO);const A=t.nBitLength,P=ze(B,t.endo?Math.ceil(A/2):A);return{CURVE:t,ProjectivePoint:B,normPrivateKeyToScalar:d,weierstrassEquation:g,isWithinCurveOrder:function(I){return At(I,Y,t.n)}}}function sn(n){const t=function(m){const h=jt(m);return lt(h,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...h})}(n),{Fp:e,n:r}=t,c=e.BYTES+1,i=2*e.BYTES+1;function g(m){return k(m,r)}function d(m){return $t(m,r)}const{ProjectivePoint:s,normPrivateKeyToScalar:y,weierstrassEquation:o,isWithinCurveOrder:B}=on({...t,toBytes(m,h,p){const u=h.toAffine(),f=e.toBytes(u.x),b=ut;return ft("isCompressed",p),p?b(Uint8Array.from([h.hasEvenY()?2:3]),f):b(Uint8Array.from([4]),f,e.toBytes(u.y))},fromBytes(m){const h=m.length,p=m[0],u=m.subarray(1);if(h!==c||p!==2&&p!==3){if(h===i&&p===4)return{x:e.fromBytes(u.subarray(0,e.BYTES)),y:e.fromBytes(u.subarray(e.BYTES,2*e.BYTES))};throw Error(`Point of length ${h} was invalid. Expected ${c} compressed bytes or ${i} uncompressed bytes`)}{const f=at(u);if(!At(f,Y,e.ORDER))throw Error("Point is not on curve");const b=o(f);let w;try{w=e.sqrt(b)}catch(x){const z=x instanceof Error?": "+x.message:"";throw Error("Point is not on curve"+z)}return!(1&~p)!=((w&Y)===Y)&&(w=e.neg(w)),{x:f,y:w}}}}),A=m=>dt(mt(m,t.nByteLength));function P(m){return m>r>>Y}const I=(m,h,p)=>at(m.slice(h,p));class a{constructor(h,p,u){this.r=h,this.s=p,this.recovery=u,this.assertValidity()}static fromCompact(h){const p=t.nByteLength;return h=j("compactSignature",h,2*p),new a(I(h,0,p),I(h,p,2*p))}static fromDER(h){const{r:p,s:u}=nt.toSig(j("DER",h));return new a(p,u)}assertValidity(){J("r",this.r,Y,r),J("s",this.s,Y,r)}addRecoveryBit(h){return new a(this.r,this.s,h)}recoverPublicKey(h){const{r:p,s:u,recovery:f}=this,b=E(j("msgHash",h));if(f==null||![0,1,2,3].includes(f))throw Error("recovery id invalid");const w=f===2||f===3?p+t.n:p;if(w>=e.ORDER)throw Error("recovery id 2 or 3 invalid");const x=1&f?"03":"02",z=s.fromHex(x+A(w)),N=d(w),T=g(-b*N),H=g(u*N),F=s.BASE.multiplyAndAddUnsafe(z,T,H);if(!F)throw Error("point at infinify");return F.assertValidity(),F}hasHighS(){return P(this.s)}normalizeS(){return this.hasHighS()?new a(this.r,g(-this.s),this.recovery):this}toDERRawBytes(){return Bt(this.toDERHex())}toDERHex(){return nt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return Bt(this.toCompactHex())}toCompactHex(){return A(this.r)+A(this.s)}}const l={isValidPrivateKey(m){try{return y(m),!0}catch{return!1}},normPrivateKeyToScalar:y,randomPrivateKey:()=>{const m=re(t.n);return function(h,p,u=!1){const f=h.length,b=qe(p),w=re(p);if(f<16||f<w||f>1024)throw Error(`expected ${w}-1024 bytes of input, got ${f}`);const x=k(u?at(h):ot(h),p-V)+V;return u?wt(x,b):mt(x,b)}(t.randomBytes(m),t.n)},precompute:(m=8,h=s.BASE)=>(h._setWindowSize(m),h.multiply(BigInt(3)),h)};function v(m){const h=ct(m),p=typeof m=="string",u=(h||p)&&m.length;return h?u===c||u===i:p?u===2*c||u===2*i:m instanceof s}const O=t.bits2int||function(m){const h=at(m),p=8*m.length-t.nBitLength;return p>0?h>>BigInt(p):h},E=t.bits2int_modN||function(m){return g(O(m))},$=Ct(t.nBitLength);function q(m){return J("num < 2^"+t.nBitLength,m,rt,$),mt(m,t.nByteLength)}function S(m,h,p=R){if(["recovered","canonical"].some(Z=>Z in p))throw Error("sign() legacy options not supported");const{hash:u,randomBytes:f}=t;let{lowS:b,prehash:w,extraEntropy:x}=p;b==null&&(b=!0),m=j("msgHash",m),oe(p),w&&(m=j("prehashed msgHash",u(m)));const z=E(m),N=y(h),T=[q(N),q(z)];if(x!=null&&x!==!1){const Z=x===!0?f(e.BYTES):x;T.push(j("extraEntropy",Z))}const H=ut(...T),F=z;return{seed:H,k2sig:function(Z){const G=O(Z);if(!B(G))return;const W=d(G),C=s.BASE.multiply(G).toAffine(),K=g(C.x);if(K===rt)return;const D=g(W*g(F+K*N));if(D===rt)return;let X=(C.x===K?0:2)|Number(C.y&Y),it=D;return b&&P(D)&&(it=function(gt){return P(gt)?g(-gt):gt}(D),X^=1),new a(K,it,X)}}}const R={lowS:t.lowS,prehash:!1},L={lowS:t.lowS,prehash:!1};return s.BASE._setWindowSize(8),{CURVE:t,getPublicKey:function(m,h=!0){return s.fromPrivateKey(m).toRawBytes(h)},getSharedSecret:function(m,h,p=!0){if(v(m))throw Error("first arg must be private key");if(!v(h))throw Error("second arg must be public key");return s.fromHex(h).multiply(y(m)).toRawBytes(p)},sign:function(m,h,p=R){const{seed:u,k2sig:f}=S(m,h,p),b=t;return Ae(b.hash.outputLen,b.nByteLength,b.hmac)(u,f)},verify:function(m,h,p,u=L){const f=m;if(h=j("msgHash",h),p=j("publicKey",p),"strict"in u)throw Error("options.strict was renamed to lowS");oe(u);const{lowS:b,prehash:w}=u;let x,z;try{if(typeof f=="string"||ct(f))try{x=a.fromDER(f)}catch(C){if(!(C instanceof nt.Err))throw C;x=a.fromCompact(f)}else{if(typeof f!="object"||typeof f.r!="bigint"||typeof f.s!="bigint")throw Error("PARSE");{const{r:C,s:K}=f;x=new a(C,K)}}z=s.fromHex(p)}catch(C){if(C.message==="PARSE")throw Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(b&&x.hasHighS())return!1;w&&(h=t.hash(h));const{r:N,s:T}=x,H=E(h),F=d(T),Z=g(H*F),G=g(N*F),W=s.BASE.multiplyAndAddUnsafe(z,Z,G)?.toAffine();return!!W&&g(W.x)===N},ProjectivePoint:s,Signature:a,utils:l}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function an(n){return{hash:n,hmac:(t,...e)=>ve(n,t,Be(...e)),randomBytes:Zt}}function ht(n,t){const e=r=>sn({...n,...an(r)});return Object.freeze({...e(t),create:e})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */BigInt(4);const se=tt(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff")),cn=ht({a:se.create(BigInt("-3")),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Fp:se,n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),h:BigInt(1),lowS:!1},Ut),ae=tt(BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff")),dn=ht({a:ae.create(BigInt("-3")),b:BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Fp:ae,n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f"),h:BigInt(1),lowS:!1},Ee),Ht=tt(BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff")),bt={a:Ht.create(BigInt("-3")),b:BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),Fp:Ht,n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650"),h:BigInt(1)},un=ht({a:bt.a,b:bt.b,Fp:Ht,n:bt.n,Gx:bt.Gx,Gy:bt.Gy,h:bt.h,lowS:!1,allowedPrivateKeyLengths:[130,131,132]},xe),Q=BigInt(0),_=BigInt(1),vt=BigInt(2),ln=BigInt(8),hn={zip215:!0};function gn(n){const t=function(u){const f=jt(u);return lt(u,{hash:"function",a:"bigint",d:"bigint",randomBytes:"function"},{adjustScalarBytes:"function",domain:"function",uvRatio:"function",mapToCurve:"function"}),Object.freeze({...f})}(n),{Fp:e,n:r,prehash:c,hash:i,randomBytes:g,nByteLength:d,h:s}=t,y=vt<<BigInt(8*d)-_,o=e.create,B=tt(t.n,t.nBitLength),A=t.uvRatio||((u,f)=>{try{return{isValid:!0,value:e.sqrt(u*e.inv(f))}}catch{return{isValid:!1,value:Q}}}),P=t.adjustScalarBytes||(u=>u),I=t.domain||((u,f,b)=>{if(ft("phflag",b),f.length||b)throw Error("Contexts/pre-hash are not supported");return u});function a(u,f){J("coordinate "+u,f,Q,y)}function l(u){if(!(u instanceof E))throw Error("ExtendedPoint expected")}const v=Et((u,f)=>{const{ex:b,ey:w,ez:x}=u,z=u.is0();f==null&&(f=z?ln:e.inv(x));const N=o(b*f),T=o(w*f),H=o(x*f);if(z)return{x:Q,y:_};if(H!==_)throw Error("invZ was invalid");return{x:N,y:T}}),O=Et(u=>{const{a:f,d:b}=t;if(u.is0())throw Error("bad point: ZERO");const{ex:w,ey:x,ez:z,et:N}=u,T=o(w*w),H=o(x*x),F=o(z*z),Z=o(F*F),G=o(T*f);if(o(F*o(G+H))!==o(Z+o(b*o(T*H))))throw Error("bad point: equation left != right (1)");if(o(w*x)!==o(z*N))throw Error("bad point: equation left != right (2)");return!0});class E{constructor(f,b,w,x){this.ex=f,this.ey=b,this.ez=w,this.et=x,a("x",f),a("y",b),a("z",w),a("t",x),Object.freeze(this)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static fromAffine(f){if(f instanceof E)throw Error("extended point not allowed");const{x:b,y:w}=f||{};return a("x",b),a("y",w),new E(b,w,_,o(b*w))}static normalizeZ(f){const b=e.invertBatch(f.map(w=>w.ez));return f.map((w,x)=>w.toAffine(b[x])).map(E.fromAffine)}static msm(f,b){return Pe(E,B,f,b)}_setWindowSize(f){S.setWindowSize(this,f)}assertValidity(){O(this)}equals(f){l(f);const{ex:b,ey:w,ez:x}=this,{ex:z,ey:N,ez:T}=f,H=o(b*T),F=o(z*x),Z=o(w*T),G=o(N*x);return H===F&&Z===G}is0(){return this.equals(E.ZERO)}negate(){return new E(o(-this.ex),this.ey,this.ez,o(-this.et))}double(){const{a:f}=t,{ex:b,ey:w,ez:x}=this,z=o(b*b),N=o(w*w),T=o(vt*o(x*x)),H=o(f*z),F=b+w,Z=o(o(F*F)-z-N),G=H+N,W=G-T,C=H-N,K=o(Z*W),D=o(G*C),X=o(Z*C),it=o(W*G);return new E(K,D,it,X)}add(f){l(f);const{a:b,d:w}=t,{ex:x,ey:z,ez:N,et:T}=this,{ex:H,ey:F,ez:Z,et:G}=f;if(b===BigInt(-1)){const Kt=o((z-x)*(F+H)),Yt=o((z+x)*(F-H)),Ot=o(Yt-Kt);if(Ot===Q)return this.double();const Mt=o(N*vt*G),Wt=o(T*vt*Z),Dt=Wt+Mt,_t=Yt+Kt,Jt=Wt-Mt,ke=o(Dt*Ot),Ge=o(_t*Jt),Ce=o(Dt*Jt),je=o(Ot*_t);return new E(ke,Ge,je,Ce)}const W=o(x*H),C=o(z*F),K=o(T*w*G),D=o(N*Z),X=o((x+z)*(H+F)-W-C),it=D-K,gt=D+K,Vt=o(C-b*W),Te=o(X*it),Fe=o(gt*Vt),Ze=o(X*Vt),Ue=o(it*gt);return new E(Te,Fe,Ue,Ze)}subtract(f){return this.add(f.negate())}wNAF(f){return S.wNAFCached(this,f,E.normalizeZ)}multiply(f){const b=f;J("scalar",b,_,r);const{p:w,f:x}=this.wNAF(b);return E.normalizeZ([w,x])[0]}multiplyUnsafe(f){const b=f;return J("scalar",b,Q,r),b===Q?q:this.equals(q)||b===_?this:this.equals($)?this.wNAF(b).p:S.unsafeLadder(this,b)}isSmallOrder(){return this.multiplyUnsafe(s).is0()}isTorsionFree(){return S.unsafeLadder(this,r).is0()}toAffine(f){return v(this,f)}clearCofactor(){const{h:f}=t;return f===_?this:this.multiplyUnsafe(f)}static fromHex(f,b=!1){const{d:w,a:x}=t,z=e.BYTES;f=j("pointHex",f,z),ft("zip215",b);const N=f.slice(),T=f[z-1];N[z-1]=-129&T;const H=ot(N),F=b?y:e.ORDER;J("pointHex.y",H,Q,F);const Z=o(H*H),G=o(Z-_),W=o(w*Z-x);let{isValid:C,value:K}=A(G,W);if(!C)throw Error("Point.fromHex: invalid y coordinate");const D=(K&_)===_,X=!!(128&T);if(!b&&K===Q&&X)throw Error("Point.fromHex: x=0 and x_0=1");return X!==D&&(K=o(-K)),E.fromAffine({x:K,y:H})}static fromPrivateKey(f){return m(f).point}toRawBytes(){const{x:f,y:b}=this.toAffine(),w=wt(b,e.BYTES);return w[w.length-1]|=f&_?128:0,w}toHex(){return dt(this.toRawBytes())}}E.BASE=new E(t.Gx,t.Gy,_,o(t.Gx*t.Gy)),E.ZERO=new E(Q,_,_,Q);const{BASE:$,ZERO:q}=E,S=ze(E,8*d);function R(u){return k(u,r)}function L(u){return R(ot(u))}function m(u){const f=d;u=j("private key",u,f);const b=j("hashed private key",i(u),2*f),w=P(b.slice(0,f)),x=b.slice(f,2*f),z=L(w),N=$.multiply(z),T=N.toRawBytes();return{head:w,prefix:x,scalar:z,point:N,pointBytes:T}}function h(u=new Uint8Array,...f){const b=ut(...f);return L(i(I(b,j("context",u),!!c)))}const p=hn;return $._setWindowSize(8),{CURVE:t,getPublicKey:function(u){return m(u).pointBytes},sign:function(u,f,b={}){u=j("message",u),c&&(u=c(u));const{prefix:w,scalar:x,pointBytes:z}=m(f),N=h(b.context,w,u),T=$.multiply(N).toRawBytes(),H=R(N+h(b.context,T,z,u)*x);return J("signature.s",H,Q,r),j("result",ut(T,wt(H,e.BYTES)),2*d)},verify:function(u,f,b,w=p){const{context:x,zip215:z}=w,N=e.BYTES;u=j("signature",u,2*N),f=j("message",f),z!==void 0&&ft("zip215",z),c&&(f=c(f));const T=ot(u.slice(N,2*N));let H,F,Z;try{H=E.fromHex(b,z),F=E.fromHex(u.slice(0,N),z),Z=$.multiplyUnsafe(T)}catch{return!1}if(!z&&H.isSmallOrder())return!1;const G=h(x,F.toRawBytes(),H.toRawBytes(),f);return F.add(H.multiplyUnsafe(G)).subtract(Z).clearCofactor().equals(E.ZERO)},ExtendedPoint:E,utils:{getExtendedPublicKey:m,randomPrivateKey:()=>g(e.BYTES),precompute:(u=8,f=E.BASE)=>(f._setWindowSize(u),f.multiply(BigInt(3)),f)}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const yt=BigInt(0),Nt=BigInt(1);function bn(n){const t=(lt(e=n,{a:"bigint"},{montgomeryBits:"isSafeInteger",nByteLength:"isSafeInteger",adjustScalarBytes:"function",domain:"function",powPminus2:"function",Gu:"bigint"}),Object.freeze({...e}));var e;const{P:r}=t,c=l=>k(l,r),i=t.montgomeryBits,g=Math.ceil(i/8),d=t.nByteLength,s=t.adjustScalarBytes||(l=>l),y=t.powPminus2||(l=>Oe(l,r-BigInt(2),r));function o(l,v,O){const E=c(l*(v-O));return[v=c(v-E),O=c(O+E)]}const B=(t.a-BigInt(2))/BigInt(4);function A(l){return wt(c(l),g)}function P(l,v){const O=function(q){const S=j("u coordinate",q,g);return d===32&&(S[31]&=127),ot(S)}(v),E=function(q){const S=j("scalar",q),R=S.length;if(R!==g&&R!==d)throw Error(`Expected ${g} or ${d} bytes, got ${R}`);return ot(s(S))}(l),$=function(q,S){J("u",q,yt,r),J("scalar",S,yt,r);const R=S,L=q;let m,h=Nt,p=yt,u=q,f=Nt,b=yt;for(let x=BigInt(i-1);x>=yt;x--){const z=R>>x&Nt;b^=z,m=o(b,h,u),h=m[0],u=m[1],m=o(b,p,f),p=m[0],f=m[1],b=z;const N=h+p,T=c(N*N),H=h-p,F=c(H*H),Z=T-F,G=u+f,W=c((u-f)*N),C=c(G*H),K=W+C,D=W-C;u=c(K*K),f=c(L*c(D*D)),h=c(T*F),p=c(Z*(T+c(B*Z)))}m=o(b,h,u),h=m[0],u=m[1],m=o(b,p,f),p=m[0],f=m[1];const w=y(p);return c(h*w)}(O,E);if($===yt)throw Error("Invalid private or public key received");return A($)}const I=A(t.Gu);function a(l){return P(l,I)}return{scalarMult:P,scalarMultBase:a,getSharedSecret:(l,v)=>P(l,v),getPublicKey:l=>a(l),utils:{randomPrivateKey:()=>t.randomBytes(t.nByteLength)},GuBytes:I}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const yn=me(()=>we.create({dkLen:114})),xt=(me(()=>we.create({dkLen:64})),BigInt("726838724295606890549323807888004534353641360687318060281490199180612328166730772686396383698676545930088884461843637361053498018365439")),pn=BigInt(1),ce=BigInt(2),de=BigInt(3);BigInt(4);const mn=BigInt(11),Bn=BigInt(22),ue=BigInt(44),wn=BigInt(88),En=BigInt(223);function Le(n){const t=xt,e=n*n*n%t,r=e*e*n%t,c=U(r,de,t)*r%t,i=U(c,de,t)*r%t,g=U(i,ce,t)*e%t,d=U(g,mn,t)*g%t,s=U(d,Bn,t)*d%t,y=U(s,ue,t)*s%t,o=U(y,wn,t)*y%t,B=U(o,ue,t)*s%t,A=U(B,ce,t)*e%t,P=U(A,pn,t)*n%t;return U(P,En,t)*A%t}function Ne(n){return n[0]&=252,n[55]|=128,n[56]=0,n}const $e=tt(xt,456,!0),xn={a:BigInt(1),d:BigInt("726838724295606890549323807888004534353641360687318060281490199180612328166730772686396383698676545930088884461843637361053498018326358"),Fp:$e,n:BigInt("181709681073901722637330951972001133588410340171829515070372549795146003961539585716195755291692375963310293709091662304773755859649779"),nBitLength:456,h:BigInt(4),Gx:BigInt("224580040295924300187604334099896036246789641632564134246125461686950415467406032909029192869357953282578032075146446173674602635247710"),Gy:BigInt("298819210078481492676017930443930673437544040154080242095928241372331506189835876003536878655418784733982303233503462500531545062832660"),hash:yn,randomBytes:Zt,adjustScalarBytes:Ne,domain:(n,t,e)=>{if(t.length>255)throw Error("Context is too big: "+t.length);return Be(Ve("SigEd448"),new Uint8Array([e?1:0,t.length]),t,n)},uvRatio:function(n,t){const e=xt,r=k(n*n*t,e),c=k(r*n,e),i=k(c*r*t,e),g=k(c*Le(i),e),d=k(g*g,e);return{isValid:k(d*t,e)===n,value:g}}},In=gn(xn),vn=bn({a:BigInt(156326),montgomeryBits:448,nByteLength:56,P:xt,Gu:BigInt(5),powPminus2:n=>{const t=xt;return k(U(Le(n),BigInt(2),t)*n,t)},adjustScalarBytes:Ne,randomBytes:Zt});$e.ORDER,BigInt(3),BigInt(4),BigInt(156326),BigInt("39082"),BigInt("78163"),BigInt("98944233647732219769177004876929019128417576295529901074099889598043702116001257856802131563896515373927712232092845883226922417596214"),BigInt("315019913931389607337177038330951043522456072897266928557328499619017160722351061360252776265186336876723201881398623946864393857820716"),BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const le=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),he=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Sn=BigInt(1),Tt=BigInt(2),ge=(n,t)=>(n+t/Tt)/t,Ft=tt(le,void 0,void 0,{sqrt:function(n){const t=le,e=BigInt(3),r=BigInt(6),c=BigInt(11),i=BigInt(22),g=BigInt(23),d=BigInt(44),s=BigInt(88),y=n*n*n%t,o=y*y*n%t,B=U(o,e,t)*o%t,A=U(B,e,t)*o%t,P=U(A,Tt,t)*y%t,I=U(P,c,t)*P%t,a=U(I,i,t)*I%t,l=U(a,d,t)*a%t,v=U(l,s,t)*l%t,O=U(v,d,t)*a%t,E=U(O,e,t)*o%t,$=U(E,g,t)*I%t,q=U($,r,t)*y%t,S=U(q,Tt,t);if(!Ft.eql(Ft.sqr(S),n))throw Error("Cannot find square root");return S}}),He=ht({a:BigInt(0),b:BigInt(7),Fp:Ft,n:he,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:n=>{const t=he,e=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-Sn*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),c=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=e,g=BigInt("0x100000000000000000000000000000000"),d=ge(i*n,t),s=ge(-r*n,t);let y=k(n-d*e-s*c,t),o=k(-d*r-s*i,t);const B=y>g,A=o>g;if(B&&(y=t-y),A&&(o=t-o),y>g||o>g)throw Error("splitScalar: Endomorphism failed, k="+n);return{k1neg:B,k1:y,k2neg:A,k2:o}}}},Ut);BigInt(0),He.ProjectivePoint;const be=tt(BigInt("0xa9fb57dba1eea9bc3e660a909d838d726e3bf623d52620282013481d1f6e5377")),An=ht({a:be.create(BigInt("0x7d5a0975fc2c3057eef67530417affe7fb8055c126dc5c6ce94a4b44f330b5d9")),b:BigInt("0x26dc5c6ce94a4b44f330b5d9bbd77cbf958416295cf7e1ce6bccdc18ff8c07b6"),Fp:be,n:BigInt("0xa9fb57dba1eea9bc3e660a909d838d718c397aa3b561a6f7901e0e82974856a7"),Gx:BigInt("0x8bd2aeb9cb7e57cb2c4b482ffc81b7afb9de27e1e3bd23c23a4453bd9ace3262"),Gy:BigInt("0x547ef835c3dac4fd97f8461a14611dc9c27745132ded8e545c1d54c72f046997"),h:BigInt(1),lowS:!1},Ut),ye=tt(BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b412b1da197fb71123acd3a729901d1a71874700133107ec53")),On=ht({a:ye.create(BigInt("0x7bc382c63d8c150c3c72080ace05afa0c2bea28e4fb22787139165efba91f90f8aa5814a503ad4eb04a8c7dd22ce2826")),b:BigInt("0x04a8c7dd22ce28268b39b55416f0447c2fb77de107dcd2a62e880ea53eeb62d57cb4390295dbc9943ab78696fa504c11"),Fp:ye,n:BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b31f166e6cac0425a7cf3ab6af6b7fc3103b883202e9046565"),Gx:BigInt("0x1d1c64f068cf45ffa2a63a81b7c13f6b8847a3e77ef14fe3db7fcafe0cbd10e8e826e03436d646aaef87b2e247d4af1e"),Gy:BigInt("0x8abe1d7520f9c2a45cb1eb8e95cfd55262b70b29feec5864e19c054ff99129280e4646217791811142820341263c5315"),h:BigInt(1),lowS:!1},Ee),pe=tt(BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca703308717d4d9b009bc66842aecda12ae6a380e62881ff2f2d82c68528aa6056583a48f3")),Rn=ht({a:pe.create(BigInt("0x7830a3318b603b89e2327145ac234cc594cbdd8d3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94ca")),b:BigInt("0x3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94cadc083e67984050b75ebae5dd2809bd638016f723"),Fp:pe,n:BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca70330870553e5c414ca92619418661197fac10471db1d381085ddaddb58796829ca90069"),Gx:BigInt("0x81aee4bdd82ed9645a21322e9c4c6a9385ed9f70b5d916c1b43b62eef4d0098eff3b1f78e2d0d48d50d1687b93b97d5f7c6d5047406a5e688b352209bcb9f822"),Gy:BigInt("0x7dde385d566332ecc0eabfa9cf7822fdf209f70024a57b1aa000c55b881f8111b2dcde494a5f485e5bca4bd88a2763aed1ca2b2fa8f0540678cd1e0f3ad80892"),h:BigInt(1),lowS:!1},xe),zn=new Map(Object.entries({nistP256:cn,nistP384:dn,nistP521:un,brainpoolP256r1:An,brainpoolP384r1:On,brainpoolP512r1:Rn,secp256k1:He,x448:vn,ed448:In}));export{zn as nobleCurves};
