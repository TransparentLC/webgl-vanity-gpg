import{I as jt,C as Fe,k as Q,i as Gt,B as Oe,n as Ge,x as ie,s as Ae,r as ht,m as Ht,L as Yt,c as $t,h as Xe,l as bt,b as zt,d as Dt,v as Mt,N as Xt,M as Wt,_ as Jt}from"./sha512.min-3GMt3wws.js";const He=BigInt(0),Ce=BigInt(1);function se(f,e=""){if(typeof f!="boolean")throw Error((e&&`"${e}"`)+"expected boolean, got type="+typeof f);return f}function _(f,e,r=""){const t=Ae(f),n=f?.length,o=e!==void 0;if(!t||o&&n!==e)throw Error((r&&`"${r}" `)+"expected Uint8Array"+(o?" of length "+e:"")+", got "+(t?"length="+n:"type="+typeof f));return f}function xe(f){const e=f.toString(16);return 1&e.length?"0"+e:e}function gt(f){if(typeof f!="string")throw Error("hex string expected, got "+typeof f);return f===""?He:BigInt("0x"+f)}function qe(f){return gt(ie(f))}function ae(f){return Ge(f),gt(ie(Uint8Array.from(f).reverse()))}function Ye(f,e){return Oe(f.toString(16).padStart(2*e,"0"))}function $e(f,e){return Ye(f,e).reverse()}function Y(f,e,r){let t;if(typeof e=="string")try{t=Oe(e)}catch(o){throw Error(f+" must be hex string or Uint8Array, cause: "+o)}else{if(!Ae(e))throw Error(f+" must be hex string or Uint8Array");t=Uint8Array.from(e)}const n=t.length;if(typeof r=="number"&&n!==r)throw Error(f+" of length "+r+" expected, got "+n);return t}function We(f){return Uint8Array.from(f)}const Ze=f=>typeof f=="bigint"&&He<=f;function we(f,e,r,t){if(!(function(n,o,a){return Ze(n)&&Ze(o)&&Ze(a)&&o<=n&&n<a})(e,r,t))throw Error("expected valid "+f+": "+r+" <= n < "+t+", got "+e)}function pt(f){let e;for(e=0;f>He;f>>=Ce,e+=1);return e}const Ee=f=>(Ce<<BigInt(f))-Ce;function pe(f,e,r={}){if(!f||typeof f!="object")throw Error("expected valid options object");function t(n,o,a){const d=f[n];if(a&&d===void 0)return;const i=typeof d;if(i!==o||d===null)throw Error(`param "${n}" is invalid: expected ${o}, got ${i}`)}Object.entries(e).forEach((([n,o])=>t(n,o,!1))),Object.entries(r).forEach((([n,o])=>t(n,o,!0)))}function Se(f){const e=new WeakMap;return(r,...t)=>{const n=e.get(r);if(n!==void 0)return n;const o=f(r,...t);return e.set(r,o),o}}const W=BigInt(0),X=BigInt(1),re=BigInt(2),yt=BigInt(3),mt=BigInt(4),Bt=BigInt(5),Qt=BigInt(7),wt=BigInt(8),_t=BigInt(9),Je=BigInt(16);function z(f,e){const r=f%e;return r>=W?r:e+r}function H(f,e,r){let t=f;for(;e-- >W;)t*=t,t%=r;return t}function Qe(f,e){if(f===W)throw Error("invert: expected non-zero number");if(e<=W)throw Error("invert: expected positive modulus, got "+e);let r=z(f,e),t=e,n=W,o=X;for(;r!==W;){const a=t%r,d=n-o*(t/r);t=r,r=a,n=o,o=d}if(t!==X)throw Error("invert: does not exist");return z(n,e)}function ze(f,e,r){if(!f.eql(f.sqr(e),r))throw Error("Cannot find square root")}function Et(f,e){const r=(f.ORDER+X)/mt,t=f.pow(e,r);return ze(f,t,e),t}function ef(f,e){const r=(f.ORDER-Bt)/wt,t=f.mul(e,re),n=f.pow(t,r),o=f.mul(e,n),a=f.mul(f.mul(o,re),n),d=f.mul(o,f.sub(a,f.ONE));return ze(f,d,e),d}function _e(f){if(f<yt)throw Error("sqrt is not defined for small field");let e=f-X,r=0;for(;e%re===W;)e/=re,r++;let t=re;const n=J(f);for(;et(n,t)===1;)if(t++>1e3)throw Error("Cannot find square root: probably non-prime P");if(r===1)return Et;let o=n.pow(t,e);const a=(e+X)/re;return function(d,i){if(d.is0(i))return i;if(et(d,i)!==1)throw Error("Cannot find square root");let K=r,E=d.mul(d.ONE,o),w=d.pow(i,e),c=d.pow(i,a);for(;!d.eql(w,d.ONE);){if(d.is0(w))return d.ZERO;let O=1,b=d.sqr(w);for(;!d.eql(b,d.ONE);)if(O++,b=d.sqr(b),O===K)throw Error("Cannot find square root");const V=X<<BigInt(K-O-1),q=d.pow(E,V);K=O,E=d.sqr(q),w=d.mul(w,E),c=d.mul(c,q)}return c}}function tf(f){return f%mt===yt?Et:f%wt===Bt?ef:f%Je===_t?(function(e){const r=J(e),t=_e(e),n=t(r,r.neg(r.ONE)),o=t(r,n),a=t(r,r.neg(n)),d=(e+Qt)/Je;return(i,K)=>{let E=i.pow(K,d),w=i.mul(E,n);const c=i.mul(E,o),O=i.mul(E,a),b=i.eql(i.sqr(w),K),V=i.eql(i.sqr(c),K);E=i.cmov(E,w,b),w=i.cmov(O,c,V);const q=i.eql(i.sqr(w),K),u=i.cmov(E,w,q);return ze(i,u,K),u}})(f):_e(f)}const ff=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function xt(f,e,r=!1){const t=Array(e.length).fill(r?f.ZERO:void 0),n=e.reduce(((a,d,i)=>f.is0(d)?a:(t[i]=a,f.mul(a,d))),f.ONE),o=f.inv(n);return e.reduceRight(((a,d,i)=>f.is0(d)?a:(t[i]=f.mul(a,t[i]),f.mul(a,d))),o),t}function et(f,e){const r=(f.ORDER-X)/re,t=f.pow(e,r),n=f.eql(t,f.ONE),o=f.eql(t,f.ZERO),a=f.eql(t,f.neg(f.ONE));if(!n&&!o&&!a)throw Error("invalid Legendre symbol result");return n?1:o?0:-1}function vt(f,e){e!==void 0&&Gt(e);const r=e!==void 0?e:f.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function J(f,e,r=!1,t={}){if(f<=W)throw Error("invalid field: expected ORDER > 0, got "+f);let n,o,a,d=!1;if(typeof e=="object"&&e!=null){if(t.sqrt||r)throw Error("cannot specify opts in two arguments");const c=e;c.BITS&&(n=c.BITS),c.sqrt&&(o=c.sqrt),typeof c.isLE=="boolean"&&(r=c.isLE),typeof c.modFromBytes=="boolean"&&(d=c.modFromBytes),a=c.allowedLengths}else typeof e=="number"&&(n=e),t.sqrt&&(o=t.sqrt);const{nBitLength:i,nByteLength:K}=vt(f,n);if(K>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let E;const w=Object.freeze({ORDER:f,isLE:r,BITS:i,BYTES:K,MASK:Ee(i),ZERO:W,ONE:X,allowedLengths:a,create:c=>z(c,f),isValid:c=>{if(typeof c!="bigint")throw Error("invalid field element: expected bigint, got "+typeof c);return W<=c&&c<f},is0:c=>c===W,isValidNot0:c=>!w.is0(c)&&w.isValid(c),isOdd:c=>(c&X)===X,neg:c=>z(-c,f),eql:(c,O)=>c===O,sqr:c=>z(c*c,f),add:(c,O)=>z(c+O,f),sub:(c,O)=>z(c-O,f),mul:(c,O)=>z(c*O,f),pow:(c,O)=>(function(b,V,q){if(q<W)throw Error("invalid exponent, negatives unsupported");if(q===W)return b.ONE;if(q===X)return V;let u=b.ONE,v=V;for(;q>W;)q&X&&(u=b.mul(u,v)),v=b.sqr(v),q>>=X;return u})(w,c,O),div:(c,O)=>z(c*Qe(O,f),f),sqrN:c=>c*c,addN:(c,O)=>c+O,subN:(c,O)=>c-O,mulN:(c,O)=>c*O,inv:c=>Qe(c,f),sqrt:o||(c=>(E||(E=tf(f)),E(w,c))),toBytes:c=>r?$e(c,K):Ye(c,K),fromBytes:(c,O=!0)=>{if(a){if(!a.includes(c.length)||c.length>K)throw Error("Field.fromBytes: expected "+a+" bytes, got "+c.length);const V=new Uint8Array(K);V.set(c,r?0:V.length-c.length),c=V}if(c.length!==K)throw Error("Field.fromBytes: expected "+K+" bytes, got "+c.length);let b=r?ae(c):qe(c);if(d&&(b=z(b,f)),!O&&!w.isValid(b))throw Error("invalid field element: outside of range 0..ORDER");return b},invertBatch:c=>xt(w,c),cmov:(c,O,b)=>b?O:c});return Object.freeze(w)}function It(f){if(typeof f!="bigint")throw Error("field order must be bigint");const e=f.toString(2).length;return Math.ceil(e/8)}function tt(f){const e=It(f);return e+Math.ceil(e/2)}class Ot extends Ht{constructor(e,r){super(),this.finished=!1,this.destroyed=!1,ht(e);const t=Yt(r);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const n=this.blockLen,o=new Uint8Array(n);o.set(t.length>n?e.create().update(t).digest():t);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),$t(o)}update(e){return Xe(this),this.iHash.update(e),this}digestInto(e){Xe(this),Ge(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:r,iHash:t,finished:n,destroyed:o,blockLen:a,outputLen:d}=this;return e.finished=n,e.destroyed=o,e.blockLen=a,e.outputLen=d,e.oHash=r._cloneInto(e.oHash),e.iHash=t._cloneInto(e.iHash),e}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const St=(f,e,r)=>new Ot(f,e).update(r).digest();St.create=(f,e)=>new Ot(f,e);const ge=BigInt(0),ne=BigInt(1);function Re(f,e){const r=e.negate();return f?r:e}function oe(f,e){const r=xt(f.Fp,e.map((t=>t.Z)));return e.map(((t,n)=>f.fromAffine(t.toAffine(r[n]))))}function Rt(f,e){if(!Number.isSafeInteger(f)||f<=0||f>e)throw Error("invalid window size, expected [1.."+e+"], got W="+f)}function Ne(f,e){Rt(f,e);const r=2**f;return{windows:Math.ceil(e/f)+1,windowSize:2**(f-1),mask:Ee(f),maxNumber:r,shiftBy:BigInt(f)}}function ft(f,e,r){const{windowSize:t,mask:n,maxNumber:o,shiftBy:a}=r;let d=Number(f&n),i=f>>a;d>t&&(d-=o,i+=ne);const K=e*t;return{nextN:i,offset:K+Math.abs(d)-1,isZero:d===0,isNeg:d<0,isNegF:e%2!=0,offsetF:K}}const Ke=new WeakMap,Ft=new WeakMap;function Pe(f){return Ft.get(f)||1}function rt(f){if(f!==ge)throw Error("invalid wNAF")}class At{constructor(e,r){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=r}_unsafeLadder(e,r,t=this.ZERO){let n=e;for(;r>ge;)r&ne&&(t=t.add(n)),n=n.double(),r>>=ne;return t}precomputeWindow(e,r){const{windows:t,windowSize:n}=Ne(r,this.bits),o=[];let a=e,d=a;for(let i=0;i<t;i++){d=a,o.push(d);for(let K=1;K<n;K++)d=d.add(a),o.push(d);a=d.double()}return o}wNAF(e,r,t){if(!this.Fn.isValid(t))throw Error("invalid scalar");let n=this.ZERO,o=this.BASE;const a=Ne(e,this.bits);for(let d=0;d<a.windows;d++){const{nextN:i,offset:K,isZero:E,isNeg:w,isNegF:c,offsetF:O}=ft(t,d,a);t=i,E?o=o.add(Re(c,r[O])):n=n.add(Re(w,r[K]))}return rt(t),{p:n,f:o}}wNAFUnsafe(e,r,t,n=this.ZERO){const o=Ne(e,this.bits);for(let a=0;a<o.windows&&t!==ge;a++){const{nextN:d,offset:i,isZero:K,isNeg:E}=ft(t,a,o);if(t=d,!K){const w=r[i];n=n.add(E?w.negate():w)}}return rt(t),n}getPrecomputes(e,r,t){let n=Ke.get(r);return n||(n=this.precomputeWindow(r,e),e!==1&&(typeof t=="function"&&(n=t(n)),Ke.set(r,n))),n}cached(e,r,t){const n=Pe(e);return this.wNAF(n,this.getPrecomputes(n,e,t),r)}unsafe(e,r,t,n){const o=Pe(e);return o===1?this._unsafeLadder(e,r,n):this.wNAFUnsafe(o,this.getPrecomputes(o,e,t),r,n)}createCache(e,r){Rt(r,this.bits),Ft.set(e,r),Ke.delete(e)}hasCache(e){return Pe(e)!==1}}function qt(f,e,r,t){(function(c,O){if(!Array.isArray(c))throw Error("array expected");c.forEach(((b,V)=>{if(!(b instanceof O))throw Error("invalid point at index "+V)}))})(r,f),(function(c,O){if(!Array.isArray(c))throw Error("array of scalars expected");c.forEach(((b,V)=>{if(!O.isValid(b))throw Error("invalid scalar at index "+V)}))})(t,e);const n=r.length,o=t.length;if(n!==o)throw Error("arrays of points and scalars must have equal length");const a=f.ZERO,d=pt(BigInt(n));let i=1;d>12?i=d-3:d>4?i=d-2:d>0&&(i=2);const K=Ee(i),E=Array(Number(K)+1).fill(a);let w=a;for(let c=Math.floor((e.BITS-1)/i)*i;c>=0;c-=i){E.fill(a);for(let b=0;b<o;b++){const V=t[b],q=Number(V>>BigInt(c)&K);E[q]=E[q].add(r[b])}let O=a;for(let b=E.length-1,V=a;b>0;b--)V=V.add(E[b]),O=O.add(V);if(w=w.add(O),c!==0)for(let b=0;b<i;b++)w=w.double()}return w}function nt(f,e,r){if(e){if(e.ORDER!==f)throw Error("Field.ORDER must match order: Fp == p, Fn == n");return(function(t){pe(t,ff.reduce(((n,o)=>(n[o]="function",n)),{ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"}))})(e),e}return J(f,{isLE:r})}function Zt(f,e,r={},t){if(t===void 0&&(t=f==="edwards"),!e||typeof e!="object")throw Error(`expected valid ${f} CURVE object`);for(const d of["p","n","h"]){const i=e[d];if(!(typeof i=="bigint"&&i>ge))throw Error(`CURVE.${d} must be positive bigint`)}const n=nt(e.p,r.Fp,t),o=nt(e.n,r.Fn,t),a=["Gx","Gy","a",f==="weierstrass"?"b":"d"];for(const d of a)if(!n.isValid(e[d]))throw Error(`CURVE.${d} must be valid field element of CURVE.Fp`);return{CURVE:e=Object.freeze(Object.assign({},e)),Fp:n,Fn:o}}const ot=(f,e)=>(f+(f>=0?e:-e)/Nt)/e;function Te(f){if(!["compact","recovered","der"].includes(f))throw Error('Signature format must be "compact", "recovered", or "der"');return f}function Ue(f,e){const r={};for(let t of Object.keys(e))r[t]=f[t]===void 0?e[t]:f[t];return se(r.lowS,"lowS"),se(r.prehash,"prehash"),r.format!==void 0&&Te(r.format),r}const ee={Err:class extends Error{constructor(f=""){super(f)}},_tlv:{encode:(f,e)=>{const{Err:r}=ee;if(f<0||f>256)throw new r("tlv.encode: wrong tag");if(1&e.length)throw new r("tlv.encode: unpadded data");const t=e.length/2,n=xe(t);if(n.length/2&128)throw new r("tlv.encode: long form length too big");const o=t>127?xe(n.length/2|128):"";return xe(f)+o+n+e},decode(f,e){const{Err:r}=ee;let t=0;if(f<0||f>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[t++]!==f)throw new r("tlv.decode: wrong tlv");const n=e[t++];let o=0;if(128&n){const d=127&n;if(!d)throw new r("tlv.decode(long): indefinite length not supported");if(d>4)throw new r("tlv.decode(long): byte length is too big");const i=e.subarray(t,t+d);if(i.length!==d)throw new r("tlv.decode: length bytes not complete");if(i[0]===0)throw new r("tlv.decode(long): zero leftmost byte");for(const K of i)o=o<<8|K;if(t+=d,o<128)throw new r("tlv.decode(long): not minimal encoding")}else o=n;const a=e.subarray(t,t+o);if(a.length!==o)throw new r("tlv.decode: wrong value length");return{v:a,l:e.subarray(t+o)}}},_int:{encode(f){const{Err:e}=ee;if(f<te)throw new e("integer: negative integers are not allowed");let r=xe(f);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(f){const{Err:e}=ee;if(128&f[0])throw new e("invalid signature integer: negative");if(f[0]===0&&!(128&f[1]))throw new e("invalid signature integer: unnecessary leading zero");return qe(f)}},toSig(f){const{Err:e,_int:r,_tlv:t}=ee,n=Y("signature",f),{v:o,l:a}=t.decode(48,n);if(a.length)throw new e("invalid signature: left bytes after parsing");const{v:d,l:i}=t.decode(2,o),{v:K,l:E}=t.decode(2,i);if(E.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(d),s:r.decode(K)}},hexFromSig(f){const{_tlv:e,_int:r}=ee,t=e.encode(2,r.encode(f.r))+e.encode(2,r.encode(f.s));return e.encode(48,t)}},te=BigInt(0),he=BigInt(1),Nt=BigInt(2),ve=BigInt(3),rf=BigInt(4);function be(f,e){const{BYTES:r}=f;let t;if(typeof e=="bigint")t=e;else{let n=Y("private key",e);try{t=f.fromBytes(n)}catch{throw Error(`invalid private key: expected ui8a of size ${r}, got ${typeof e}`)}}if(!f.isValidNot0(t))throw Error("invalid private key: out of range [1..N-1]");return t}function nf(f,e={}){const r=Zt("weierstrass",f,e),{Fp:t,Fn:n}=r;let o=r.CURVE;const{h:a,n:d}=o;pe(e,{},{allowInfinityPoint:"boolean",clearCofactor:"function",isTorsionFree:"function",fromBytes:"function",toBytes:"function",endo:"object",wrapPrivateKey:"boolean"});const{endo:i}=e;if(i&&(!t.is0(o.a)||typeof i.beta!="bigint"||!Array.isArray(i.basises)))throw Error('invalid endo: expected "beta": bigint and "basises": array');const K=Pt(t,n);function E(){if(!t.isOdd)throw Error("compression is not supported: Field does not have .isOdd()")}const w=e.toBytes||function(g,s,h){const{x:y,y:I}=s.toAffine(),N=t.toBytes(y);if(se(h,"isCompressed"),h){E();const m=!t.isOdd(I);return Q(Kt(m),N)}return Q(Uint8Array.of(4),N,t.toBytes(I))},c=e.fromBytes||function(g){_(g,void 0,"Point");const{publicKey:s,publicKeyUncompressed:h}=K,y=g.length,I=g[0],N=g.subarray(1);if(y!==s||I!==2&&I!==3){if(y===h&&I===4){const m=t.BYTES,x=t.fromBytes(N.subarray(0,m)),B=t.fromBytes(N.subarray(m,2*m));if(!b(x,B))throw Error("bad point: is not on curve");return{x,y:B}}throw Error(`bad point: got length ${y}, expected compressed=${s} or uncompressed=${h}`)}{const m=t.fromBytes(N);if(!t.isValid(m))throw Error("bad point: is not on curve, wrong x");const x=O(m);let B;try{B=t.sqrt(x)}catch(Z){const F=Z instanceof Error?": "+Z.message:"";throw Error("bad point: is not on curve, sqrt error"+F)}return E(),!(1&~I)!==t.isOdd(B)&&(B=t.neg(B)),{x:m,y:B}}};function O(g){const s=t.sqr(g),h=t.mul(s,g);return t.add(t.add(h,t.mul(g,o.a)),o.b)}function b(g,s){const h=t.sqr(s),y=O(g);return t.eql(h,y)}if(!b(o.Gx,o.Gy))throw Error("bad curve params: generator point");const V=t.mul(t.pow(o.a,ve),rf),q=t.mul(t.sqr(o.b),BigInt(27));if(t.is0(t.add(V,q)))throw Error("bad curve params: a or b");function u(g,s,h=!1){if(!t.isValid(s)||h&&t.is0(s))throw Error("bad point coordinate "+g);return s}function v(g){if(!(g instanceof R))throw Error("ProjectivePoint expected")}function p(g){if(!i||!i.basises)throw Error("no endo");return(function(s,h,y){const[[I,N],[m,x]]=h,B=ot(x*s,y),Z=ot(-N*s,y);let F=s-B*I-Z*m,L=-B*N-Z*x;const T=F<te,U=L<te;T&&(F=-F),U&&(L=-L);const j=Ee(Math.ceil(pt(y)/2))+he;if(F<te||F>=j||L<te||L>=j)throw Error("splitScalar (endomorphism): failed, k="+s);return{k1neg:T,k1:F,k2neg:U,k2:L}})(g,i.basises,n.ORDER)}const S=Se(((g,s)=>{const{X:h,Y:y,Z:I}=g;if(t.eql(I,t.ONE))return{x:h,y};const N=g.is0();s==null&&(s=N?t.ONE:t.inv(I));const m=t.mul(h,s),x=t.mul(y,s),B=t.mul(I,s);if(N)return{x:t.ZERO,y:t.ZERO};if(!t.eql(B,t.ONE))throw Error("invZ was invalid");return{x:m,y:x}})),P=Se((g=>{if(g.is0()){if(e.allowInfinityPoint&&!t.is0(g.Y))return;throw Error("bad point: ZERO")}const{x:s,y:h}=g.toAffine();if(!t.isValid(s)||!t.isValid(h))throw Error("bad point: x or y not field elements");if(!b(s,h))throw Error("bad point: equation left != right");if(!g.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0}));function C(g,s,h,y,I){return h=new R(t.mul(h.X,g),h.Y,h.Z),s=Re(y,s),h=Re(I,h),s.add(h)}class R{constructor(s,h,y){this.X=u("x",s),this.Y=u("y",h,!0),this.Z=u("z",y),Object.freeze(this)}static CURVE(){return o}static fromAffine(s){const{x:h,y}=s||{};if(!s||!t.isValid(h)||!t.isValid(y))throw Error("invalid affine point");if(s instanceof R)throw Error("projective point not allowed");return t.is0(h)&&t.is0(y)?R.ZERO:new R(h,y,t.ONE)}static fromBytes(s){const h=R.fromAffine(c(_(s,void 0,"point")));return h.assertValidity(),h}static fromHex(s){return R.fromBytes(Y("pointHex",s))}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(s=8,h=!0){return l.createCache(this,s),h||this.multiply(ve),this}assertValidity(){P(this)}hasEvenY(){const{y:s}=this.toAffine();if(!t.isOdd)throw Error("Field doesn't support isOdd");return!t.isOdd(s)}equals(s){v(s);const{X:h,Y:y,Z:I}=this,{X:N,Y:m,Z:x}=s,B=t.eql(t.mul(h,x),t.mul(N,I)),Z=t.eql(t.mul(y,x),t.mul(m,I));return B&&Z}negate(){return new R(this.X,t.neg(this.Y),this.Z)}double(){const{a:s,b:h}=o,y=t.mul(h,ve),{X:I,Y:N,Z:m}=this;let x=t.ZERO,B=t.ZERO,Z=t.ZERO,F=t.mul(I,I),L=t.mul(N,N),T=t.mul(m,m),U=t.mul(I,N);return U=t.add(U,U),Z=t.mul(I,m),Z=t.add(Z,Z),x=t.mul(s,Z),B=t.mul(y,T),B=t.add(x,B),x=t.sub(L,B),B=t.add(L,B),B=t.mul(x,B),x=t.mul(U,x),Z=t.mul(y,Z),T=t.mul(s,T),U=t.sub(F,T),U=t.mul(s,U),U=t.add(U,Z),Z=t.add(F,F),F=t.add(Z,F),F=t.add(F,T),F=t.mul(F,U),B=t.add(B,F),T=t.mul(N,m),T=t.add(T,T),F=t.mul(T,U),x=t.sub(x,F),Z=t.mul(T,L),Z=t.add(Z,Z),Z=t.add(Z,Z),new R(x,B,Z)}add(s){v(s);const{X:h,Y:y,Z:I}=this,{X:N,Y:m,Z:x}=s;let B=t.ZERO,Z=t.ZERO,F=t.ZERO;const L=o.a,T=t.mul(o.b,ve);let U=t.mul(h,N),j=t.mul(y,m),k=t.mul(I,x),$=t.add(h,y),G=t.add(N,m);$=t.mul($,G),G=t.add(U,j),$=t.sub($,G),G=t.add(h,I);let D=t.add(N,x);return G=t.mul(G,D),D=t.add(U,k),G=t.sub(G,D),D=t.add(y,I),B=t.add(m,x),D=t.mul(D,B),B=t.add(j,k),D=t.sub(D,B),F=t.mul(L,G),B=t.mul(T,k),F=t.add(B,F),B=t.sub(j,F),F=t.add(j,F),Z=t.mul(B,F),j=t.add(U,U),j=t.add(j,U),k=t.mul(L,k),G=t.mul(T,G),j=t.add(j,k),k=t.sub(U,k),k=t.mul(L,k),G=t.add(G,k),U=t.mul(j,G),Z=t.add(Z,U),U=t.mul(D,G),B=t.mul($,B),B=t.sub(B,U),U=t.mul($,j),F=t.mul(D,F),F=t.add(F,U),new R(B,Z,F)}subtract(s){return this.add(s.negate())}is0(){return this.equals(R.ZERO)}multiply(s){const{endo:h}=e;if(!n.isValidNot0(s))throw Error("invalid scalar: out of range");let y,I;const N=m=>l.cached(this,m,(x=>oe(R,x)));if(h){const{k1neg:m,k1:x,k2neg:B,k2:Z}=p(s),{p:F,f:L}=N(x),{p:T,f:U}=N(Z);I=L.add(U),y=C(h.beta,F,T,m,B)}else{const{p:m,f:x}=N(s);y=m,I=x}return oe(R,[y,I])[0]}multiplyUnsafe(s){const{endo:h}=e,y=this;if(!n.isValid(s))throw Error("invalid scalar: out of range");if(s===te||y.is0())return R.ZERO;if(s===he)return y;if(l.hasCache(this))return this.multiply(s);if(h){const{k1neg:I,k1:N,k2neg:m,k2:x}=p(s),{p1:B,p2:Z}=(function(F,L,T,U){let j=L,k=F.ZERO,$=F.ZERO;for(;T>ge||U>ge;)T&ne&&(k=k.add(j)),U&ne&&($=$.add(j)),j=j.double(),T>>=ne,U>>=ne;return{p1:k,p2:$}})(R,y,N,x);return C(h.beta,B,Z,I,m)}return l.unsafe(y,s)}multiplyAndAddUnsafe(s,h,y){const I=this.multiplyUnsafe(h).add(s.multiplyUnsafe(y));return I.is0()?void 0:I}toAffine(s){return S(this,s)}isTorsionFree(){const{isTorsionFree:s}=e;return a===he||(s?s(R,this):l.unsafe(this,d).is0())}clearCofactor(){const{clearCofactor:s}=e;return a===he?this:s?s(R,this):this.multiplyUnsafe(a)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}toBytes(s=!0){return se(s,"isCompressed"),this.assertValidity(),w(R,this,s)}toHex(s=!0){return ie(this.toBytes(s))}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get px(){return this.X}get py(){return this.X}get pz(){return this.Z}toRawBytes(s=!0){return this.toBytes(s)}_setWindowSize(s){this.precompute(s)}static normalizeZ(s){return oe(R,s)}static msm(s,h){return qt(R,n,s,h)}static fromPrivateKey(s){return R.BASE.multiply(be(n,s))}}R.BASE=new R(o.Gx,o.Gy,t.ONE),R.ZERO=new R(t.ZERO,t.ONE,t.ZERO),R.Fp=t,R.Fn=n;const A=n.BITS,l=new At(R,e.endo?Math.ceil(A/2):A);return R.BASE.precompute(8),R}function Kt(f){return Uint8Array.of(f?2:3)}function Pt(f,e){return{secretKey:e.BYTES,publicKey:1+f.BYTES,publicKeyUncompressed:1+2*f.BYTES,publicKeyHasPrefix:!0,signature:2*e.BYTES}}function of(f,e={}){const{Fn:r}=f,t=e.randomBytes||Fe,n=Object.assign(Pt(f.Fp,r),{seed:tt(r.ORDER)});function o(E){try{return!!be(r,E)}catch{return!1}}function a(E=t(n.seed)){return(function(w,c,O=!1){const b=w.length,V=It(c),q=tt(c);if(b<16||b<q||b>1024)throw Error("expected "+q+"-1024 bytes of input, got "+b);const u=z(O?ae(w):qe(w),c-X)+X;return O?$e(u,V):Ye(u,V)})(_(E,n.seed,"seed"),r.ORDER)}function d(E,w=!0){return f.BASE.multiply(be(r,E)).toBytes(w)}function i(E){if(typeof E=="bigint")return!1;if(E instanceof f)return!0;const{secretKey:w,publicKey:c,publicKeyUncompressed:O}=n;if(r.allowedLengths||w===c)return;const b=Y("key",E).length;return b===c||b===O}return Object.freeze({getPublicKey:d,getSharedSecret:function(E,w,c=!0){if(i(E)===!0)throw Error("first arg must be private key");if(i(w)===!1)throw Error("second arg must be public key");const O=be(r,E);return f.fromHex(w).multiply(O).toBytes(c)},keygen:function(E){const w=a(E);return{secretKey:w,publicKey:d(w)}},Point:f,utils:{isValidSecretKey:o,isValidPublicKey:function(E,w){const{publicKey:c,publicKeyUncompressed:O}=n;try{const b=E.length;return(w!==!0||b===c)&&(w!==!1||b===O)&&!!f.fromBytes(E)}catch{return!1}},randomSecretKey:a,isValidPrivateKey:o,randomPrivateKey:a,normPrivateKeyToScalar:E=>be(r,E),precompute:(E=8,w=f.BASE)=>w.precompute(E,!1)},lengths:n})}function sf(f,e,r={}){ht(e),pe(r,{},{hmac:"function",lowS:"boolean",randomBytes:"function",bits2int:"function",bits2int_modN:"function"});const t=r.randomBytes||Fe,n=r.hmac||((A,...l)=>St(e,A,Q(...l))),{Fp:o,Fn:a}=f,{ORDER:d,BITS:i}=a,{keygen:K,getPublicKey:E,getSharedSecret:w,utils:c,lengths:O}=of(f,r),b={prehash:!1,lowS:typeof r.lowS=="boolean"&&r.lowS,format:void 0,extraEntropy:!1},V="compact";function q(A){return A>d>>he}function u(A,l){if(!a.isValidNot0(l))throw Error(`invalid signature ${A}: out of range 1..Point.Fn.ORDER`);return l}class v{constructor(l,g,s){this.r=u("r",l),this.s=u("s",g),s!=null&&(this.recovery=s),Object.freeze(this)}static fromBytes(l,g=V){let s;if((function(N,m){Te(m);const x=O.signature;_(N,m==="compact"?x:m==="recovered"?x+1:void 0,m+" signature")})(l,g),g==="der"){const{r:N,s:m}=ee.toSig(_(l));return new v(N,m)}g==="recovered"&&(s=l[0],g="compact",l=l.subarray(1));const h=a.BYTES,y=l.subarray(0,h),I=l.subarray(h,2*h);return new v(a.fromBytes(y),a.fromBytes(I),s)}static fromHex(l,g){return this.fromBytes(Oe(l),g)}addRecoveryBit(l){return new v(this.r,this.s,l)}recoverPublicKey(l){const g=o.ORDER,{r:s,s:h,recovery:y}=this;if(y==null||![0,1,2,3].includes(y))throw Error("recovery id invalid");if(d*Nt<g&&y>1)throw Error("recovery id is ambiguous for h>1 curve");const I=y===2||y===3?s+d:s;if(!o.isValid(I))throw Error("recovery id 2 or 3 invalid");const N=o.toBytes(I),m=f.fromBytes(Q(Kt(!(1&y)),N)),x=a.inv(I),B=S(Y("msgHash",l)),Z=a.create(-B*x),F=a.create(h*x),L=f.BASE.multiplyUnsafe(Z).add(m.multiplyUnsafe(F));if(L.is0())throw Error("point at infinify");return L.assertValidity(),L}hasHighS(){return q(this.s)}toBytes(l=V){if(Te(l),l==="der")return Oe(ee.hexFromSig(this));const g=a.toBytes(this.r),s=a.toBytes(this.s);if(l==="recovered"){if(this.recovery==null)throw Error("recovery bit must be present");return Q(Uint8Array.of(this.recovery),g,s)}return Q(g,s)}toHex(l){return ie(this.toBytes(l))}assertValidity(){}static fromCompact(l){return v.fromBytes(Y("sig",l),"compact")}static fromDER(l){return v.fromBytes(Y("sig",l),"der")}normalizeS(){return this.hasHighS()?new v(this.r,a.neg(this.s),this.recovery):this}toDERRawBytes(){return this.toBytes("der")}toDERHex(){return ie(this.toBytes("der"))}toCompactRawBytes(){return this.toBytes("compact")}toCompactHex(){return ie(this.toBytes("compact"))}}const p=r.bits2int||function(A){if(A.length>8192)throw Error("input is too large");const l=qe(A),g=8*A.length-i;return g>0?l>>BigInt(g):l},S=r.bits2int_modN||function(A){return a.create(p(A))},P=Ee(i);function C(A){return we("num < 2^"+i,A,te,P),a.toBytes(A)}function R(A,l){return _(A,void 0,"message"),l?_(e(A),void 0,"prehashed message"):A}return Object.freeze({keygen:K,getPublicKey:E,getSharedSecret:w,utils:c,lengths:O,Point:f,sign:function(A,l,g={}){A=Y("message",A);const{seed:s,k2sig:h}=(function(y,I,N){if(["recovered","canonical"].some((j=>j in N)))throw Error("sign() legacy options not supported");const{lowS:m,prehash:x,extraEntropy:B}=Ue(N,b);y=R(y,x);const Z=S(y),F=be(a,I),L=[C(F),C(Z)];if(B!=null&&B!==!1){const j=B===!0?t(O.secretKey):B;L.push(Y("extraEntropy",j))}const T=Q(...L),U=Z;return{seed:T,k2sig:function(j){const k=p(j);if(!a.isValidNot0(k))return;const $=a.inv(k),G=f.BASE.multiply(k).toAffine(),D=a.create(G.x);if(D===te)return;const ue=a.create($*a.create(U+D*F));if(ue===te)return;let ye=(G.x===D?0:2)|Number(G.y&he),me=ue;return m&&q(ue)&&(me=a.neg(ue),ye^=1),new v(D,me,ye)}}})(A,l,g);return(function(y,I,N){if(typeof y!="number"||y<2)throw Error("hashLen must be a number");if(typeof I!="number"||I<2)throw Error("qByteLen must be a number");if(typeof N!="function")throw Error("hmacFn must be a function");const m=k=>new Uint8Array(k),x=k=>Uint8Array.of(k);let B=m(y),Z=m(y),F=0;const L=()=>{B.fill(1),Z.fill(0),F=0},T=(...k)=>N(Z,B,...k),U=(k=m(0))=>{Z=T(x(0),k),B=T(),k.length!==0&&(Z=T(x(1),k),B=T())},j=()=>{if(F++>=1e3)throw Error("drbg: tried 1000 values");let k=0;const $=[];for(;k<I;){B=T();const G=B.slice();$.push(G),k+=B.length}return Q(...$)};return(k,$)=>{let G;for(L(),U(k);!(G=$(j()));)U();return L(),G}})(e.outputLen,a.BYTES,n)(s,h)},verify:function(A,l,g,s={}){const{lowS:h,prehash:y,format:I}=Ue(s,b);if(g=Y("publicKey",g),l=R(Y("message",l),y),"strict"in s)throw Error("options.strict was renamed to lowS");const N=I===void 0?(function(m){let x;const B=typeof m=="string"||Ae(m),Z=!B&&m!==null&&typeof m=="object"&&typeof m.r=="bigint"&&typeof m.s=="bigint";if(!B&&!Z)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");if(Z)x=new v(m.r,m.s);else if(B){try{x=v.fromBytes(Y("sig",m),"der")}catch(F){if(!(F instanceof ee.Err))throw F}if(!x)try{x=v.fromBytes(Y("sig",m),"compact")}catch{return!1}}return x||!1})(A):v.fromBytes(Y("sig",A),I);if(N===!1)return!1;try{const m=f.fromBytes(g);if(h&&N.hasHighS())return!1;const{r:x,s:B}=N,Z=S(l),F=a.inv(B),L=a.create(Z*F),T=a.create(x*F),U=f.BASE.multiplyUnsafe(L).add(m.multiplyUnsafe(T));return U.is0()?!1:a.create(U.x)===x}catch{return!1}},recoverPublicKey:function(A,l,g={}){const{prehash:s}=Ue(g,b);return l=R(l,s),v.fromBytes(A,"recovered").recoverPublicKey(l).toBytes()},Signature:v,hash:e})}function af(f){const{CURVE:e,curveOpts:r}=(function(n){const o={a:n.a,b:n.b,p:n.Fp.ORDER,n:n.n,h:n.h,Gx:n.Gx,Gy:n.Gy},a=n.Fp;let d=n.allowedPrivateKeyLengths?Array.from(new Set(n.allowedPrivateKeyLengths.map((i=>Math.ceil(i/2))))):void 0;return{CURVE:o,curveOpts:{Fp:a,Fn:J(o.n,{BITS:n.nBitLength,allowedLengths:d,modFromBytes:n.wrapPrivateKey}),allowInfinityPoint:n.allowInfinityPoint,endo:n.endo,isTorsionFree:n.isTorsionFree,clearCofactor:n.clearCofactor,fromBytes:n.fromBytes,toBytes:n.toBytes}}})(f),t={hmac:f.hmac,randomBytes:f.randomBytes,lowS:f.lowS,bits2int:f.bits2int,bits2int_modN:f.bits2int_modN};return{CURVE:e,curveOpts:r,hash:f.hash,ecdsaOpts:t}}function cf(f){const{CURVE:e,curveOpts:r,hash:t,ecdsaOpts:n}=af(f);return(function(o,a){const d=a.Point;return Object.assign({},a,{ProjectivePoint:d,CURVE:Object.assign({},o,vt(d.Fn.ORDER,d.Fn.BITS))})})(f,sf(nf(e,r),t,n))}function ce(f,e){const r=t=>cf({...f,hash:t});return{...r(e),create:r}}const Ut={p:BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"),n:BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),h:BigInt(1),a:BigInt("0xffffffff00000001000000000000000000000000fffffffffffffffffffffffc"),b:BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b"),Gx:BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),Gy:BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5")},Vt={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000ffffffff"),n:BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffc7634d81f4372ddf581a0db248b0a77aecec196accc52973"),h:BigInt(1),a:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffff0000000000000000fffffffc"),b:BigInt("0xb3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef"),Gx:BigInt("0xaa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7"),Gy:BigInt("0x3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f")},Ct={p:BigInt("0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x01fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa51868783bf2f966b7fcc0148f709a5d03bb5c9b8899c47aebb6fb71e91386409"),h:BigInt(1),a:BigInt("0x1fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc"),b:BigInt("0x0051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00"),Gx:BigInt("0x00c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66"),Gy:BigInt("0x011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650")},df=J(Ut.p),uf=J(Vt.p),lf=J(Ct.p),hf=ce({...Ut,Fp:df,lowS:!1},bt),bf=ce({...Vt,Fp:uf,lowS:!1},zt),gf=ce({...Ct,Fp:lf,lowS:!1,allowedPrivateKeyLengths:[130,131,132]},Dt),fe=BigInt(0),M=BigInt(1),Ve=BigInt(2),pf=BigInt(8);function Tt(f,e={}){const r=Zt("edwards",f,e,e.FpFnLE),{Fp:t,Fn:n}=r;let o=r.CURVE;const{h:a}=o;pe(e,{},{uvRatio:"function"});const d=Ve<<BigInt(8*n.BYTES)-M,i=q=>t.create(q),K=e.uvRatio||((q,u)=>{try{return{isValid:!0,value:t.sqrt(t.div(q,u))}}catch{return{isValid:!1,value:fe}}});if(!(function(q,u,v,p){const S=q.sqr(v),P=q.sqr(p),C=q.add(q.mul(u.a,S),P),R=q.add(q.ONE,q.mul(u.d,q.mul(S,P)));return q.eql(C,R)})(t,o,o.Gx,o.Gy))throw Error("bad curve params: generator point");function E(q,u,v=!1){return we("coordinate "+q,u,v?M:fe,d),u}function w(q){if(!(q instanceof b))throw Error("ExtendedPoint expected")}const c=Se(((q,u)=>{const{X:v,Y:p,Z:S}=q,P=q.is0();u==null&&(u=P?pf:t.inv(S));const C=i(v*u),R=i(p*u),A=t.mul(S,u);if(P)return{x:fe,y:M};if(A!==M)throw Error("invZ was invalid");return{x:C,y:R}})),O=Se((q=>{const{a:u,d:v}=o;if(q.is0())throw Error("bad point: ZERO");const{X:p,Y:S,Z:P,T:C}=q,R=i(p*p),A=i(S*S),l=i(P*P),g=i(l*l),s=i(R*u);if(i(l*i(s+A))!==i(g+i(v*i(R*A))))throw Error("bad point: equation left != right (1)");if(i(p*S)!==i(P*C))throw Error("bad point: equation left != right (2)");return!0}));class b{constructor(u,v,p,S){this.X=E("x",u),this.Y=E("y",v),this.Z=E("z",p,!0),this.T=E("t",S),Object.freeze(this)}static CURVE(){return o}static fromAffine(u){if(u instanceof b)throw Error("extended point not allowed");const{x:v,y:p}=u||{};return E("x",v),E("y",p),new b(v,p,M,i(v*p))}static fromBytes(u,v=!1){const p=t.BYTES,{a:S,d:P}=o;u=We(_(u,p,"point")),se(v,"zip215");const C=We(u),R=u[p-1];C[p-1]=-129&R;const A=ae(C),l=v?d:t.ORDER;we("point.y",A,fe,l);const g=i(A*A),s=i(g-M),h=i(P*g-S);let{isValid:y,value:I}=K(s,h);if(!y)throw Error("bad point: invalid y coordinate");const N=(I&M)===M,m=!!(128&R);if(!v&&I===fe&&m)throw Error("bad point: x=0 and x_0=1");return m!==N&&(I=i(-I)),b.fromAffine({x:I,y:A})}static fromHex(u,v=!1){return b.fromBytes(Y("point",u),v)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(u=8,v=!0){return V.createCache(this,u),v||this.multiply(Ve),this}assertValidity(){O(this)}equals(u){w(u);const{X:v,Y:p,Z:S}=this,{X:P,Y:C,Z:R}=u,A=i(v*R),l=i(P*S),g=i(p*R),s=i(C*S);return A===l&&g===s}is0(){return this.equals(b.ZERO)}negate(){return new b(i(-this.X),this.Y,this.Z,i(-this.T))}double(){const{a:u}=o,{X:v,Y:p,Z:S}=this,P=i(v*v),C=i(p*p),R=i(Ve*i(S*S)),A=i(u*P),l=v+p,g=i(i(l*l)-P-C),s=A+C,h=s-R,y=A-C,I=i(g*h),N=i(s*y),m=i(g*y),x=i(h*s);return new b(I,N,x,m)}add(u){w(u);const{a:v,d:p}=o,{X:S,Y:P,Z:C,T:R}=this,{X:A,Y:l,Z:g,T:s}=u,h=i(S*A),y=i(P*l),I=i(R*p*s),N=i(C*g),m=i((S+P)*(A+l)-h-y),x=N-I,B=N+I,Z=i(y-v*h),F=i(m*x),L=i(B*Z),T=i(m*Z),U=i(x*B);return new b(F,L,U,T)}subtract(u){return this.add(u.negate())}multiply(u){if(!n.isValidNot0(u))throw Error("invalid scalar: expected 1 <= sc < curve.n");const{p:v,f:p}=V.cached(this,u,(S=>oe(b,S)));return oe(b,[v,p])[0]}multiplyUnsafe(u,v=b.ZERO){if(!n.isValid(u))throw Error("invalid scalar: expected 0 <= sc < curve.n");return u===fe?b.ZERO:this.is0()||u===M?this:V.unsafe(this,u,(p=>oe(b,p)),v)}isSmallOrder(){return this.multiplyUnsafe(a).is0()}isTorsionFree(){return V.unsafe(this,o.n).is0()}toAffine(u){return c(this,u)}clearCofactor(){return a===M?this:this.multiplyUnsafe(a)}toBytes(){const{x:u,y:v}=this.toAffine(),p=t.toBytes(v);return p[p.length-1]|=u&M?128:0,p}toHex(){return ie(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(u){return oe(b,u)}static msm(u,v){return qt(b,n,u,v)}_setWindowSize(u){this.precompute(u)}toRawBytes(){return this.toBytes()}}b.BASE=new b(o.Gx,o.Gy,M,i(o.Gx*o.Gy)),b.ZERO=new b(fe,M,M,fe),b.Fp=t,b.Fn=n;const V=new At(b,n.BITS);return b.BASE.precompute(8),b}function yf(f,e,r={}){if(typeof e!="function")throw Error('"hash" function param is required');pe(r,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:t}=r,{BASE:n,Fp:o,Fn:a}=f,d=r.randomBytes||Fe,i=r.adjustScalarBytes||(p=>p),K=r.domain||((p,S,P)=>{if(se(P,"phflag"),S.length||P)throw Error("Contexts/pre-hash are not supported");return p});function E(p){return a.create(ae(p))}function w(p){const{head:S,prefix:P,scalar:C}=(function(l){const g=q.secretKey;l=Y("private key",l,g);const s=Y("hashed private key",e(l),2*g),h=i(s.slice(0,g));return{head:h,prefix:s.slice(g,2*g),scalar:E(h)}})(p),R=n.multiply(C),A=R.toBytes();return{head:S,prefix:P,scalar:C,point:R,pointBytes:A}}function c(p){return w(p).pointBytes}function O(p=Uint8Array.of(),...S){const P=Q(...S);return E(e(K(P,Y("context",p),!!t)))}const b={zip215:!0},V=o.BYTES,q={secretKey:V,publicKey:V,signature:2*V,seed:V};function u(p=d(q.seed)){return _(p,q.seed,"seed")}const v={getExtendedPublicKey:w,randomSecretKey:u,isValidSecretKey:function(p){return Ae(p)&&p.length===a.BYTES},isValidPublicKey:function(p,S){try{return!!f.fromBytes(p,S)}catch{return!1}},toMontgomery(p){const{y:S}=f.fromBytes(p),P=q.publicKey,C=P===32;if(!C&&P!==57)throw Error("only defined for 25519 and 448");const R=C?o.div(M+S,M-S):o.div(S-M,S+M);return o.toBytes(R)},toMontgomerySecret(p){const S=q.secretKey;_(p,S);const P=e(p.subarray(0,S));return i(P).subarray(0,S)},randomPrivateKey:u,precompute:(p=8,S=f.BASE)=>S.precompute(p,!1)};return Object.freeze({keygen:function(p){const S=v.randomSecretKey(p);return{secretKey:S,publicKey:c(S)}},getPublicKey:c,sign:function(p,S,P={}){p=Y("message",p),t&&(p=t(p));const{prefix:C,scalar:R,pointBytes:A}=w(S),l=O(P.context,C,p),g=n.multiply(l).toBytes(),s=O(P.context,g,A,p),h=a.create(l+s*R);if(!a.isValid(h))throw Error("sign failed: invalid s");return _(Q(g,a.toBytes(h)),q.signature,"result")},verify:function(p,S,P,C=b){const{context:R,zip215:A}=C,l=q.signature;p=Y("signature",p,l),S=Y("message",S),P=Y("publicKey",P,q.publicKey),A!==void 0&&se(A,"zip215"),t&&(S=t(S));const g=l/2,s=p.subarray(0,g),h=ae(p.subarray(g,l));let y,I,N;try{y=f.fromBytes(P,A),I=f.fromBytes(s,A),N=n.multiplyUnsafe(h)}catch{return!1}if(!A&&y.isSmallOrder())return!1;const m=O(R,I.toBytes(),y.toBytes(),S);return I.add(y.multiplyUnsafe(m)).subtract(N).clearCofactor().is0()},utils:v,Point:f,lengths:q})}const Be=BigInt(0),le=BigInt(1),Ie=BigInt(2);function mf(f){const e=(pe(r=f,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...r}));var r;const{P:t,type:n,adjustScalarBytes:o,powPminus2:a,randomBytes:d}=e,i=n==="x25519";if(!i&&n!=="x448")throw Error("invalid type");const K=d||Fe,E=i?255:448,w=i?32:56,c=BigInt(i?9:5),O=BigInt(i?121665:39081),b=i?Ie**BigInt(254):Ie**BigInt(447),V=i?BigInt(8)*Ie**BigInt(251)-le:BigInt(4)*Ie**BigInt(445)-le,q=b+V+le,u=l=>z(l,t),v=p(c);function p(l){return $e(u(l),w)}function S(l,g){const s=(function(h,y){we("u",h,Be,t),we("scalar",y,b,q);const I=y,N=h;let m=le,x=Be,B=h,Z=le,F=Be;for(let T=BigInt(E-1);T>=Be;T--){const U=I>>T&le;F^=U,{x_2:m,x_3:B}=C(F,m,B),{x_2:x,x_3:Z}=C(F,x,Z),F=U;const j=m+x,k=u(j*j),$=m-x,G=u($*$),D=k-G,ue=B+Z,ye=u((B-Z)*j),me=u(ue*$),De=ye+me,Me=ye-me;B=u(De*De),Z=u(N*u(Me*Me)),m=u(k*G),x=u(D*(k+u(O*D)))}({x_2:m,x_3:B}=C(F,m,B)),{x_2:x,x_3:Z}=C(F,x,Z);const L=a(x);return u(m*L)})((function(h){const y=Y("u coordinate",h,w);return i&&(y[31]&=127),u(ae(y))})(g),(function(h){return ae(o(Y("scalar",h,w)))})(l));if(s===Be)throw Error("invalid private or public key received");return p(s)}function P(l){return S(l,v)}function C(l,g,s){const h=u(l*(g-s));return{x_2:g=u(g-h),x_3:s=u(s+h)}}const R={secretKey:w,publicKey:w,seed:w},A=(l=K(w))=>(Ge(l,R.seed),l);return{keygen:function(l){const g=A(l);return{secretKey:g,publicKey:P(g)}},getSharedSecret:(l,g)=>S(l,g),getPublicKey:l=>P(l),scalarMult:S,scalarMultBase:P,utils:{randomSecretKey:A,randomPrivateKey:A},GuBytes:v.slice(),lengths:R}}const de={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),n:BigInt("0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffff7cca23e9c44edb49aed63690216cc2728dc58f552378c292ab5844f3"),h:BigInt(4),a:BigInt(1),d:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffffffffffffffffffffffffffffffffffff6756"),Gx:BigInt("0x4f1970c66bed0ded221d15a622bf36da9e146570470f1767ea6de324a3d3a46412ae1af72ab66511433b80e18b00938e2626a82bc70cc05e"),Gy:BigInt("0x693f46716eb6bc248876203756c9c7624bea73736ca3984087789c1e05a0c2d73ad3ff1ce67c39c4fdbd132c4ed7c8ad9808795bf230fa14")},Bf=Object.assign({},de,{d:BigInt("0xd78b4bdc7f0daf19f24f38c29373a2ccad46157242a50f37809b1da3412a12e79ccc9c81264cfe9ad080997058fb61c4243cc32dbaa156b9"),Gx:BigInt("0x79a70b2b70400553ae7c9df416c792c61128751ac92969240c25a07d728bdc93e21f7787ed6972249de732f38496cd11698713093e9c04fc"),Gy:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff80000000000000000000000000000000000000000000000000000001")}),wf=jt((()=>Mt.create({dkLen:114}))),Ef=BigInt(1),ke=BigInt(2),it=BigInt(3);BigInt(4);const xf=BigInt(11),vf=BigInt(22),st=BigInt(44),If=BigInt(88),Of=BigInt(223);function kt(f){const e=de.p,r=f*f*f%e,t=r*r*f%e,n=H(t,it,e)*t%e,o=H(n,it,e)*t%e,a=H(o,ke,e)*r%e,d=H(a,xf,e)*a%e,i=H(d,vf,e)*d%e,K=H(i,st,e)*i%e,E=H(K,If,e)*K%e,w=H(E,st,e)*i%e,c=H(w,ke,e)*r%e,O=H(c,Ef,e)*f%e;return H(O,Of,e)*c%e}function Lt(f){return f[0]&=252,f[55]|=128,f[56]=0,f}function Sf(f,e){const r=de.p,t=z(f*f*e,r),n=z(t*f,r),o=z(n*t*e,r),a=z(n*kt(o),r),d=z(a*a,r);return{isValid:z(d*e,r)===f,value:a}}const Rf=J(de.p,{BITS:456,isLE:!0}),at=J(de.n,{BITS:456,isLE:!0});function Ff(f,e,r){if(e.length>255)throw Error("context must be smaller than 255, got: "+e.length);return Q((t="SigEd448",Uint8Array.from(t,((n,o)=>{const a=n.charCodeAt(0);if(n.length!==1||a>127)throw Error(`string contains non-ASCII character "${t[o]}" with code ${a} at position ${o}`);return a}))),new Uint8Array([r?1:0,e.length]),e,f);var t}const Af=(function(f){const{CURVE:e,curveOpts:r,hash:t,eddsaOpts:n}=(function(o){const a={a:o.a,d:o.d,p:o.Fp.ORDER,n:o.n,h:o.h,Gx:o.Gx,Gy:o.Gy},d={Fp:o.Fp,Fn:J(a.n,o.nBitLength,!0),uvRatio:o.uvRatio},i={randomBytes:o.randomBytes,adjustScalarBytes:o.adjustScalarBytes,domain:o.domain,prehash:o.prehash,mapToCurve:o.mapToCurve};return{CURVE:a,curveOpts:d,hash:o.hash,eddsaOpts:i}})(f);return(function(o,a){const d=a.Point;return Object.assign({},a,{ExtendedPoint:d,CURVE:o,nBitLength:d.Fn.BITS,nByteLength:d.Fn.BYTES})})(f,yf(Tt(e,r),t,n))})({...de,Fp:Rf,Fn:at,nBitLength:at.BITS,hash:wf,adjustScalarBytes:Lt,domain:Ff,uvRatio:Sf});Tt(Bf);const qf=(()=>{const f=de.p;return mf({P:f,type:"x448",powPminus2:e=>z(H(kt(e),ke,f)*e,f),adjustScalarBytes:Lt})})(),Le={p:BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),n:BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),h:BigInt(1),a:BigInt(0),b:BigInt(7),Gx:BigInt("0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798"),Gy:BigInt("0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8")},Zf={beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),basises:[[BigInt("0x3086d221a7d46bcde86c90e49284eb15"),-BigInt("0xe4437ed6010e88286f547fa90abfe4c3")],[BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),BigInt("0x3086d221a7d46bcde86c90e49284eb15")]]},ct=BigInt(2);const je=J(Le.p,{sqrt:function(f){const e=Le.p,r=BigInt(3),t=BigInt(6),n=BigInt(11),o=BigInt(22),a=BigInt(23),d=BigInt(44),i=BigInt(88),K=f*f*f%e,E=K*K*f%e,w=H(E,r,e)*E%e,c=H(w,r,e)*E%e,O=H(c,ct,e)*K%e,b=H(O,n,e)*O%e,V=H(b,o,e)*b%e,q=H(V,d,e)*V%e,u=H(q,i,e)*q%e,v=H(u,d,e)*V%e,p=H(v,r,e)*E%e,S=H(p,a,e)*b%e,P=H(S,t,e)*K%e,C=H(P,ct,e);if(!je.eql(je.sqr(C),f))throw Error("Cannot find square root");return C}}),Nf=ce({...Le,Fp:je,lowS:!0,endo:Zf},bt),dt=J(BigInt("0xa9fb57dba1eea9bc3e660a909d838d726e3bf623d52620282013481d1f6e5377")),Kf=ce({a:dt.create(BigInt("0x7d5a0975fc2c3057eef67530417affe7fb8055c126dc5c6ce94a4b44f330b5d9")),b:BigInt("0x26dc5c6ce94a4b44f330b5d9bbd77cbf958416295cf7e1ce6bccdc18ff8c07b6"),Fp:dt,n:BigInt("0xa9fb57dba1eea9bc3e660a909d838d718c397aa3b561a6f7901e0e82974856a7"),Gx:BigInt("0x8bd2aeb9cb7e57cb2c4b482ffc81b7afb9de27e1e3bd23c23a4453bd9ace3262"),Gy:BigInt("0x547ef835c3dac4fd97f8461a14611dc9c27745132ded8e545c1d54c72f046997"),h:BigInt(1),lowS:!1},Xt),ut=J(BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b412b1da197fb71123acd3a729901d1a71874700133107ec53")),Pf=ce({a:ut.create(BigInt("0x7bc382c63d8c150c3c72080ace05afa0c2bea28e4fb22787139165efba91f90f8aa5814a503ad4eb04a8c7dd22ce2826")),b:BigInt("0x04a8c7dd22ce28268b39b55416f0447c2fb77de107dcd2a62e880ea53eeb62d57cb4390295dbc9943ab78696fa504c11"),Fp:ut,n:BigInt("0x8cb91e82a3386d280f5d6f7e50e641df152f7109ed5456b31f166e6cac0425a7cf3ab6af6b7fc3103b883202e9046565"),Gx:BigInt("0x1d1c64f068cf45ffa2a63a81b7c13f6b8847a3e77ef14fe3db7fcafe0cbd10e8e826e03436d646aaef87b2e247d4af1e"),Gy:BigInt("0x8abe1d7520f9c2a45cb1eb8e95cfd55262b70b29feec5864e19c054ff99129280e4646217791811142820341263c5315"),h:BigInt(1),lowS:!1},Wt),lt=J(BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca703308717d4d9b009bc66842aecda12ae6a380e62881ff2f2d82c68528aa6056583a48f3")),Uf=ce({a:lt.create(BigInt("0x7830a3318b603b89e2327145ac234cc594cbdd8d3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94ca")),b:BigInt("0x3df91610a83441caea9863bc2ded5d5aa8253aa10a2ef1c98b9ac8b57f1117a72bf2c7b9e7c1ac4d77fc94cadc083e67984050b75ebae5dd2809bd638016f723"),Fp:lt,n:BigInt("0xaadd9db8dbe9c48b3fd4e6ae33c9fc07cb308db3b3c9d20ed6639cca70330870553e5c414ca92619418661197fac10471db1d381085ddaddb58796829ca90069"),Gx:BigInt("0x81aee4bdd82ed9645a21322e9c4c6a9385ed9f70b5d916c1b43b62eef4d0098eff3b1f78e2d0d48d50d1687b93b97d5f7c6d5047406a5e688b352209bcb9f822"),Gy:BigInt("0x7dde385d566332ecc0eabfa9cf7822fdf209f70024a57b1aa000c55b881f8111b2dcde494a5f485e5bca4bd88a2763aed1ca2b2fa8f0540678cd1e0f3ad80892"),h:BigInt(1),lowS:!1},Jt),Cf=new Map(Object.entries({nistP256:hf,nistP384:bf,nistP521:gf,brainpoolP256r1:Kf,brainpoolP384r1:Pf,brainpoolP512r1:Uf,secp256k1:Nf,x448:qf,ed448:Af}));export{Cf as nobleCurves};
