const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./noble_curves.min-C6rDaKvs.js","./sha512.min-3GMt3wws.js","./noble_hashes.min-CdcE1gs5.js"])))=>i.map(i=>d[i]);
(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))n(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&n(a)}).observe(document,{childList:!0,subtree:!0});function r(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function n(i){if(i.ep)return;i.ep=!0;const s=r(i);fetch(i.href,s)}})();var Sa=Object.defineProperty,Pa=(t,e,r)=>e in t?Sa(t,e,{enumerable:!0,configurable:!0,writable:!0,value:r}):t[e]=r,Ge=(t,e,r)=>(Pa(t,typeof e!="symbol"?e+"":e,r),r);function Ka(t,e){const r=Object.create(null),n=t.split(",");for(let i=0;i<n.length;i++)r[n[i]]=!0;return i=>!!r[i]}function Yi(t){if(j(t)){const e={};for(let r=0;r<t.length;r++){const n=t[r],i=pt(n)?Ia(n):Yi(n);if(i)for(const s in i)e[s]=i[s]}return e}else if(pt(t)||ze(t))return t}const Ua=/;(?![^(]*\))/g,Da=/:(.+)/;function Ia(t){const e={};return t.split(Ua).forEach(r=>{if(r){const n=r.split(Da);n.length>1&&(e[n[0].trim()]=n[1].trim())}}),e}function es(t){let e="";if(pt(t))e=t;else if(j(t))for(let r=0;r<t.length;r++){const n=es(t[r]);n&&(e+=n+" ")}else if(ze(t))for(const r in t)t[r]&&(e+=r+" ");return e.trim()}function Ca(t,e){if(t.length!==e.length)return!1;let r=!0;for(let n=0;r&&n<t.length;n++)r=ct(t[n],e[n]);return r}function ct(t,e){if(t===e)return!0;let r=Yn(t),n=Yn(e);if(r||n)return r&&n?t.getTime()===e.getTime():!1;if(r=j(t),n=j(e),r||n)return r&&n?Ca(t,e):!1;if(r=ze(t),n=ze(e),r||n){if(!r||!n)return!1;const i=Object.keys(t).length,s=Object.keys(e).length;if(i!==s)return!1;for(const a in t){const c=t.hasOwnProperty(a),u=e.hasOwnProperty(a);if(c&&!u||!c&&u||!ct(t[a],e[a]))return!1}}return String(t)===String(e)}function Nr(t,e){return t.findIndex(r=>ct(r,e))}const xa=Object.assign,Ta=(t,e)=>{const r=t.indexOf(e);r>-1&&t.splice(r,1)},Ba=Object.prototype.hasOwnProperty,Dn=(t,e)=>Ba.call(t,e),j=Array.isArray,Mr=t=>ts(t)==="[object Map]",Yn=t=>t instanceof Date,pt=t=>typeof t=="string",In=t=>typeof t=="symbol",ze=t=>t!==null&&typeof t=="object",La=Object.prototype.toString,ts=t=>La.call(t),Fa=t=>ts(t).slice(8,-1),Cn=t=>pt(t)&&t!=="NaN"&&t[0]!=="-"&&""+parseInt(t,10)===t,rs=t=>{const e=Object.create(null);return r=>e[r]||(e[r]=t(r))},Ra=/-(\w)/g,Oa=rs(t=>t.replace(Ra,(e,r)=>r?r.toUpperCase():"")),Na=/\B([A-Z])/g,ns=rs(t=>t.replace(Na,"-$1").toLowerCase()),Ma=(t,e)=>!Object.is(t,e),ei=t=>{const e=parseFloat(t);return isNaN(e)?t:e};let Ha;function is(t,e){e=e||Ha,e&&e.active&&e.effects.push(t)}const ss=t=>{const e=new Set(t);return e.w=0,e.n=0,e},as=t=>(t.w&_e)>0,os=t=>(t.n&_e)>0,$a=({deps:t})=>{if(t.length)for(let e=0;e<t.length;e++)t[e].w|=_e},za=t=>{const{deps:e}=t;if(e.length){let r=0;for(let n=0;n<e.length;n++){const i=e[n];as(i)&&!os(i)?i.delete(t):e[r++]=i,i.w&=~_e,i.n&=~_e}e.length=r}},Jr=new WeakMap;let Kt=0,_e=1;const Yr=30,kt=[];let Ze;const Qt=Symbol(""),ti=Symbol("");let _a=class{constructor(e,r=null,n){this.fn=e,this.scheduler=r,this.active=!0,this.deps=[],is(this,n)}run(){if(!this.active)return this.fn();if(!kt.includes(this))try{return kt.push(Ze=this),Wa(),_e=1<<++Kt,Kt<=Yr?$a(this):ri(this),this.fn()}finally{Kt<=Yr&&za(this),_e=1<<--Kt,cs(),kt.pop();const e=kt.length;Ze=e>0?kt[e-1]:void 0}}stop(){this.active&&(ri(this),this.onStop&&this.onStop(),this.active=!1)}};function ri(t){const{deps:e}=t;if(e.length){for(let r=0;r<e.length;r++)e[r].delete(t);e.length=0}}function ja(t,e){t.effect&&(t=t.effect.fn);const r=new _a(t);e&&(xa(r,e),e.scope&&is(r,e.scope)),(!e||!e.lazy)&&r.run();const n=r.run.bind(r);return n.effect=r,n}function Ga(t){t.effect.stop()}let ft=!0;const xn=[];function qa(){xn.push(ft),ft=!1}function Wa(){xn.push(ft),ft=!0}function cs(){const t=xn.pop();ft=t===void 0?!0:t}function kr(t,e,r){if(!Va())return;let n=Jr.get(t);n||Jr.set(t,n=new Map);let i=n.get(r);i||n.set(r,i=ss()),Qa(i)}function Va(){return ft&&Ze!==void 0}function Qa(t,e){let r=!1;Kt<=Yr?os(t)||(t.n|=_e,r=!as(t)):r=!t.has(Ze),r&&(t.add(Ze),Ze.deps.push(t))}function en(t,e,r,n,i,s){const a=Jr.get(t);if(!a)return;let c=[];if(e==="clear")c=[...a.values()];else if(r==="length"&&j(t))a.forEach((u,l)=>{(l==="length"||l>=n)&&c.push(u)});else switch(r!==void 0&&c.push(a.get(r)),e){case"add":j(t)?Cn(r)&&c.push(a.get("length")):(c.push(a.get(Qt)),Mr(t)&&c.push(a.get(ti)));break;case"delete":j(t)||(c.push(a.get(Qt)),Mr(t)&&c.push(a.get(ti)));break;case"set":Mr(t)&&c.push(a.get(Qt));break}if(c.length===1)c[0]&&ni(c[0]);else{const u=[];for(const l of c)l&&u.push(...l);ni(ss(u))}}function ni(t,e){for(const r of j(t)?t:[...t])(r!==Ze||r.allowRecurse)&&(r.scheduler?r.scheduler():r.run())}const Za=Ka("__proto__,__v_isRef,__isVue"),us=new Set(Object.getOwnPropertyNames(Symbol).map(t=>Symbol[t]).filter(In)),Xa=ls(),Ja=ls(!0),ii=Ya();function Ya(){const t={};return["includes","indexOf","lastIndexOf"].forEach(e=>{t[e]=function(...r){const n=Xe(this);for(let s=0,a=this.length;s<a;s++)kr(n,"get",s+"");const i=n[e](...r);return i===-1||i===!1?n[e](...r.map(Xe)):i}}),["push","pop","shift","unshift","splice"].forEach(e=>{t[e]=function(...r){qa();const n=Xe(this)[e].apply(this,r);return cs(),n}}),t}function ls(t=!1,e=!1){return function(r,n,i){if(n==="__v_isReactive")return!t;if(n==="__v_isReadonly")return t;if(n==="__v_raw"&&i===(t?e?co:ys:e?oo:hs).get(r))return r;const s=j(r);if(!t&&s&&Dn(ii,n))return Reflect.get(ii,n,i);const a=Reflect.get(r,n,i);return(In(n)?us.has(n):Za(n))||(t||kr(r,"get",n),e)?a:tn(a)?!s||!Cn(n)?a.value:a:ze(a)?t?ho(a):vr(a):a}}const eo=to();function to(t=!1){return function(e,r,n,i){let s=e[r];if(!t&&!yo(n)&&(n=Xe(n),s=Xe(s),!j(e)&&tn(s)&&!tn(n)))return s.value=n,!0;const a=j(e)&&Cn(r)?Number(r)<e.length:Dn(e,r),c=Reflect.set(e,r,n,i);return e===Xe(i)&&(a?Ma(n,s)&&en(e,"set",r,n):en(e,"add",r,n)),c}}function ro(t,e){const r=Dn(t,e);t[e];const n=Reflect.deleteProperty(t,e);return n&&r&&en(t,"delete",e,void 0),n}function no(t,e){const r=Reflect.has(t,e);return(!In(e)||!us.has(e))&&kr(t,"has",e),r}function io(t){return kr(t,"iterate",j(t)?"length":Qt),Reflect.ownKeys(t)}const so={get:Xa,set:eo,deleteProperty:ro,has:no,ownKeys:io},ao={get:Ja,set(t,e){return!0},deleteProperty(t,e){return!0}},hs=new WeakMap,oo=new WeakMap,ys=new WeakMap,co=new WeakMap;function uo(t){switch(t){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function lo(t){return t.__v_skip||!Object.isExtensible(t)?0:uo(Fa(t))}function vr(t){return t&&t.__v_isReadonly?t:ps(t,!1,so,null,hs)}function ho(t){return ps(t,!0,ao,null,ys)}function ps(t,e,r,n,i){if(!ze(t)||t.__v_raw&&!(e&&t.__v_isReactive))return t;const s=i.get(t);if(s)return s;const a=lo(t);if(a===0)return t;const c=new Proxy(t,a===2?n:r);return i.set(t,c),c}function yo(t){return!!(t&&t.__v_isReadonly)}function Xe(t){const e=t&&t.__v_raw;return e?Xe(e):t}function tn(t){return!!(t&&t.__v_isRef===!0)}Promise.resolve();let rn=!1;const ir=[],po=Promise.resolve(),Ar=t=>po.then(t),si=t=>{ir.includes(t)||ir.push(t),rn||(rn=!0,Ar(fo))},fo=()=>{for(const t of ir)t();ir.length=0,rn=!1},go=/^(spellcheck|draggable|form|list|type)$/,nn=({el:t,get:e,effect:r,arg:n,modifiers:i})=>{let s;n==="class"&&(t._class=t.className),r(()=>{let a=e();if(n)i?.camel&&(n=Oa(n)),Hr(t,n,a,s);else{for(const c in a)Hr(t,c,a[c],s&&s[c]);for(const c in s)(!a||!(c in a))&&Hr(t,c,null)}s=a})},Hr=(t,e,r,n)=>{if(e==="class")t.setAttribute("class",es(t._class?[t._class,r]:r)||"");else if(e==="style"){r=Yi(r);const{style:i}=t;if(!r)t.removeAttribute("style");else if(pt(r))r!==n&&(i.cssText=r);else{for(const s in r)sn(i,s,r[s]);if(n&&!pt(n))for(const s in n)r[s]==null&&sn(i,s,"")}}else!(t instanceof SVGElement)&&e in t&&!go.test(e)?(t[e]=r,e==="value"&&(t._value=r)):e==="true-value"?t._trueValue=r:e==="false-value"?t._falseValue=r:r!=null?t.setAttribute(e,r):t.removeAttribute(e)},ai=/\s*!important$/,sn=(t,e,r)=>{j(r)?r.forEach(n=>sn(t,e,n)):e.startsWith("--")?t.setProperty(e,r):ai.test(r)?t.setProperty(ns(e),r.replace(ai,""),"important"):t[e]=r},Me=(t,e)=>{const r=t.getAttribute(e);return r!=null&&t.removeAttribute(e),r},Ne=(t,e,r,n)=>{t.addEventListener(e,r,n)},mo=/^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/,wo=["ctrl","shift","alt","meta"],bo={stop:t=>t.stopPropagation(),prevent:t=>t.preventDefault(),self:t=>t.target!==t.currentTarget,ctrl:t=>!t.ctrlKey,shift:t=>!t.shiftKey,alt:t=>!t.altKey,meta:t=>!t.metaKey,left:t=>"button"in t&&t.button!==0,middle:t=>"button"in t&&t.button!==1,right:t=>"button"in t&&t.button!==2,exact:(t,e)=>wo.some(r=>t[`${r}Key`]&&!e[r])},fs=({el:t,get:e,exp:r,arg:n,modifiers:i})=>{if(!n)return;let s=mo.test(r)?e(`(e => ${r}(e))`):e(`($event => { ${r} })`);if(n==="vue:mounted"){Ar(s);return}else if(n==="vue:unmounted")return()=>s();if(i){n==="click"&&(i.right&&(n="contextmenu"),i.middle&&(n="mouseup"));const a=s;s=c=>{if(!("key"in c&&!(ns(c.key)in i))){for(const u in i){const l=bo[u];if(l&&l(c,i))return}return a(c)}}}Ne(t,n,s,i)},ko=({el:t,get:e,effect:r})=>{const n=t.style.display;r(()=>{t.style.display=e()?n:"none"})},gs=({el:t,get:e,effect:r})=>{r(()=>{t.textContent=ds(e())})},ds=t=>t==null?"":ze(t)?JSON.stringify(t,null,2):String(t),vo=({el:t,get:e,effect:r})=>{r(()=>{t.innerHTML=e()})},Ao=({el:t,exp:e,get:r,effect:n,modifiers:i})=>{const s=t.type,a=r(`(val) => { ${e} = val }`),{trim:c,number:u=s==="number"}=i||{};if(t.tagName==="SELECT"){const l=t;Ne(t,"change",()=>{const h=Array.prototype.filter.call(l.options,p=>p.selected).map(p=>u?ei(Oe(p)):Oe(p));a(l.multiple?h:h[0])}),n(()=>{const h=r(),p=l.multiple;for(let g=0,f=l.options.length;g<f;g++){const d=l.options[g],m=Oe(d);if(p)j(h)?d.selected=Nr(h,m)>-1:d.selected=h.has(m);else if(ct(Oe(d),h)){l.selectedIndex!==g&&(l.selectedIndex=g);return}}!p&&l.selectedIndex!==-1&&(l.selectedIndex=-1)})}else if(s==="checkbox"){Ne(t,"change",()=>{const h=r(),p=t.checked;if(j(h)){const g=Oe(t),f=Nr(h,g),d=f!==-1;if(p&&!d)a(h.concat(g));else if(!p&&d){const m=[...h];m.splice(f,1),a(m)}}else a(oi(t,p))});let l;n(()=>{const h=r();j(h)?t.checked=Nr(h,Oe(t))>-1:h!==l&&(t.checked=ct(h,oi(t,!0))),l=h})}else if(s==="radio"){Ne(t,"change",()=>{a(Oe(t))});let l;n(()=>{const h=r();h!==l&&(t.checked=ct(h,Oe(t)))})}else{const l=h=>c?h.trim():u?ei(h):h;Ne(t,"compositionstart",Eo),Ne(t,"compositionend",So),Ne(t,i?.lazy?"change":"input",()=>{t.composing||a(l(t.value))}),c&&Ne(t,"change",()=>{t.value=t.value.trim()}),n(()=>{if(t.composing)return;const h=t.value,p=r();document.activeElement===t&&l(h)===p||h!==p&&(t.value=p)})}},Oe=t=>"_value"in t?t._value:t.value,oi=(t,e)=>{const r=e?"_trueValue":"_falseValue";return r in t?t[r]:e},Eo=t=>{t.target.composing=!0},So=t=>{const e=t.target;e.composing&&(e.composing=!1,Po(e,"input"))},Po=(t,e)=>{const r=document.createEvent("HTMLEvents");r.initEvent(e,!0,!0),t.dispatchEvent(r)},ci=Object.create(null),Ft=(t,e,r)=>ms(t,`return(${e})`,r),ms=(t,e,r)=>{const n=ci[e]||(ci[e]=Ko(e));try{return n(t,r)}catch(i){console.error(i)}},Ko=t=>{try{return new Function("$data","$el",`with($data){${t}}`)}catch(e){return console.error(`${e.message} in expression: ${t}`),()=>{}}},Uo=({el:t,ctx:e,exp:r,effect:n})=>{Ar(()=>n(()=>ms(e.scope,r,t)))},Do={bind:nn,on:fs,show:ko,text:gs,html:vo,model:Ao,effect:Uo},Io=(t,e,r)=>{const n=t.parentElement,i=new Comment("v-if");n.insertBefore(i,t);const s=[{exp:e,el:t}];let a,c;for(;(a=t.nextElementSibling)&&(c=null,Me(a,"v-else")===""||(c=Me(a,"v-else-if")));)n.removeChild(a),s.push({exp:c,el:a});const u=t.nextSibling;n.removeChild(t);let l,h=-1;const p=()=>{l&&(n.insertBefore(i,l.el),l.remove(),l=void 0)};return r.effect(()=>{for(let g=0;g<s.length;g++){const{exp:f,el:d}=s[g];if(!f||Ft(r.scope,f)){g!==h&&(p(),l=new Tn(d,r),l.insert(n,i),n.removeChild(i),h=g);return}}h=-1,p()}),u},Co=/([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/,ui=/,([^,\}\]]*)(?:,([^,\}\]]*))?$/,xo=/^\(|\)$/g,To=/^[{[]\s*((?:[\w_$]+\s*,?\s*)+)[\]}]$/,Bo=(t,e,r)=>{const n=e.match(Co);if(!n)return;const i=t.nextSibling,s=t.parentElement,a=new Text("");s.insertBefore(a,t),s.removeChild(t);const c=n[2].trim();let u=n[1].trim().replace(xo,"").trim(),l,h=!1,p,g,f="key",d=t.getAttribute(f)||t.getAttribute(f=":key")||t.getAttribute(f="v-bind:key");d&&(t.removeAttribute(f),f==="key"&&(d=JSON.stringify(d)));let m;(m=u.match(ui))&&(u=u.replace(ui,"").trim(),p=m[1].trim(),m[2]&&(g=m[2].trim())),(m=u.match(To))&&(l=m[1].split(",").map(S=>S.trim()),h=u[0]==="[");let w=!1,b,k,v;const A=S=>{const I=new Map,x=[];if(j(S))for(let U=0;U<S.length;U++)x.push(E(I,S[U],U));else if(typeof S=="number")for(let U=0;U<S;U++)x.push(E(I,U+1,U));else if(ze(S)){let U=0;for(const C in S)x.push(E(I,S[C],U++,C))}return[x,I]},E=(S,I,x,U)=>{const C={};l?l.forEach((de,me)=>C[de]=I[h?me:de]):C[u]=I,U?(p&&(C[p]=U),g&&(C[g]=x)):p&&(C[p]=x);const M=vs(r,C),Q=d?Ft(M.scope,d):x;return S.set(Q,x),M.key=Q,M},D=(S,I)=>{const x=new Tn(t,S);return x.key=S.key,x.insert(s,I),x};return r.effect(()=>{const S=Ft(r.scope,c),I=v;if([k,v]=A(S),!w)b=k.map(x=>D(x,a)),w=!0;else{for(let Q=0;Q<b.length;Q++)v.has(b[Q].key)||b[Q].remove();const x=[];let U=k.length,C,M;for(;U--;){const Q=k[U],de=I.get(Q.key);let me;de==null?me=D(Q,C?C.el:a):(me=b[de],Object.assign(me.ctx.scope,Q.scope),de!==U&&(b[de+1]!==C||M===C)&&(M=me,me.insert(s,C?C.el:a))),x.unshift(C=me)}b=x}}),i},ws=({el:t,ctx:{scope:{$refs:e}},get:r,effect:n})=>{let i;return n(()=>{const s=r();e[s]=t,i&&s!==i&&delete e[i],i=s}),()=>{i&&delete e[i]}},Lo=/^(?:v-|:|@)/,Fo=/\.([\w-]+)/g;let an=!1;const bs=(t,e)=>{const r=t.nodeType;if(r===1){const n=t;if(n.hasAttribute("v-pre"))return;Me(n,"v-cloak");let i;if(i=Me(n,"v-if"))return Io(n,i,e);if(i=Me(n,"v-for"))return Bo(n,i,e);if((i=Me(n,"v-scope"))||i===""){const c=i?Ft(e.scope,i):{};e=vs(e,c),c.$template&&Ro(n,c.$template)}const s=Me(n,"v-once")!=null;s&&(an=!0),(i=Me(n,"ref"))&&on(n,ws,`"${i}"`,e),li(n,e);const a=[];for(const{name:c,value:u}of[...n.attributes])Lo.test(c)&&c!=="v-cloak"&&(c==="v-model"?a.unshift([c,u]):c[0]==="@"||/^v-on\b/.test(c)?a.push([c,u]):hi(n,c,u,e));for(const[c,u]of a)hi(n,c,u,e);s&&(an=!1)}else if(r===3){const n=t.data;if(n.includes(e.delimiters[0])){let i=[],s=0,a;for(;a=e.delimitersRE.exec(n);){const c=n.slice(s,a.index);c&&i.push(JSON.stringify(c)),i.push(`$s(${a[1]})`),s=a.index+a[0].length}s<n.length&&i.push(JSON.stringify(n.slice(s))),on(t,gs,i.join("+"),e)}}else r===11&&li(t,e)},li=(t,e)=>{let r=t.firstChild;for(;r;)r=bs(r,e)||r.nextSibling},hi=(t,e,r,n)=>{let i,s,a;if(e=e.replace(Fo,(c,u)=>((a||(a={}))[u]=!0,"")),e[0]===":")i=nn,s=e.slice(1);else if(e[0]==="@")i=fs,s=e.slice(1);else{const c=e.indexOf(":"),u=c>0?e.slice(2,c):e.slice(2);i=Do[u]||n.dirs[u],s=c>0?e.slice(c+1):void 0}i&&(i===nn&&s==="ref"&&(i=ws),on(t,i,r,n,s,a),t.removeAttribute(e))},on=(t,e,r,n,i,s)=>{const a=e({el:t,get:(c=r)=>Ft(n.scope,c,t),effect:n.effect,ctx:n,exp:r,arg:i,modifiers:s});a&&n.cleanups.push(a)},Ro=(t,e)=>{if(e[0]==="#"){const r=document.querySelector(e);t.appendChild(r.content.cloneNode(!0));return}t.innerHTML=e},ks=t=>{const e={delimiters:["{{","}}"],delimitersRE:/\{\{([^]+?)\}\}/g,...t,scope:t?t.scope:vr({}),dirs:t?t.dirs:{},effects:[],blocks:[],cleanups:[],effect:r=>{if(an)return si(r),r;const n=ja(r,{scheduler:()=>si(n)});return e.effects.push(n),n}};return e},vs=(t,e={})=>{const r=t.scope,n=Object.create(r);Object.defineProperties(n,Object.getOwnPropertyDescriptors(e)),n.$refs=Object.create(r.$refs);const i=vr(new Proxy(n,{set(s,a,c,u){return u===i&&!s.hasOwnProperty(a)?Reflect.set(r,a,c):Reflect.set(s,a,c,u)}}));return As(i),{...t,scope:i}},As=t=>{for(const e of Object.keys(t))typeof t[e]=="function"&&(t[e]=t[e].bind(t))};let Tn=class{constructor(e,r,n=!1){Ge(this,"template"),Ge(this,"ctx"),Ge(this,"key"),Ge(this,"parentCtx"),Ge(this,"isFragment"),Ge(this,"start"),Ge(this,"end"),this.isFragment=e instanceof HTMLTemplateElement,n?this.template=e:this.isFragment?this.template=e.content.cloneNode(!0):this.template=e.cloneNode(!0),n?this.ctx=r:(this.parentCtx=r,r.blocks.push(this),this.ctx=ks(r)),bs(this.template,this.ctx)}get el(){return this.start||this.template}insert(e,r=null){if(this.isFragment)if(this.start){let n=this.start,i;for(;n&&(i=n.nextSibling,e.insertBefore(n,r),n!==this.end);)n=i}else this.start=new Text(""),this.end=new Text(""),e.insertBefore(this.end,r),e.insertBefore(this.start,this.end),e.insertBefore(this.template,this.end);else e.insertBefore(this.template,r)}remove(){if(this.parentCtx&&Ta(this.parentCtx.blocks,this),this.start){const e=this.start.parentNode;let r=this.start,n;for(;r&&(n=r.nextSibling,e.removeChild(r),r!==this.end);)r=n}else this.template.parentNode.removeChild(this.template);this.teardown()}teardown(){this.ctx.blocks.forEach(e=>{e.teardown()}),this.ctx.effects.forEach(Ga),this.ctx.cleanups.forEach(e=>e())}};const yi=t=>t.replace(/[-.*+?^${}()|[\]\/\\]/g,"\\$&"),Es=t=>{const e=ks();if(t&&(e.scope=vr(t),As(e.scope),t.$delimiters)){const[n,i]=e.delimiters=t.$delimiters;e.delimitersRE=new RegExp(yi(n)+"([^]+?)"+yi(i),"g")}e.scope.$s=ds,e.scope.$nextTick=Ar,e.scope.$refs=Object.create(null);let r;return{directive(n,i){return i?(e.dirs[n]=i,this):e.dirs[n]},mount(n){if(typeof n=="string"&&(n=document.querySelector(n),!n))return;n=n||document.documentElement;let i;return n.hasAttribute("v-scope")?i=[n]:i=[...n.querySelectorAll("[v-scope]")].filter(s=>!s.matches("[v-scope] [v-scope]")),i.length||(i=[n]),r=i.map(s=>new Tn(s,e,!0)),this},unmount(){r.forEach(n=>n.teardown())}}},pi=document.currentScript;pi&&pi.hasAttribute("init")&&Es().mount();const Oo="modulepreload",No=function(t,e){return new URL(t,e).href},fi={},ge=function(e,r,n){let i=Promise.resolve();if(r&&r.length>0){let l=function(h){return Promise.all(h.map(p=>Promise.resolve(p).then(g=>({status:"fulfilled",value:g}),g=>({status:"rejected",reason:g}))))};const a=document.getElementsByTagName("link"),c=document.querySelector("meta[property=csp-nonce]"),u=c?.nonce||c?.getAttribute("nonce");i=l(r.map(h=>{if(h=No(h,n),h in fi)return;fi[h]=!0;const p=h.endsWith(".css"),g=p?'[rel="stylesheet"]':"";if(n)for(let d=a.length-1;d>=0;d--){const m=a[d];if(m.href===h&&(!p||m.rel==="stylesheet"))return}else if(document.querySelector(`link[href="${h}"]${g}`))return;const f=document.createElement("link");if(f.rel=p?"stylesheet":Oo,p||(f.as="script"),f.crossOrigin="",f.href=h,u&&f.setAttribute("nonce",u),document.head.appendChild(f),p)return new Promise((d,m)=>{f.addEventListener("load",d),f.addEventListener("error",()=>m(new Error(`Unable to preload CSS for ${h}`)))})}))}function s(a){const c=new Event("vite:preloadError",{cancelable:!0});if(c.payload=a,window.dispatchEvent(c),!c.defaultPrevented)throw a}return i.then(a=>{for(const c of a||[])c.status==="rejected"&&s(c.reason);return e().catch(s)})},Ce=typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{},st=Symbol("doneWritingPromise"),Ss=Symbol("doneWritingResolve"),Ps=Symbol("doneWritingReject"),vt=Symbol("readingIndex");class oe extends Array{constructor(){super(),Object.setPrototypeOf(this,oe.prototype),this[st]=new Promise(((e,r)=>{this[Ss]=e,this[Ps]=r})),this[st].catch((()=>{}))}}function W(t){return t&&t.getReader&&Array.isArray(t)}function Ut(t){if(!W(t)){const e=t.getWriter(),r=e.releaseLock;return e.releaseLock=()=>{e.closed.catch((function(){})),r.call(e)},e}this.stream=t}function G(t){if(W(t))return"array";if(Ce.ReadableStream&&Ce.ReadableStream.prototype.isPrototypeOf(t))return"web";if(t&&!(Ce.ReadableStream&&t instanceof Ce.ReadableStream)&&typeof t._read=="function"&&typeof t._readableState=="object")throw Error("Native Node streams are no longer supported: please manually convert the stream to a WebStream, using e.g. `stream.Readable.toWeb`");return!(!t||!t.getReader)&&"web-like"}function Er(t){return Uint8Array.prototype.isPrototypeOf(t)}function Ks(t){if(t.length===1)return t[0];let e=0;for(let i=0;i<t.length;i++){if(!Er(t[i]))throw Error("concatUint8Array: Data must be in the form of a Uint8Array");e+=t[i].length}const r=new Uint8Array(e);let n=0;return t.forEach((function(i){r.set(i,n),n+=i.length})),r}oe.prototype.getReader=function(){return this[vt]===void 0&&(this[vt]=0),{read:async()=>(await this[st],this[vt]===this.length?{value:void 0,done:!0}:{value:this[this[vt]++],done:!1})}},oe.prototype.readToEnd=async function(t){await this[st];const e=t(this.slice(this[vt]));return this.length=0,e},oe.prototype.clone=function(){const t=new oe;return t[st]=this[st].then((()=>{t.push(...this)})),t},Ut.prototype.write=async function(t){this.stream.push(t)},Ut.prototype.close=async function(){this.stream[Ss]()},Ut.prototype.abort=async function(t){return this.stream[Ps](t),t},Ut.prototype.releaseLock=function(){},typeof Ce.process=="object"&&Ce.process.versions;const gi=new WeakSet,L=Symbol("externalBuffer");function we(t){if(this.stream=t,t[L]&&(this[L]=t[L].slice()),W(t)){const r=t.getReader();return this._read=r.read.bind(r),this._releaseLock=()=>{},void(this._cancel=()=>{})}if(G(t)){const r=t.getReader();return this._read=r.read.bind(r),this._releaseLock=()=>{r.closed.catch((function(){})),r.releaseLock()},void(this._cancel=r.cancel.bind(r))}let e=!1;this._read=async()=>e||gi.has(t)?{value:void 0,done:!0}:(e=!0,{value:t,done:!1}),this._releaseLock=()=>{if(e)try{gi.add(t)}catch{}}}function Bn(t){return G(t)?t:new ReadableStream({start(e){e.enqueue(t),e.close()}})}function Us(t){const e=G(t);if(e){if(e!=="array")throw Error("Can't convert Stream to ArrayStream here, call `readToEnd` first");return t}const r=new oe;return(async()=>{const n=Ke(r);await n.write(t),await n.close()})(),r}function ne(t){return t.some((e=>G(e)&&!W(e)))?(function(e){e=e.map(Bn);const r=Ds((async function(s){await Promise.all(i.map((a=>Ho(a,s))))}));let n=Promise.resolve();const i=e.map(((s,a)=>Sr(s,((c,u)=>(n=n.then((()=>cn(c,r.writable,{preventClose:a!==e.length-1}))),n)))));return r.readable})(t):t.some((e=>W(e)))?(function(e){const r=new oe;let n=Promise.resolve();return e.forEach(((i,s)=>(n=n.then((()=>cn(i,r,{preventClose:s!==e.length-1}))),n))),r})(t):typeof t[0]=="string"?t.join(""):Ks(t)}async function cn(t,e,{preventClose:r=!1,preventAbort:n=!1,preventCancel:i=!1}={}){if(G(t)&&!W(t)&&!W(e)){t=Bn(t);try{if(t[L]){const c=Ke(e);for(let u=0;u<t[L].length;u++)await c.ready,await c.write(t[L][u]);c.releaseLock()}await t.pipeTo(e,{preventClose:r,preventAbort:n,preventCancel:i})}catch{}return}G(t)||(t=Us(t));const s=dt(t),a=Ke(e);try{for(;;){await a.ready;const{done:c,value:u}=await s.read();if(c){r||await a.close();break}await a.write(u)}}catch(c){n||await a.abort(c)}finally{s.releaseLock(),a.releaseLock()}}function Ds(t){let e,r,n,i=!1,s=!1;return{readable:new ReadableStream({start(a){n=a},pull(){e?e():i=!0},async cancel(a){s=!0,t&&await t(a),r&&r(a)}},{highWaterMark:0}),writable:new WritableStream({write:async function(a){if(s)throw Error("Stream is cancelled");n.enqueue(a),i?i=!1:(await new Promise(((c,u)=>{e=c,r=u})),e=null,r=null)},close:n.close.bind(n),abort:n.error.bind(n)})}}function $(t,e=()=>{},r=()=>{},n={highWaterMark:0}){if(G(t))return Is(t,e,r,n);const i=e(t),s=r();return i!==void 0&&s!==void 0?ne([i,s]):i!==void 0?i:s}async function un(t,e=async()=>{},r=async()=>{},n={highWaterMark:1}){if(G(t))return Is(t,e,r,n);const i=await e(t),s=await r();return i!==void 0&&s!==void 0?ne([i,s]):i!==void 0?i:s}function Is(t,e,r,n){if(W(t)){const i=new oe;return(async()=>{const s=Ke(i);try{const a=await gt(t),c=await e(a),u=await r();let l;l=c!==void 0&&u!==void 0?ne([c,u]):c!==void 0?c:u,await s.write(l),await s.close()}catch(a){await s.abort(a)}})(),i}if(G(t)){let i,s=!1;return new ReadableStream({start(){i=t.getReader()},async pull(a){if(s)return a.close(),void t.releaseLock();try{for(;;){const{value:c,done:u}=await i.read();s=u;const l=await(u?r:e)(c);if(l!==void 0)return void a.enqueue(l);if(u)return a.close(),void t.releaseLock()}}catch(c){a.error(c)}},async cancel(a){await i.cancel(a)}},n)}throw Error("Unreachable")}function Sr(t,e){if(G(t)&&!W(t)){let n;const i=new TransformStream({start(c){n=c}}),s=cn(t,i.writable),a=Ds((async function(c){n.error(c),await s,await new Promise((u=>setTimeout(u)))}));return e(i.readable,a.writable),a.readable}t=Us(t);const r=new oe;return e(t,r),r}function sr(t){if(W(t))return t.clone();if(G(t)){const e=(function(r){if(W(r))throw Error("ArrayStream cannot be tee()d, use clone() instead");if(G(r)){const n=Bn(r).tee();return n[0][L]=n[1][L]=r[L],n}return[ie(r),ie(r)]})(t);return Cs(t,e[0]),e[1]}return ie(t)}function Mo(t){return W(t)?sr(t):G(t)?new ReadableStream({start(e){const r=Sr(t,(async(n,i)=>{const s=dt(n),a=Ke(i);try{for(;;){await a.ready;const{done:c,value:u}=await s.read();if(c){try{e.close()}catch{}return void await a.close()}try{e.enqueue(u)}catch{}await a.write(u)}}catch(c){e.error(c),await a.abort(c)}}));Cs(t,r)}}):ie(t)}function Cs(t,e){Object.entries(Object.getOwnPropertyDescriptors(t.constructor.prototype)).forEach((([r,n])=>{r!=="constructor"&&(n.value?n.value=n.value.bind(e):n.get=n.get.bind(e),Object.defineProperty(t,r,n))}))}function ie(t,e=0,r=1/0){if(W(t))throw Error("Not implemented");if(G(t)){if(e>=0&&r>=0){let n,i=0;return new ReadableStream({start(){n=t.getReader()},async pull(s){try{for(;;){if(!(i<r))return s.close(),void t.releaseLock();{const{value:a,done:c}=await n.read();if(c)return s.close(),void t.releaseLock();let u;if(i+a.length>=e&&(u=ie(a,Math.max(e-i,0),r-i)),i+=a.length,u)return void s.enqueue(u)}}}catch(a){s.error(a)}},async cancel(s){await n.cancel(s)}},{highWaterMark:0})}if(e<0&&(r<0||r===1/0)){let n=[];return $(t,(i=>{i.length>=-e?n=[i]:n.push(i)}),(()=>ie(ne(n),e,r)))}if(e===0&&r<0){let n;return $(t,(i=>{const s=n?ne([n,i]):i;if(s.length>=-r)return n=ie(s,r),ie(s,e,r);n=s}))}return console.warn(`stream.slice(input, ${e}, ${r}) not implemented efficiently.`),Ln((async()=>ie(await gt(t),e,r)))}return t[L]&&(t=ne(t[L].concat([t]))),Er(t)?t.subarray(e,r===1/0?t.length:r):t.slice(e,r)}async function gt(t,e=ne){return W(t)?t.readToEnd(e):G(t)?dt(t).readToEnd(e):t}async function Ho(t,e){if(G(t)){if(t.cancel){const r=await t.cancel(e);return await new Promise((n=>setTimeout(n))),r}if(t.destroy)return t.destroy(e),await new Promise((r=>setTimeout(r))),e}}function Ln(t){const e=new oe;return(async()=>{const r=Ke(e);try{await r.write(await t()),await r.close()}catch(n){await r.abort(n)}})(),e}function dt(t){return new we(t)}function Ke(t){return new Ut(t)}we.prototype.read=async function(){return this[L]&&this[L].length?{done:!1,value:this[L].shift()}:this._read()},we.prototype.releaseLock=function(){this[L]&&(this.stream[L]=this[L]),this._releaseLock()},we.prototype.cancel=function(t){return this._cancel(t)},we.prototype.readLine=async function(){let t,e=[];for(;!t;){let{done:r,value:n}=await this.read();if(n+="",r)return e.length?ne(e):void 0;const i=n.indexOf(`
`)+1;i&&(t=ne(e.concat(n.substr(0,i))),e=[]),i!==n.length&&e.push(n.substr(i))}return this.unshift(...e),t},we.prototype.readByte=async function(){const{done:t,value:e}=await this.read();if(t)return;const r=e[0];return this.unshift(ie(e,1)),r},we.prototype.readBytes=async function(t){const e=[];let r=0;for(;;){const{done:n,value:i}=await this.read();if(n)return e.length?ne(e):void 0;if(e.push(i),r+=i.length,r>=t){const s=ne(e);return this.unshift(ie(s,t)),ie(s,0,t)}}},we.prototype.peekBytes=async function(t){const e=await this.readBytes(t);return this.unshift(e),e},we.prototype.unshift=function(...t){this[L]||(this[L]=[]),t.length===1&&Er(t[0])&&this[L].length&&t[0].length&&this[L][0].byteOffset>=t[0].length?this[L][0]=new Uint8Array(this[L][0].buffer,this[L][0].byteOffset-t[0].length,this[L][0].byteLength+t[0].length):this[L].unshift(...t.filter((e=>e&&e.length)))},we.prototype.readToEnd=async function(t=ne){const e=[];for(;;){const{done:r,value:n}=await this.read();if(r)break;e.push(n)}return t(e)};const At=Symbol("byValue");var o={curve:{nistP256:"nistP256",p256:"nistP256",nistP384:"nistP384",p384:"nistP384",nistP521:"nistP521",p521:"nistP521",secp256k1:"secp256k1",ed25519Legacy:"ed25519Legacy",ed25519:"ed25519Legacy",curve25519Legacy:"curve25519Legacy",curve25519:"curve25519Legacy",brainpoolP256r1:"brainpoolP256r1",brainpoolP384r1:"brainpoolP384r1",brainpoolP512r1:"brainpoolP512r1"},s2k:{simple:0,salted:1,iterated:3,argon2:4,gnu:101},publicKey:{rsaEncryptSign:1,rsaEncrypt:2,rsaSign:3,elgamal:16,dsa:17,ecdh:18,ecdsa:19,eddsaLegacy:22,aedh:23,aedsa:24,x25519:25,x448:26,ed25519:27,ed448:28},symmetric:{idea:1,tripledes:2,cast5:3,blowfish:4,aes128:7,aes192:8,aes256:9,twofish:10},compression:{uncompressed:0,zip:1,zlib:2,bzip2:3},hash:{md5:1,sha1:2,ripemd:3,sha256:8,sha384:9,sha512:10,sha224:11,sha3_256:12,sha3_512:14},webHash:{"SHA-1":2,"SHA-256":8,"SHA-384":9,"SHA-512":10},aead:{eax:1,ocb:2,gcm:3,experimentalGCM:100},packet:{publicKeyEncryptedSessionKey:1,signature:2,symEncryptedSessionKey:3,onePassSignature:4,secretKey:5,publicKey:6,secretSubkey:7,compressedData:8,symmetricallyEncryptedData:9,marker:10,literalData:11,trust:12,userID:13,publicSubkey:14,userAttribute:17,symEncryptedIntegrityProtectedData:18,modificationDetectionCode:19,aeadEncryptedData:20,padding:21},literal:{binary:98,text:116,utf8:117,mime:109},signature:{binary:0,text:1,standalone:2,certGeneric:16,certPersona:17,certCasual:18,certPositive:19,certRevocation:48,subkeyBinding:24,keyBinding:25,key:31,keyRevocation:32,subkeyRevocation:40,timestamp:64,thirdParty:80},signatureSubpacket:{signatureCreationTime:2,signatureExpirationTime:3,exportableCertification:4,trustSignature:5,regularExpression:6,revocable:7,keyExpirationTime:9,placeholderBackwardsCompatibility:10,preferredSymmetricAlgorithms:11,revocationKey:12,issuerKeyID:16,notationData:20,preferredHashAlgorithms:21,preferredCompressionAlgorithms:22,keyServerPreferences:23,preferredKeyServer:24,primaryUserID:25,policyURI:26,keyFlags:27,signersUserID:28,reasonForRevocation:29,features:30,signatureTarget:31,embeddedSignature:32,issuerFingerprint:33,preferredAEADAlgorithms:34,preferredCipherSuites:39},keyFlags:{certifyKeys:1,signData:2,encryptCommunication:4,encryptStorage:8,splitPrivateKey:16,authentication:32,sharedPrivateKey:128},armor:{multipartSection:0,multipartLast:1,signed:2,message:3,publicKey:4,privateKey:5,signature:6},reasonForRevocation:{noReason:0,keySuperseded:1,keyCompromised:2,keyRetired:3,userIDInvalid:32},features:{modificationDetection:1,aead:2,v5Keys:4,seipdv2:8},write:function(t,e){if(typeof e=="number"&&(e=this.read(t,e)),t[e]!==void 0)return t[e];throw Error("Invalid enum value.")},read:function(t,e){if(t[At]||(t[At]=[],Object.entries(t).forEach((([r,n])=>{t[At][n]=r}))),t[At][e]!==void 0)return t[At][e];throw Error("Invalid enum value.")}},P={preferredHashAlgorithm:o.hash.sha512,preferredSymmetricAlgorithm:o.symmetric.aes256,preferredCompressionAlgorithm:o.compression.uncompressed,aeadProtect:!1,parseAEADEncryptedV4KeysAsLegacy:!1,preferredAEADAlgorithm:o.aead.gcm,aeadChunkSizeByte:12,v6Keys:!1,enableParsingV5Entities:!1,s2kType:o.s2k.iterated,s2kIterationCountByte:224,s2kArgon2Params:{passes:3,parallelism:4,memoryExponent:16},allowUnauthenticatedMessages:!1,allowUnauthenticatedStream:!1,minRSABits:2047,passwordCollisionCheck:!1,allowInsecureDecryptionWithSigningKeys:!1,allowInsecureVerificationWithReformattedKeys:!1,allowMissingKeyFlags:!1,constantTimePKCS1Decryption:!1,constantTimePKCS1DecryptionSupportedSymmetricAlgorithms:new Set([o.symmetric.aes128,o.symmetric.aes192,o.symmetric.aes256]),ignoreUnsupportedPackets:!0,ignoreMalformedPackets:!1,enforceGrammar:!0,additionalAllowedPackets:[],showVersion:!1,showComment:!1,versionString:"OpenPGP.js 6.3.0",commentString:"https://openpgpjs.org",maxUserIDLength:5120,maxDecompressedMessageSize:1/0,knownNotations:[],nonDeterministicSignaturesViaNotation:!0,useEllipticFallback:!0,rejectHashAlgorithms:new Set([o.hash.md5,o.hash.ripemd]),rejectMessageHashAlgorithms:new Set([o.hash.md5,o.hash.ripemd,o.hash.sha1]),rejectPublicKeyAlgorithms:new Set([o.publicKey.elgamal,o.publicKey.dsa]),rejectCurves:new Set([o.curve.secp256k1])};const di=(()=>{try{return!1}catch{}return!1})(),y={isString:function(t){return typeof t=="string"||t instanceof String},nodeRequire:()=>{},isArray:function(t){return t instanceof Array},isUint8Array:Er,isStream:G,getNobleCurve:async(t,e)=>{if(!P.useEllipticFallback)throw Error("This curve is only supported in the full build of OpenPGP.js");const{nobleCurves:r}=await ge(async()=>{const{nobleCurves:n}=await import("./noble_curves.min-C6rDaKvs.js");return{nobleCurves:n}},__vite__mapDeps([0,1]),import.meta.url);switch(t){case o.publicKey.ecdh:case o.publicKey.ecdsa:{const n=r.get(e);if(!n)throw Error("Unsupported curve");return n}case o.publicKey.x448:return r.get("x448");case o.publicKey.ed448:return r.get("ed448");default:throw Error("Unsupported curve")}},readNumber:function(t){let e=0;for(let r=0;r<t.length;r++)e+=256**r*t[t.length-1-r];return e},writeNumber:function(t,e){const r=new Uint8Array(e);for(let n=0;n<e;n++)r[n]=t>>8*(e-n-1)&255;return r},readDate:function(t){const e=y.readNumber(t);return new Date(1e3*e)},writeDate:function(t){const e=Math.floor(t.getTime()/1e3);return y.writeNumber(e,4)},normalizeDate:function(t=Date.now()){return t===null||t===1/0?t:new Date(1e3*Math.floor(+t/1e3))},readMPI:function(t){const e=(t[0]<<8|t[1])+7>>>3;return y.readExactSubarray(t,2,2+e)},readExactSubarray:function(t,e,r){if(t.length<r-e)throw Error("Input array too short");return t.subarray(e,r)},leftPad(t,e){if(t.length>e)throw Error("Input array too long");const r=new Uint8Array(e),n=e-t.length;return r.set(t,n),r},uint8ArrayToMPI:function(t){const e=y.uint8ArrayBitLength(t);if(e===0)throw Error("Zero MPI");const r=t.subarray(t.length-Math.ceil(e/8)),n=new Uint8Array([(65280&e)>>8,255&e]);return y.concatUint8Array([n,r])},uint8ArrayBitLength:function(t){let e;for(e=0;e<t.length&&t[e]===0;e++);if(e===t.length)return 0;const r=t.subarray(e);return 8*(r.length-1)+y.nbits(r[0])},hexToUint8Array:function(t){const e=new Uint8Array(t.length>>1);for(let r=0;r<t.length>>1;r++)e[r]=parseInt(t.substr(r<<1,2),16);return e},uint8ArrayToHex:function(t){const e="0123456789abcdef";let r="";return t.forEach((n=>{r+=e[n>>4]+e[15&n]})),r},stringToUint8Array:function(t){return $(t,(e=>{if(!y.isString(e))throw Error("stringToUint8Array: Data must be in the form of a string");const r=new Uint8Array(e.length);for(let n=0;n<e.length;n++)r[n]=e.charCodeAt(n);return r}))},uint8ArrayToString:function(t){const e=[],n=(t=new Uint8Array(t)).length;for(let i=0;i<n;i+=16384)e.push(String.fromCharCode.apply(String,t.subarray(i,i+16384<n?i+16384:n)));return e.join("")},encodeUTF8:function(t){const e=new TextEncoder("utf-8");function r(n,i=!1){return e.encode(n,{stream:!i})}return $(t,r,(()=>r("",!0)))},decodeUTF8:function(t){const e=new TextDecoder("utf-8");function r(n,i=!1){return e.decode(n,{stream:!i})}return $(t,r,(()=>r(new Uint8Array,!0)))},concat:ne,concatUint8Array:Ks,equalsUint8Array:function(t,e){if(!y.isUint8Array(t)||!y.isUint8Array(e))throw Error("Data must be in the form of a Uint8Array");if(t.length!==e.length)return!1;for(let r=0;r<t.length;r++)if(t[r]!==e[r])return!1;return!0},findLastIndex:function(t,e){for(let r=t.length;r>=0;r--)if(e(t[r],r,t))return r;return-1},writeChecksum:function(t){let e=0;for(let r=0;r<t.length;r++)e=e+t[r]&65535;return y.writeNumber(e,2)},printDebug:function(t){di&&console.log("[OpenPGP.js debug]",t)},printDebugError:function(t){di&&console.error("[OpenPGP.js debug]",t)},nbits:function(t){let e=1,r=t>>>16;return r!==0&&(t=r,e+=16),r=t>>8,r!==0&&(t=r,e+=8),r=t>>4,r!==0&&(t=r,e+=4),r=t>>2,r!==0&&(t=r,e+=2),r=t>>1,r!==0&&(t=r,e+=1),e},double:function(t){const e=new Uint8Array(t.length),r=t.length-1;for(let n=0;n<r;n++)e[n]=t[n]<<1^t[n+1]>>7;return e[r]=t[r]<<1^135*(t[0]>>7),e},shiftRight:function(t,e){if(e)for(let r=t.length-1;r>=0;r--)t[r]>>=e,r>0&&(t[r]|=t[r-1]<<8-e);return t},getWebCrypto:function(){const t=Ce!==void 0&&Ce.crypto&&Ce.crypto.subtle||this.getNodeCrypto()?.webcrypto.subtle;if(!t)throw Error("The WebCrypto API is not available");return t},getNodeCrypto:function(){return this.nodeRequire("crypto")},getNodeZlib:function(){return this.nodeRequire("zlib")},getNodeBuffer:function(){return(this.nodeRequire("buffer")||{}).Buffer},getHardwareConcurrency:function(){return typeof navigator<"u"?navigator.hardwareConcurrency||1:this.nodeRequire("os").cpus().length},isEmailAddress:function(t){return y.isString(t)?/^[^\p{C}\p{Z}@<>\\]+@[^\p{C}\p{Z}@<>\\]+[^\p{C}\p{Z}\p{P}]$/u.test(t):!1},canonicalizeEOL:function(t){let e=!1;return $(t,(r=>{let n;e&&(r=y.concatUint8Array([new Uint8Array([13]),r])),r[r.length-1]===13?(e=!0,r=r.subarray(0,-1)):e=!1;const i=[];for(let c=0;n=r.indexOf(10,c)+1,n;c=n)r[n-2]!==13&&i.push(n);if(!i.length)return r;const s=new Uint8Array(r.length+i.length);let a=0;for(let c=0;c<i.length;c++){const u=r.subarray(i[c-1]||0,i[c]);s.set(u,a),a+=u.length,s[a-1]=13,s[a]=10,a++}return s.set(r.subarray(i[i.length-1]||0),a),s}),(()=>e?new Uint8Array([13]):void 0))},nativeEOL:function(t){let e=!1;return $(t,(r=>{let n;(r=e&&r[0]!==10?y.concatUint8Array([new Uint8Array([13]),r]):new Uint8Array(r))[r.length-1]===13?(e=!0,r=r.subarray(0,-1)):e=!1;let i=0;for(let s=0;s!==r.length;s=n){n=r.indexOf(13,s)+1,n||(n=r.length);const a=n-(r[n]===10?1:0);s&&r.copyWithin(i,s,a),i+=a-s}return r.subarray(0,i)}),(()=>e?new Uint8Array([13]):void 0))},removeTrailingSpaces:function(t){return t.split(`
`).map((e=>{let r=e.length-1;for(;r>=0&&(e[r]===" "||e[r]==="	"||e[r]==="\r");r--);return e.substr(0,r+1)})).join(`
`)},wrapError:function(t,e){if(!e)return t instanceof Error?t:Error(t);if(t instanceof Error){try{t.message+=": "+e.message,t.cause=e}catch{}return t}return Error(t+": "+e.message,{cause:e})},constructAllowedPackets:function(t){const e={};return t.forEach((r=>{if(!r.tag)throw Error("Invalid input: expected a packet class");e[r.tag]=r})),e},anyPromise:function(t){return new Promise(((e,r)=>{let n;Promise.all(t.map((async i=>{try{e(await i)}catch(s){n=s}}))).then((()=>{r(n)}))}))},selectUint8Array:function(t,e,r){const n=Math.max(e.length,r.length),i=new Uint8Array(n);let s=0;for(let a=0;a<i.length;a++)i[a]=e[a]&256-t|r[a]&255+t,s+=t&a<e.length|1-t&a<r.length;return i.subarray(0,s)},selectUint8:function(t,e,r){return e&256-t|r&255+t},isAES:function(t){return t===o.symmetric.aes128||t===o.symmetric.aes192||t===o.symmetric.aes256}},$r=y.getNodeBuffer();let ar,or;function De(t){let e=new Uint8Array;return $(t,(r=>{e=y.concatUint8Array([e,r]);const n=[],i=Math.floor(e.length/45),s=45*i,a=ar(e.subarray(0,s));for(let c=0;c<i;c++)n.push(a.substr(60*c,60)),n.push(`
`);return e=e.subarray(s),n.join("")}),(()=>e.length?ar(e)+`
`:""))}function xs(t){let e="";return $(t,(r=>{e+=r;let n=0;const i=[" ","	","\r",`
`];for(let c=0;c<i.length;c++){const u=i[c];for(let l=e.indexOf(u);l!==-1;l=e.indexOf(u,l+1))n++}let s=e.length;for(;s>0&&(s-n)%4!=0;s--)i.includes(e[s])&&n--;const a=or(e.substr(0,s));return e=e.substr(s),a}),(()=>or(e)))}function J(t){return xs(t.replace(/-/g,"+").replace(/_/g,"/"))}function _(t,e){let r=De(t).replace(/[\r\n]/g,"");return r=r.replace(/[+]/g,"-").replace(/[/]/g,"_").replace(/[=]/g,""),r}function $o(t){const e=t.match(/^-----BEGIN PGP (MESSAGE, PART \d+\/\d+|MESSAGE, PART \d+|SIGNED MESSAGE|MESSAGE|PUBLIC KEY BLOCK|PRIVATE KEY BLOCK|SIGNATURE)-----$/m);if(!e)throw Error("Unknown ASCII armor type");return/MESSAGE, PART \d+\/\d+/.test(e[1])?o.armor.multipartSection:/MESSAGE, PART \d+/.test(e[1])?o.armor.multipartLast:/SIGNED MESSAGE/.test(e[1])?o.armor.signed:/MESSAGE/.test(e[1])?o.armor.message:/PUBLIC KEY BLOCK/.test(e[1])?o.armor.publicKey:/PRIVATE KEY BLOCK/.test(e[1])?o.armor.privateKey:/SIGNATURE/.test(e[1])?o.armor.signature:void 0}function qe(t,e){let r="";return e.showVersion&&(r+="Version: "+e.versionString+`
`),e.showComment&&(r+="Comment: "+e.commentString+`
`),t&&(r+="Comment: "+t+`
`),r+=`
`,r}function We(t){const e=(function(r){let n=13501623;return $(r,(i=>{const s=zo?Math.floor(i.length/4):0,a=new Uint32Array(i.buffer,i.byteOffset,s);for(let c=0;c<s;c++)n^=a[c],n=z[0][n>>24&255]^z[1][n>>16&255]^z[2][n>>8&255]^z[3][255&n];for(let c=4*s;c<i.length;c++)n=n>>8^z[0][255&n^i[c]]}),(()=>new Uint8Array([n,n>>8,n>>16])))})(t);return De(e)}$r?(ar=t=>$r.from(t).toString("base64"),or=t=>{const e=$r.from(t,"base64");return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}):(ar=t=>btoa(y.uint8ArrayToString(t)),or=t=>y.stringToUint8Array(atob(t)));const z=[Array(255),Array(255),Array(255),Array(255)];for(let t=0;t<=255;t++){let e=t<<16;for(let r=0;r<8;r++)e=e<<1^(8388608&e?8801531:0);z[0][t]=(16711680&e)>>16|65280&e|(255&e)<<16}for(let t=0;t<=255;t++)z[1][t]=z[0][t]>>8^z[0][255&z[0][t]];for(let t=0;t<=255;t++)z[2][t]=z[1][t]>>8^z[0][255&z[1][t]];for(let t=0;t<=255;t++)z[3][t]=z[2][t]>>8^z[0][255&z[2][t]];const zo=(function(){const t=new ArrayBuffer(2);return new DataView(t).setInt16(0,255,!0),new Int16Array(t)[0]===255})();function mi(t){for(let e=0;e<t.length;e++)/^([^\s:]|[^\s:][^:]*[^\s:]): .+$/.test(t[e])||y.printDebugError(Error("Improperly formatted armor header: "+t[e])),/^(Version|Comment|MessageID|Hash|Charset): .+$/.test(t[e])||y.printDebugError(Error("Unknown header: "+t[e]))}function _o(t){let e=t;const r=t.lastIndexOf("=");return r>=0&&r!==t.length-1&&(e=t.slice(0,r)),e}function Ts(t){return new Promise(((e,r)=>{try{const n=/^-----[^-]+-----$/m,i=/^[ \f\r\t\u00a0\u2000-\u200a\u202f\u205f\u3000]*$/;let s;const a=[];let c,u,l=a,h=[];const p=xs(Sr(t,(async(g,f)=>{const d=dt(g);try{for(;;){let w=await d.readLine();if(w===void 0)throw Error("Misformed armored text");if(w=y.removeTrailingSpaces(w.replace(/[\r\n]/g,"")),s)if(c)u||s!==o.armor.signed||(n.test(w)?(h=h.join(`\r
`),u=!0,mi(l),l=[],c=!1):h.push(w.replace(/^- /,"")));else if(n.test(w)&&r(Error("Mandatory blank line missing between armor headers and armor data")),i.test(w)){if(mi(l),c=!0,u||s!==o.armor.signed){e({text:h,data:p,headers:a,type:s});break}}else l.push(w);else n.test(w)&&(s=$o(w))}}catch(w){return void r(w)}const m=Ke(f);try{for(;;){await m.ready;const{done:w,value:b}=await d.read();if(w)throw Error("Misformed armored text");const k=b+"";if(k.indexOf("=")!==-1||k.indexOf("-")!==-1){let v=await d.readToEnd();v.length||(v=""),v=k+v,v=y.removeTrailingSpaces(v.replace(/\r/g,""));const A=v.split(n);if(A.length===1)throw Error("Misformed armored text");const E=_o(A[0].slice(0,-1));await m.write(E);break}await m.write(k)}await m.ready,await m.close()}catch(w){await m.abort(w)}})))}catch(n){r(n)}})).then((async e=>(W(e.data)&&(e.data=await gt(e.data)),e)))}function Fn(t,e,r,n,i,s=!1,a=P){let c,u;t===o.armor.signed&&(c=e.text,u=e.hash,e=e.data);const l=s&&Mo(e),h=[];switch(t){case o.armor.multipartSection:h.push("-----BEGIN PGP MESSAGE, PART "+r+"/"+n+`-----
`),h.push(qe(i,a)),h.push(De(e)),l&&h.push("=",We(l)),h.push("-----END PGP MESSAGE, PART "+r+"/"+n+`-----
`);break;case o.armor.multipartLast:h.push("-----BEGIN PGP MESSAGE, PART "+r+`-----
`),h.push(qe(i,a)),h.push(De(e)),l&&h.push("=",We(l)),h.push("-----END PGP MESSAGE, PART "+r+`-----
`);break;case o.armor.signed:h.push(`-----BEGIN PGP SIGNED MESSAGE-----
`),h.push(u?`Hash: ${u}

`:`
`),h.push(c.replace(/^-/gm,"- -")),h.push(`
-----BEGIN PGP SIGNATURE-----
`),h.push(qe(i,a)),h.push(De(e)),l&&h.push("=",We(l)),h.push(`-----END PGP SIGNATURE-----
`);break;case o.armor.message:h.push(`-----BEGIN PGP MESSAGE-----
`),h.push(qe(i,a)),h.push(De(e)),l&&h.push("=",We(l)),h.push(`-----END PGP MESSAGE-----
`);break;case o.armor.publicKey:h.push(`-----BEGIN PGP PUBLIC KEY BLOCK-----
`),h.push(qe(i,a)),h.push(De(e)),l&&h.push("=",We(l)),h.push(`-----END PGP PUBLIC KEY BLOCK-----
`);break;case o.armor.privateKey:h.push(`-----BEGIN PGP PRIVATE KEY BLOCK-----
`),h.push(qe(i,a)),h.push(De(e)),l&&h.push("=",We(l)),h.push(`-----END PGP PRIVATE KEY BLOCK-----
`);break;case o.armor.signature:h.push(`-----BEGIN PGP SIGNATURE-----
`),h.push(qe(i,a)),h.push(De(e)),l&&h.push("=",We(l)),h.push(`-----END PGP SIGNATURE-----
`)}return y.concat(h)}const ee=BigInt(0),ut=BigInt(1);function K(t){const e="0123456789ABCDEF";let r="";return t.forEach((n=>{r+=e[n>>4]+e[15&n]})),BigInt("0x0"+r)}function T(t,e){const r=t%e;return r<ee?r+e:r}function he(t,e,r){if(r===ee)throw Error("Modulo cannot be zero");if(r===ut)return BigInt(0);if(e<ee)throw Error("Unsopported negative exponent");let n=e,i=t;i%=r;let s=BigInt(1);for(;n>ee;){const a=n&ut;n>>=ut,s=a?s*i%r:s,i=i*i%r}return s}function wi(t){return t>=ee?t:-t}function cr(t,e){const{gcd:r,x:n}=(function(i,s){let a=BigInt(0),c=BigInt(1),u=BigInt(1),l=BigInt(0),h=wi(i),p=wi(s);const g=i<ee,f=s<ee;for(;p!==ee;){const d=h/p;let m=a;a=u-d*a,u=m,m=c,c=l-d*c,l=m,m=p,p=h%p,h=m}return{x:g?-u:u,y:f?-l:l,gcd:h}})(t,e);if(r!==ut)throw Error("Inverse does not exist");return T(n+e,e)}function ln(t){const e=Number(t);if(e>Number.MAX_SAFE_INTEGER)throw Error("Number can only safely store up to 53 bits");return e}function jo(t,e){return(t>>BigInt(e)&ut)===ee?0:1}function lt(t){const e=t<ee?BigInt(-1):ee;let r=1,n=t;for(;(n>>=ut)!==e;)r++;return r}function xe(t){const e=t<ee?BigInt(-1):ee,r=BigInt(8);let n=1,i=t;for(;(i>>=r)!==e;)n++;return n}function q(t,e="be",r){let n=t.toString(16);n.length%2==1&&(n="0"+n);const i=n.length/2,s=new Uint8Array(r||i),a=r?r-i:0;let c=0;for(;c<i;)s[c+a]=parseInt(n.slice(2*c,2*c+2),16),c++;return e!=="be"&&s.reverse(),s}const Go=y.getNodeCrypto();function ye(t){const e=typeof crypto<"u"?crypto:Go?.webcrypto;if(e?.getRandomValues){const r=new Uint8Array(t);return e.getRandomValues(r)}throw Error("No secure random number generator available.")}function ht(t,e){if(e<t)throw Error("Illegal parameter value: max <= min");const r=e-t;return T(K(ye(xe(r)+8)),r)+t}const be=BigInt(1);function bi(t,e,r){const n=BigInt(30),i=be<<BigInt(t-1),s=[1,6,5,4,3,2,1,4,3,2,1,2,1,4,3,2,1,2,1,4,3,2,1,6,5,4,3,2,1,2];let a=ht(i,i<<be),c=ln(T(a,n));do a+=BigInt(s[c]),c=(c+s[c])%s.length,lt(a)>t&&(a=T(a,i<<be),a+=i,c=ln(T(a,n)));while(!Bs(a,e,r));return a}function Bs(t,e,r){return(!e||(function(n,i){let s=n,a=i;for(;a!==ee;){const c=a;a=s%a,s=c}return s})(t-be,e)===be)&&!!(function(n){const i=BigInt(0);return qo.every((s=>T(n,s)!==i))})(t)&&!!(function(n,i=BigInt(2)){return he(i,n-be,n)===be})(t)&&!!(function(n,i){const s=lt(n);i||(i=Math.max(1,s/48|0));const a=n-be;let c=0;for(;!jo(a,c);)c++;const u=n>>BigInt(c);for(;i>0;i--){let l,h=he(ht(BigInt(2),a),u,n);if(h!==be&&h!==a){for(l=1;l<c;l++){if(h=T(h*h,n),h===be)return!1;if(h===a)break}if(l===c)return!1}}return!0})(t,r)}const qo=[7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583,1597,1601,1607,1609,1613,1619,1621,1627,1637,1657,1663,1667,1669,1693,1697,1699,1709,1721,1723,1733,1741,1747,1753,1759,1777,1783,1787,1789,1801,1811,1823,1831,1847,1861,1867,1871,1873,1877,1879,1889,1901,1907,1913,1931,1933,1949,1951,1973,1979,1987,1993,1997,1999,2003,2011,2017,2027,2029,2039,2053,2063,2069,2081,2083,2087,2089,2099,2111,2113,2129,2131,2137,2141,2143,2153,2161,2179,2203,2207,2213,2221,2237,2239,2243,2251,2267,2269,2273,2281,2287,2293,2297,2309,2311,2333,2339,2341,2347,2351,2357,2371,2377,2381,2383,2389,2393,2399,2411,2417,2423,2437,2441,2447,2459,2467,2473,2477,2503,2521,2531,2539,2543,2549,2551,2557,2579,2591,2593,2609,2617,2621,2633,2647,2657,2659,2663,2671,2677,2683,2687,2689,2693,2699,2707,2711,2713,2719,2729,2731,2741,2749,2753,2767,2777,2789,2791,2797,2801,2803,2819,2833,2837,2843,2851,2857,2861,2879,2887,2897,2903,2909,2917,2927,2939,2953,2957,2963,2969,2971,2999,3001,3011,3019,3023,3037,3041,3049,3061,3067,3079,3083,3089,3109,3119,3121,3137,3163,3167,3169,3181,3187,3191,3203,3209,3217,3221,3229,3251,3253,3257,3259,3271,3299,3301,3307,3313,3319,3323,3329,3331,3343,3347,3359,3361,3371,3373,3389,3391,3407,3413,3433,3449,3457,3461,3463,3467,3469,3491,3499,3511,3517,3527,3529,3533,3539,3541,3547,3557,3559,3571,3581,3583,3593,3607,3613,3617,3623,3631,3637,3643,3659,3671,3673,3677,3691,3697,3701,3709,3719,3727,3733,3739,3761,3767,3769,3779,3793,3797,3803,3821,3823,3833,3847,3851,3853,3863,3877,3881,3889,3907,3911,3917,3919,3923,3929,3931,3943,3947,3967,3989,4001,4003,4007,4013,4019,4021,4027,4049,4051,4057,4073,4079,4091,4093,4099,4111,4127,4129,4133,4139,4153,4157,4159,4177,4201,4211,4217,4219,4229,4231,4241,4243,4253,4259,4261,4271,4273,4283,4289,4297,4327,4337,4339,4349,4357,4363,4373,4391,4397,4409,4421,4423,4441,4447,4451,4457,4463,4481,4483,4493,4507,4513,4517,4519,4523,4547,4549,4561,4567,4583,4591,4597,4603,4621,4637,4639,4643,4649,4651,4657,4663,4673,4679,4691,4703,4721,4723,4729,4733,4751,4759,4783,4787,4789,4793,4799,4801,4813,4817,4831,4861,4871,4877,4889,4903,4909,4919,4931,4933,4937,4943,4951,4957,4967,4969,4973,4987,4993,4999].map((t=>BigInt(t))),ki=y.getWebCrypto(),ur=y.getNodeCrypto(),Wo=ur&&ur.getHashes();function Fe(t){if(ur&&Wo.includes(t))return async function(e){const r=ur.createHash(t);return $(e,(n=>{r.update(n)}),(()=>new Uint8Array(r.digest())))}}function Re(t,e){const r=async()=>{const{nobleHashes:n}=await ge(async()=>{const{nobleHashes:s}=await import("./noble_hashes.min-CdcE1gs5.js");return{nobleHashes:s}},__vite__mapDeps([2,1]),import.meta.url),i=n.get(t);if(!i)throw Error("Unsupported hash");return i};return async function(n){if(W(n)&&(n=await gt(n)),y.isStream(n)){const i=(await r()).create();return $(n,(s=>{i.update(s)}),(()=>i.digest()))}return ki&&e?new Uint8Array(await ki.digest(e,n)):(await r())(n)}}const Vo=Fe("md5")||Re("md5"),Qo=Fe("sha1")||Re("sha1","SHA-1"),Zo=Fe("sha224")||Re("sha224"),Xo=Fe("sha256")||Re("sha256","SHA-256"),Jo=Fe("sha384")||Re("sha384","SHA-384"),Yo=Fe("sha512")||Re("sha512","SHA-512"),ec=Fe("ripemd160")||Re("ripemd160"),tc=Fe("sha3-256")||Re("sha3_256"),rc=Fe("sha3-512")||Re("sha3_512");function je(t,e){switch(t){case o.hash.md5:return Vo(e);case o.hash.sha1:return Qo(e);case o.hash.ripemd:return ec(e);case o.hash.sha256:return Xo(e);case o.hash.sha384:return Jo(e);case o.hash.sha512:return Yo(e);case o.hash.sha224:return Zo(e);case o.hash.sha3_256:return tc(e);case o.hash.sha3_512:return rc(e);default:throw Error("Unsupported hash function")}}function H(t){switch(t){case o.hash.md5:return 16;case o.hash.sha1:case o.hash.ripemd:return 20;case o.hash.sha256:return 32;case o.hash.sha384:return 48;case o.hash.sha512:return 64;case o.hash.sha224:return 28;case o.hash.sha3_256:return 32;case o.hash.sha3_512:return 64;default:throw Error("Invalid hash algorithm.")}}const ke=[];function Ls(t,e,r){let n;if(e.length!==H(t))throw Error("Invalid hash length");const i=new Uint8Array(ke[t].length);for(n=0;n<ke[t].length;n++)i[n]=ke[t][n];const s=i.length+e.length;if(r<s+11)throw Error("Intended encoded message length too short");const a=new Uint8Array(r-s-3).fill(255),c=new Uint8Array(r);return c[1]=1,c.set(a,2),c.set(i,r-s),c.set(e,r-e.length),c}ke[1]=[48,32,48,12,6,8,42,134,72,134,247,13,2,5,5,0,4,16],ke[2]=[48,33,48,9,6,5,43,14,3,2,26,5,0,4,20],ke[3]=[48,33,48,9,6,5,43,36,3,2,1,5,0,4,20],ke[8]=[48,49,48,13,6,9,96,134,72,1,101,3,4,2,1,5,0,4,32],ke[9]=[48,65,48,13,6,9,96,134,72,1,101,3,4,2,2,5,0,4,48],ke[10]=[48,81,48,13,6,9,96,134,72,1,101,3,4,2,3,5,0,4,64],ke[11]=[48,45,48,13,6,9,96,134,72,1,101,3,4,2,4,5,0,4,28];const mt=y.getWebCrypto(),Rn=y.getNodeCrypto(),wt=BigInt(1);async function nc(t,e,r,n,i,s,a,c,u){if(H(t)>=r.length)throw Error("Digest size cannot exceed key modulus size");if(e&&!y.isStream(e)){if(y.getWebCrypto())try{return await(async function(l,h,p,g,f,d,m,w){const b=vi(p,g,f,d,m,w),k={name:"RSASSA-PKCS1-v1_5",hash:{name:l}},v=await mt.importKey("jwk",b,k,!1,["sign"]);return new Uint8Array(await mt.sign("RSASSA-PKCS1-v1_5",v,h))})(o.read(o.webHash,t),e,r,n,i,s,a,c)}catch(l){y.printDebugError(l)}else if(y.getNodeCrypto())return(function(l,h,p,g,f,d,m,w){const b=Rn.createSign(o.read(o.hash,l));b.write(h),b.end();const k=vi(p,g,f,d,m,w);return new Uint8Array(b.sign({key:k,format:"jwk",type:"pkcs1"}))})(t,e,r,n,i,s,a,c)}return(function(l,h,p,g){h=K(h);const f=K(Ls(l,g,xe(h)));return p=K(p),q(he(f,p,h),"be",xe(h))})(t,r,i,u)}async function ic(t,e,r,n,i,s){if(e&&!y.isStream(e)){if(y.getWebCrypto())try{return await(async function(a,c,u,l,h){const p=Ai(l,h),g=await mt.importKey("jwk",p,{name:"RSASSA-PKCS1-v1_5",hash:{name:a}},!1,["verify"]);return mt.verify("RSASSA-PKCS1-v1_5",g,u,c)})(o.read(o.webHash,t),e,r,n,i)}catch(a){y.printDebugError(a)}else if(y.getNodeCrypto())return(function(a,c,u,l,h){const p=Ai(l,h),g={key:p,format:"jwk",type:"pkcs1"},f=Rn.createVerify(o.read(o.hash,a));f.write(c),f.end();try{return f.verify(g,u)}catch{return!1}})(t,e,r,n,i)}return(function(a,c,u,l,h){if(u=K(u),c=K(c),l=K(l),c>=u)throw Error("Signature size cannot exceed modulus size");const p=q(he(c,l,u),"be",xe(u)),g=Ls(a,h,xe(u));return y.equalsUint8Array(p,g)})(t,r,n,i,s)}function vi(t,e,r,n,i,s){const a=K(n),c=K(i),u=K(r);let l=T(u,c-wt),h=T(u,a-wt);return h=q(h),l=q(l),{kty:"RSA",n:_(t),e:_(e),d:_(r),p:_(i),q:_(n),dp:_(l),dq:_(h),qi:_(s),ext:!0}}function Ai(t,e){return{kty:"RSA",n:_(t),e:_(e),ext:!0}}function Ei(t,e){return{n:J(t.n),e:q(e),d:J(t.d),p:J(t.q),q:J(t.p),u:J(t.qi)}}const it=BigInt(1),sc={"2a8648ce3d030107":o.curve.nistP256,"2b81040022":o.curve.nistP384,"2b81040023":o.curve.nistP521,"2b8104000a":o.curve.secp256k1,"2b06010401da470f01":o.curve.ed25519Legacy,"2b060104019755010501":o.curve.curve25519Legacy,"2b2403030208010107":o.curve.brainpoolP256r1,"2b240303020801010b":o.curve.brainpoolP384r1,"2b240303020801010d":o.curve.brainpoolP512r1};class Te{constructor(e){if(e instanceof Te)this.oid=e.oid;else if(y.isArray(e)||y.isUint8Array(e)){if((e=new Uint8Array(e))[0]===6){if(e[1]!==e.length-2)throw Error("Length mismatch in DER encoded oid");e=e.subarray(2)}this.oid=e}else this.oid=""}read(e){if(e.length>=1){const r=e[0];if(e.length>=1+r)return this.oid=e.subarray(1,1+r),1+this.oid.length}throw Error("Invalid oid")}write(){return y.concatUint8Array([new Uint8Array([this.oid.length]),this.oid])}toHex(){return y.uint8ArrayToHex(this.oid)}getName(){const e=sc[this.toHex()];if(!e)throw Error("Unknown curve object identifier.");return e}}function Fs(t){let e,r=0;const n=t[0];return n<192?([r]=t,e=1):n<255?(r=(t[0]-192<<8)+t[1]+192,e=2):n===255&&(r=y.readNumber(t.subarray(1,5)),e=5),{len:r,offset:e}}function Pr(t){return t<192?new Uint8Array([t]):t>191&&t<8384?new Uint8Array([192+(t-192>>8),t-192&255]):y.concatUint8Array([new Uint8Array([255]),y.writeNumber(t,4)])}function ac(t){if(t<0||t>30)throw Error("Partial Length power must be between 1 and 30");return new Uint8Array([224+t])}function lr(t){return new Uint8Array([192|t])}function Si(t,e){return y.concatUint8Array([lr(t),Pr(e)])}function Zt(t){return[o.packet.literalData,o.packet.compressedData,o.packet.symmetricallyEncryptedData,o.packet.symEncryptedIntegrityProtectedData,o.packet.aeadEncryptedData].includes(t)}async function oc(t,e,r){let n,i;try{const s=await t.peekBytes(2);if(!s||s.length<2||!(128&s[0]))throw Error("Error during parsing. This message / key probably does not conform to a valid OpenPGP format.");const a=await t.readByte();let c,u,l=-1,h=-1;h=0,64&a&&(h=1),h?l=63&a:(l=(63&a)>>2,u=3&a);const p=Zt(l);let g,f=null;if(e&&p){if(e==="array"){const d=new oe;n=Ke(d),f=d}else{const d=new TransformStream;n=Ke(d.writable),f=d.readable}i=r({tag:l,packet:f})}else f=[];do{if(h){const d=await t.readByte();if(g=!1,d<192)c=d;else if(d>=192&&d<224)c=(d-192<<8)+await t.readByte()+192;else if(d>223&&d<255){if(c=1<<(31&d),g=!0,!p)throw new TypeError("This packet type does not support partial lengths.")}else c=await t.readByte()<<24|await t.readByte()<<16|await t.readByte()<<8|await t.readByte()}else switch(u){case 0:c=await t.readByte();break;case 1:c=await t.readByte()<<8|await t.readByte();break;case 2:c=await t.readByte()<<24|await t.readByte()<<16|await t.readByte()<<8|await t.readByte();break;default:c=1/0}if(c>0){let d=0;for(;;){n&&await n.ready;const{done:m,value:w}=await t.read();if(m){if(c===1/0)break;throw Error("Unexpected end of packet")}const b=c===1/0?w:w.subarray(0,c-d);if(n?await n.write(b):f.push(b),d+=w.length,d>=c){t.unshift(w.subarray(c-d+w.length));break}}}}while(g);n?(await n.ready,await n.close()):(f=y.concatUint8Array(f),await r({tag:l,packet:f}))}catch(s){if(n)return await n.abort(s),!0;throw s}finally{n&&await i}}class O extends Error{constructor(...e){super(...e),Error.captureStackTrace&&Error.captureStackTrace(this,O),this.name="UnsupportedError"}}class Xt extends O{constructor(...e){super(...e),Error.captureStackTrace&&Error.captureStackTrace(this,O),this.name="UnknownPacketError"}}class zr extends O{constructor(...e){super(...e),Error.captureStackTrace&&Error.captureStackTrace(this,O),this.name="MalformedPacketError"}}class hn{constructor(e,r){this.tag=e,this.rawContent=r}write(){return this.rawContent}}async function On(t){switch(t){case o.publicKey.ed25519:try{const e=y.getWebCrypto(),r=await e.generateKey("Ed25519",!0,["sign","verify"]).catch((s=>{if(s.name==="OperationError"){const a=Error("Unexpected key generation issue");throw a.name="NotSupportedError",a}throw s})),n=await e.exportKey("jwk",r.privateKey),i=await e.exportKey("jwk",r.publicKey);return{A:new Uint8Array(J(i.x)),seed:J(n.d)}}catch(e){if(e.name!=="NotSupportedError")throw e;const{default:r}=await ge(async()=>{const{default:s}=await import("./nacl-fast.min-qTGi1RRO.js");return{default:s}},[],import.meta.url),n=ye(Kr(t)),{publicKey:i}=r.sign.keyPair.fromSeed(n);return{A:i,seed:n}}case o.publicKey.ed448:{const e=await y.getNobleCurve(o.publicKey.ed448),{secretKey:r,publicKey:n}=e.keygen();return{A:n,seed:r}}default:throw Error("Unsupported EdDSA algorithm")}}async function Nn(t,e,r,n,i,s){if(H(e)<H(Ur(t)))throw Error("Hash algorithm too weak for EdDSA.");switch(t){case o.publicKey.ed25519:try{const a=y.getWebCrypto(),c=Rs(t,n,i),u=await a.importKey("jwk",c,"Ed25519",!1,["sign"]);return{RS:new Uint8Array(await a.sign("Ed25519",u,s))}}catch(a){if(a.name!=="NotSupportedError")throw a;const{default:c}=await ge(async()=>{const{default:l}=await import("./nacl-fast.min-qTGi1RRO.js");return{default:l}},[],import.meta.url),u=y.concatUint8Array([i,n]);return{RS:c.sign.detached(s,u)}}case o.publicKey.ed448:return{RS:(await y.getNobleCurve(o.publicKey.ed448)).sign(s,i)};default:throw Error("Unsupported EdDSA algorithm")}}async function Mn(t,e,{RS:r},n,i,s){if(H(e)<H(Ur(t)))throw Error("Hash algorithm too weak for EdDSA.");switch(t){case o.publicKey.ed25519:try{const a=y.getWebCrypto(),c=$n(t,i),u=await a.importKey("jwk",c,"Ed25519",!1,["verify"]);return await a.verify("Ed25519",u,r,s)}catch(a){if(a.name!=="NotSupportedError")throw a;const{default:c}=await ge(async()=>{const{default:u}=await import("./nacl-fast.min-qTGi1RRO.js");return{default:u}},[],import.meta.url);return c.sign.detached.verify(s,r,i)}case o.publicKey.ed448:return(await y.getNobleCurve(o.publicKey.ed448)).verify(r,s,i);default:throw Error("Unsupported EdDSA algorithm")}}async function Hn(t,e,r){switch(t){case o.publicKey.ed25519:try{const n=y.getWebCrypto(),i=Rs(t,e,r),s=$n(t,e),a=await n.importKey("jwk",i,"Ed25519",!1,["sign"]),c=await n.importKey("jwk",s,"Ed25519",!1,["verify"]),u=ye(8),l=new Uint8Array(await n.sign("Ed25519",a,u));return await n.verify("Ed25519",c,l,u)}catch(n){if(n.name!=="NotSupportedError")return!1;const{default:i}=await ge(async()=>{const{default:a}=await import("./nacl-fast.min-qTGi1RRO.js");return{default:a}},[],import.meta.url),{publicKey:s}=i.sign.keyPair.fromSeed(r);return y.equalsUint8Array(e,s)}case o.publicKey.ed448:{const n=(await y.getNobleCurve(o.publicKey.ed448)).getPublicKey(r);return y.equalsUint8Array(e,n)}default:return!1}}function Kr(t){switch(t){case o.publicKey.ed25519:return 32;case o.publicKey.ed448:return 57;default:throw Error("Unsupported EdDSA algorithm")}}function Ur(t){switch(t){case o.publicKey.ed25519:return o.hash.sha256;case o.publicKey.ed448:return o.hash.sha512;default:throw Error("Unknown EdDSA algo")}}const $n=(t,e)=>{if(t===o.publicKey.ed25519)return{kty:"OKP",crv:"Ed25519",x:_(e),ext:!0};throw Error("Unsupported EdDSA algorithm")},Rs=(t,e,r)=>{if(t===o.publicKey.ed25519){const n=$n(t,e);return n.d=_(r),n}throw Error("Unsupported EdDSA algorithm")};var cc=Object.freeze({__proto__:null,generate:On,getPayloadSize:Kr,getPreferredHashAlgo:Ur,sign:Nn,validateParams:Hn,verify:Mn});function Os(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function N(t,...e){if(!Os(t))throw Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw Error("Uint8Array expected of length "+e+", got length="+t.length)}function hr(t,e=!0){if(t.destroyed)throw Error("Hash instance has been destroyed");if(e&&t.finished)throw Error("Hash#digest() has already been called")}function Ns(t,e){N(t);const r=e.outputLen;if(t.length<r)throw Error("digestInto() expects output buffer of length at least "+r)}function zn(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}function F(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function V(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function Dr(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}const uc=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function Rt(t){if(typeof t=="string")t=(function(e){if(typeof e!="string")throw Error("string expected");return new Uint8Array(new TextEncoder().encode(e))})(t);else{if(!Os(t))throw Error("Uint8Array expected, got "+typeof t);t=Y(t)}return t}function Ms(t,e){return t.buffer===e.buffer&&t.byteOffset<e.byteOffset+e.byteLength&&e.byteOffset<t.byteOffset+t.byteLength}function yn(t,e){if(Ms(t,e)&&t.byteOffset<e.byteOffset)throw Error("complex overlap of input and output is not supported")}function Hs(t,e){if(t.length!==e.length)return!1;let r=0;for(let n=0;n<t.length;n++)r|=t[n]^e[n];return r===0}const $t=(t,e)=>{function r(n,...i){if(N(n),!uc)throw Error("Non little-endian hardware is not yet supported");if(t.nonceLength!==void 0){const l=i[0];if(!l)throw Error("nonce / iv required");t.varSizeNonce?N(l):N(l,t.nonceLength)}const s=t.tagLength;s&&i[1]!==void 0&&N(i[1]);const a=e(n,...i),c=(l,h)=>{if(h!==void 0){if(l!==2)throw Error("cipher output not supported");N(h)}};let u=!1;return{encrypt(l,h){if(u)throw Error("cannot encrypt() twice with same key + nonce");return u=!0,N(l),c(a.encrypt.length,h),a.encrypt(l,h)},decrypt(l,h){if(N(l),s&&l.length<s)throw Error("invalid ciphertext length: smaller than tagLength="+s);return c(a.decrypt.length,h),a.decrypt(l,h)}}}return Object.assign(r,t),r};function Ot(t,e,r=!0){if(e===void 0)return new Uint8Array(t);if(e.length!==t)throw Error("invalid output length, expected "+t+", got: "+e.length);if(r&&!ce(e))throw Error("invalid output, must be aligned");return e}function pn(t,e,r,n){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,r,n);const i=BigInt(32),s=BigInt(4294967295),a=Number(r>>i&s),c=Number(r&s);t.setUint32(e+0,a,n),t.setUint32(e+4,c,n)}function ce(t){return t.byteOffset%4==0}function Y(t){return Uint8Array.from(t)}const Ie=16,_n=new Uint8Array(16),Ae=F(_n),se=t=>(t>>>0&255)<<24|(t>>>8&255)<<16|(t>>>16&255)<<8|t>>>24&255;class $s{constructor(e,r){this.blockLen=Ie,this.outputLen=Ie,this.s0=0,this.s1=0,this.s2=0,this.s3=0,this.finished=!1,N(e=Rt(e),16);const n=Dr(e);let i=n.getUint32(0,!1),s=n.getUint32(4,!1),a=n.getUint32(8,!1),c=n.getUint32(12,!1);const u=[];for(let k=0;k<128;k++)u.push({s0:se(i),s1:se(s),s2:se(a),s3:se(c)}),{s0:i,s1:s,s2:a,s3:c}={s3:(p=a)<<31|(g=c)>>>1,s2:(h=s)<<31|p>>>1,s1:(l=i)<<31|h>>>1,s0:l>>>1^225<<24&-(1&g)};var l,h,p,g;const f=(d=r||1024)>65536?8:d>1024?4:2;var d;if(![1,2,4,8].includes(f))throw Error("ghash: invalid window size, expected 2, 4 or 8");this.W=f;const m=128/f,w=this.windowSize=2**f,b=[];for(let k=0;k<m;k++)for(let v=0;v<w;v++){let A=0,E=0,D=0,S=0;for(let I=0;I<f;I++){if(!(v>>>f-I-1&1))continue;const{s0:x,s1:U,s2:C,s3:M}=u[f*k+I];A^=x,E^=U,D^=C,S^=M}b.push({s0:A,s1:E,s2:D,s3:S})}this.t=b}_updateBlock(e,r,n,i){e^=this.s0,r^=this.s1,n^=this.s2,i^=this.s3;const{W:s,t:a,windowSize:c}=this;let u=0,l=0,h=0,p=0;const g=(1<<s)-1;let f=0;for(const d of[e,r,n,i])for(let m=0;m<4;m++){const w=d>>>8*m&255;for(let b=8/s-1;b>=0;b--){const k=w>>>s*b&g,{s0:v,s1:A,s2:E,s3:D}=a[f*c+k];u^=v,l^=A,h^=E,p^=D,f+=1}}this.s0=u,this.s1=l,this.s2=h,this.s3=p}update(e){hr(this),N(e=Rt(e));const r=F(e),n=Math.floor(e.length/Ie),i=e.length%Ie;for(let s=0;s<n;s++)this._updateBlock(r[4*s+0],r[4*s+1],r[4*s+2],r[4*s+3]);return i&&(_n.set(e.subarray(n*Ie)),this._updateBlock(Ae[0],Ae[1],Ae[2],Ae[3]),V(Ae)),this}destroy(){const{t:e}=this;for(const r of e)r.s0=0,r.s1=0,r.s2=0,r.s3=0}digestInto(e){hr(this),Ns(e,this),this.finished=!0;const{s0:r,s1:n,s2:i,s3:s}=this,a=F(e);return a[0]=r,a[1]=n,a[2]=i,a[3]=s,e}digest(){const e=new Uint8Array(Ie);return this.digestInto(e),this.destroy(),e}}class lc extends $s{constructor(e,r){N(e=Rt(e));const n=(function(i){i.reverse();const s=1&i[15];let a=0;for(let c=0;c<i.length;c++){const u=i[c];i[c]=u>>>1|a,a=(1&u)<<7}return i[0]^=225&-s,i})(Y(e));super(n,r),V(n)}update(e){e=Rt(e),hr(this);const r=F(e),n=e.length%Ie,i=Math.floor(e.length/Ie);for(let s=0;s<i;s++)this._updateBlock(se(r[4*s+3]),se(r[4*s+2]),se(r[4*s+1]),se(r[4*s+0]));return n&&(_n.set(e.subarray(i*Ie)),this._updateBlock(se(Ae[3]),se(Ae[2]),se(Ae[1]),se(Ae[0])),V(Ae)),this}digestInto(e){hr(this),Ns(e,this),this.finished=!0;const{s0:r,s1:n,s2:i,s3:s}=this,a=F(e);return a[0]=r,a[1]=n,a[2]=i,a[3]=s,e.reverse()}}function zs(t){const e=(n,i)=>t(i,n.length).update(Rt(n)).digest(),r=t(new Uint8Array(16),0);return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=(n,i)=>t(n,i),e}const Pi=zs(((t,e)=>new $s(t,e)));zs(((t,e)=>new lc(t,e)));const re=16,jt=new Uint8Array(re);function jn(t){return t<<1^283&-(t>>7)}function at(t,e){let r=0;for(;e>0;e>>=1)r^=t&-(1&e),t=jn(t);return r}const fn=(()=>{const t=new Uint8Array(256);for(let r=0,n=1;r<256;r++,n^=jn(n))t[r]=n;const e=new Uint8Array(256);e[0]=99;for(let r=0;r<255;r++){let n=t[255-r];n|=n<<8,e[t[r]]=255&(n^n>>4^n>>5^n>>6^n>>7^99)}return V(t),e})(),hc=fn.map(((t,e)=>fn.indexOf(e))),_r=t=>t<<8|t>>>24,Ki=t=>t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255;function _s(t,e){if(t.length!==256)throw Error("Wrong sbox length");const r=new Uint32Array(256).map(((l,h)=>e(t[h]))),n=r.map(_r),i=n.map(_r),s=i.map(_r),a=new Uint32Array(65536),c=new Uint32Array(65536),u=new Uint16Array(65536);for(let l=0;l<256;l++)for(let h=0;h<256;h++){const p=256*l+h;a[p]=r[l]^n[h],c[p]=i[l]^s[h],u[p]=t[l]<<8|t[h]}return{sbox:t,sbox2:u,T0:r,T1:n,T2:i,T3:s,T01:a,T23:c}}const Gn=_s(fn,(t=>at(t,3)<<24|t<<16|t<<8|at(t,2))),js=_s(hc,(t=>at(t,11)<<24|at(t,13)<<16|at(t,9)<<8|at(t,14))),yc=(()=>{const t=new Uint8Array(16);for(let e=0,r=1;e<16;e++,r=jn(r))t[e]=r;return t})();function nt(t){N(t);const e=t.length;if(![16,24,32].includes(e))throw Error("aes: invalid key size, should be 16, 24 or 32, got "+e);const{sbox2:r}=Gn,n=[];ce(t)||n.push(t=Y(t));const i=F(t),s=i.length,a=l=>Ee(r,l,l,l,l),c=new Uint32Array(e+28);c.set(i);for(let l=s;l<c.length;l++){let h=c[l-1];l%s==0?h=a((u=h)<<24|u>>>8)^yc[l/s-1]:s>6&&l%s==4&&(h=a(h)),c[l]=c[l-s]^h}var u;return V(...n),c}function qn(t){const e=nt(t),r=e.slice(),n=e.length,{sbox2:i}=Gn,{T0:s,T1:a,T2:c,T3:u}=js;for(let l=0;l<n;l+=4)for(let h=0;h<4;h++)r[l+h]=e[n-l-4+h];V(e);for(let l=4;l<n-4;l++){const h=r[l],p=Ee(i,h,h,h,h);r[l]=s[255&p]^a[p>>>8&255]^c[p>>>16&255]^u[p>>>24]}return r}function $e(t,e,r,n,i,s){return t[r<<8&65280|n>>>8&255]^e[i>>>8&65280|s>>>24&255]}function Ee(t,e,r,n,i){return t[255&e|65280&r]|t[n>>>16&255|i>>>16&65280]<<16}function pe(t,e,r,n,i){const{sbox2:s,T01:a,T23:c}=Gn;let u=0;e^=t[u++],r^=t[u++],n^=t[u++],i^=t[u++];const l=t.length/4-2;for(let h=0;h<l;h++){const p=t[u++]^$e(a,c,e,r,n,i),g=t[u++]^$e(a,c,r,n,i,e),f=t[u++]^$e(a,c,n,i,e,r),d=t[u++]^$e(a,c,i,e,r,n);e=p,r=g,n=f,i=d}return{s0:t[u++]^Ee(s,e,r,n,i),s1:t[u++]^Ee(s,r,n,i,e),s2:t[u++]^Ee(s,n,i,e,r),s3:t[u++]^Ee(s,i,e,r,n)}}function Ir(t,e,r,n,i){const{sbox2:s,T01:a,T23:c}=js;let u=0;e^=t[u++],r^=t[u++],n^=t[u++],i^=t[u++];const l=t.length/4-2;for(let h=0;h<l;h++){const p=t[u++]^$e(a,c,e,i,n,r),g=t[u++]^$e(a,c,r,e,i,n),f=t[u++]^$e(a,c,n,r,e,i),d=t[u++]^$e(a,c,i,n,r,e);e=p,r=g,n=f,i=d}return{s0:t[u++]^Ee(s,e,i,n,r),s1:t[u++]^Ee(s,r,e,i,n),s2:t[u++]^Ee(s,n,r,e,i),s3:t[u++]^Ee(s,i,n,r,e)}}function Gs(t,e,r,n){N(e,re),N(r);const i=r.length;yn(r,n=Ot(i,n));const s=e,a=F(s);let{s0:c,s1:u,s2:l,s3:h}=pe(t,a[0],a[1],a[2],a[3]);const p=F(r),g=F(n);for(let d=0;d+4<=p.length;d+=4){g[d+0]=p[d+0]^c,g[d+1]=p[d+1]^u,g[d+2]=p[d+2]^l,g[d+3]=p[d+3]^h;let m=1;for(let w=s.length-1;w>=0;w--)m=m+(255&s[w])|0,s[w]=255&m,m>>>=8;({s0:c,s1:u,s2:l,s3:h}=pe(t,a[0],a[1],a[2],a[3]))}const f=re*Math.floor(p.length/4);if(f<i){const d=new Uint32Array([c,u,l,h]),m=zn(d);for(let w=f,b=0;w<i;w++,b++)n[w]=r[w]^m[b];V(d)}return n}function Dt(t,e,r,n,i){N(r,re),N(n),i=Ot(n.length,i);const s=r,a=F(s),c=Dr(s),u=F(n),l=F(i),h=e?0:12,p=n.length;let g=c.getUint32(h,e),{s0:f,s1:d,s2:m,s3:w}=pe(t,a[0],a[1],a[2],a[3]);for(let k=0;k+4<=u.length;k+=4)l[k+0]=u[k+0]^f,l[k+1]=u[k+1]^d,l[k+2]=u[k+2]^m,l[k+3]=u[k+3]^w,g=g+1>>>0,c.setUint32(h,g,e),{s0:f,s1:d,s2:m,s3:w}=pe(t,a[0],a[1],a[2],a[3]);const b=re*Math.floor(u.length/4);if(b<p){const k=new Uint32Array([f,d,m,w]),v=zn(k);for(let A=b,E=0;A<p;A++,E++)i[A]=n[A]^v[E];V(k)}return i}const pc=$t({blockSize:16,nonceLength:16},(function(t,e){function r(n,i){if(N(n),i!==void 0&&(N(i),!ce(i)))throw Error("unaligned destination");const s=nt(t),a=Y(e),c=[s,a];ce(n)||c.push(n=Y(n));const u=Gs(s,a,n,i);return V(...c),u}return{encrypt:(n,i)=>r(n,i),decrypt:(n,i)=>r(n,i)}})),gn=$t({blockSize:16,nonceLength:16},(function(t,e,r={}){const n=!r.disablePadding;return{encrypt(i,s){const a=nt(t),{b:c,o:u,out:l}=(function(k,v,A){N(k);let E=k.length;const D=E%re;if(!v&&D!==0)throw Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");ce(k)||(k=Y(k));const S=F(k);if(v){let I=re-D;I||(I=re),E+=I}return yn(k,A=Ot(E,A)),{b:S,o:F(A),out:A}})(i,n,s);let h=e;const p=[a];ce(h)||p.push(h=Y(h));const g=F(h);let f=g[0],d=g[1],m=g[2],w=g[3],b=0;for(;b+4<=c.length;)f^=c[b+0],d^=c[b+1],m^=c[b+2],w^=c[b+3],{s0:f,s1:d,s2:m,s3:w}=pe(a,f,d,m,w),u[b++]=f,u[b++]=d,u[b++]=m,u[b++]=w;if(n){const k=(function(v){const A=new Uint8Array(16),E=F(A);A.set(v);const D=re-v.length;for(let S=re-D;S<re;S++)A[S]=D;return E})(i.subarray(4*b));f^=k[0],d^=k[1],m^=k[2],w^=k[3],{s0:f,s1:d,s2:m,s3:w}=pe(a,f,d,m,w),u[b++]=f,u[b++]=d,u[b++]=m,u[b++]=w}return V(...p),l},decrypt(i,s){(function(w){if(N(w),w.length%re!=0)throw Error("aes-(cbc/ecb).decrypt ciphertext should consist of blocks with size 16")})(i);const a=qn(t);let c=e;const u=[a];ce(c)||u.push(c=Y(c));const l=F(c);s=Ot(i.length,s),ce(i)||u.push(i=Y(i)),yn(i,s);const h=F(i),p=F(s);let g=l[0],f=l[1],d=l[2],m=l[3];for(let w=0;w+4<=h.length;){const b=g,k=f,v=d,A=m;g=h[w+0],f=h[w+1],d=h[w+2],m=h[w+3];const{s0:E,s1:D,s2:S,s3:I}=Ir(a,g,f,d,m);p[w++]=E^b,p[w++]=D^k,p[w++]=S^v,p[w++]=I^A}return V(...u),(function(w,b){if(!b)return w;const k=w.length;if(!k)throw Error("aes/pcks5: empty ciphertext not allowed");const v=w[k-1];if(v<=0||v>16)throw Error("aes/pcks5: wrong padding");const A=w.subarray(0,-v);for(let E=0;E<v;E++)if(w[k-E-1]!==v)throw Error("aes/pcks5: wrong padding");return A})(s,n)}}})),qs=$t({blockSize:16,nonceLength:16},(function(t,e){function r(n,i,s){N(n);const a=n.length;if(Ms(n,s=Ot(a,s)))throw Error("overlapping src and dst not supported.");const c=nt(t);let u=e;const l=[c];ce(u)||l.push(u=Y(u)),ce(n)||l.push(n=Y(n));const h=F(n),p=F(s),g=i?p:h,f=F(u);let d=f[0],m=f[1],w=f[2],b=f[3];for(let v=0;v+4<=h.length;){const{s0:A,s1:E,s2:D,s3:S}=pe(c,d,m,w,b);p[v+0]=h[v+0]^A,p[v+1]=h[v+1]^E,p[v+2]=h[v+2]^D,p[v+3]=h[v+3]^S,d=g[v++],m=g[v++],w=g[v++],b=g[v++]}const k=re*Math.floor(h.length/4);if(k<a){({s0:d,s1:m,s2:w,s3:b}=pe(c,d,m,w,b));const v=zn(new Uint32Array([d,m,w,b]));for(let A=k,E=0;A<a;A++,E++)s[A]=n[A]^v[E];V(v)}return V(...l),s}return{encrypt:(n,i)=>r(n,!0,i),decrypt:(n,i)=>r(n,!1,i)}}));function fc(t,e,r,n,i){const s=i?i.length:0,a=t.create(r,n.length+s);i&&a.update(i);const c=(function(l,h,p){const g=new Uint8Array(16),f=Dr(g);return pn(f,0,BigInt(h),p),pn(f,8,BigInt(l),p),g})(8*n.length,8*s,e);a.update(n),a.update(c);const u=a.digest();return V(c),u}const Gt=$t({blockSize:16,nonceLength:12,tagLength:16,varSizeNonce:!0},(function(t,e,r){if(e.length<8)throw Error("aes/gcm: invalid nonce length");function n(s,a,c){const u=fc(Pi,!1,s,c,r);for(let l=0;l<a.length;l++)u[l]^=a[l];return u}function i(){const s=nt(t),a=jt.slice(),c=jt.slice();if(Dt(s,!1,c,c,a),e.length===12)c.set(e);else{const u=jt.slice();pn(Dr(u),8,BigInt(8*e.length),!1);const l=Pi.create(a).update(e).update(u);l.digestInto(c),l.destroy()}return{xk:s,authKey:a,counter:c,tagMask:Dt(s,!1,c,jt)}}return{encrypt(s){const{xk:a,authKey:c,counter:u,tagMask:l}=i(),h=new Uint8Array(s.length+16),p=[a,c,u,l];ce(s)||p.push(s=Y(s)),Dt(a,!1,u,s,h.subarray(0,s.length));const g=n(c,l,h.subarray(0,h.length-16));return p.push(g),h.set(g,s.length),V(...p),h},decrypt(s){const{xk:a,authKey:c,counter:u,tagMask:l}=i(),h=[a,c,l,u];ce(s)||h.push(s=Y(s));const p=s.subarray(0,-16),g=s.subarray(-16),f=n(c,l,p);if(h.push(f),!Hs(f,g))throw Error("aes/gcm: invalid ghash tag");const d=Dt(a,!1,u,p);return V(...h),d}}}));function Ws(t){return t instanceof Uint32Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint32Array"}function Vs(t,e){if(N(e,16),!Ws(t))throw Error("_encryptBlock accepts result of expandKeyLE");const r=F(e);let{s0:n,s1:i,s2:s,s3:a}=pe(t,r[0],r[1],r[2],r[3]);return r[0]=n,r[1]=i,r[2]=s,r[3]=a,e}function Qs(t,e){if(N(e,16),!Ws(t))throw Error("_decryptBlock accepts result of expandKeyLE");const r=F(e);let{s0:n,s1:i,s2:s,s3:a}=Ir(t,r[0],r[1],r[2],r[3]);return r[0]=n,r[1]=i,r[2]=s,r[3]=a,e}const Ui={encrypt(t,e){if(e.length>=2**32)throw Error("plaintext should be less than 4gb");const r=nt(t);if(e.length===16)Vs(r,e);else{const n=F(e);let i=n[0],s=n[1];for(let a=0,c=1;a<6;a++)for(let u=2;u<n.length;u+=2,c++){const{s0:l,s1:h,s2:p,s3:g}=pe(r,i,s,n[u],n[u+1]);i=l,s=h^Ki(c),n[u]=p,n[u+1]=g}n[0]=i,n[1]=s}r.fill(0)},decrypt(t,e){if(e.length-8>=2**32)throw Error("ciphertext should be less than 4gb");const r=qn(t),n=e.length/8-1;if(n===1)Qs(r,e);else{const i=F(e);let s=i[0],a=i[1];for(let c=0,u=6*n;c<6;c++)for(let l=2*n;l>=1;l-=2,u--){a^=Ki(u);const{s0:h,s1:p,s2:g,s3:f}=Ir(r,s,a,i[l],i[l+1]);s=h,a=p,i[l]=g,i[l+1]=f}i[0]=s,i[1]=a}r.fill(0)}},Di=new Uint8Array(8).fill(166),Zs=$t({blockSize:8},(t=>({encrypt(e){if(!e.length||e.length%8!=0)throw Error("invalid plaintext length");if(e.length===8)throw Error("8-byte keys not allowed in AESKW, use AESKWP instead");const r=(function(...n){let i=0;for(let a=0;a<n.length;a++){const c=n[a];N(c),i+=c.length}const s=new Uint8Array(i);for(let a=0,c=0;a<n.length;a++){const u=n[a];s.set(u,c),c+=u.length}return s})(Di,e);return Ui.encrypt(t,r),r},decrypt(e){if(e.length%8!=0||e.length<24)throw Error("invalid ciphertext length");const r=Y(e);if(Ui.decrypt(t,r),!Hs(r.subarray(0,8),Di))throw Error("integrity check failed");return r.subarray(0,8).fill(0),r.subarray(8)}}))),Ii={expandKeyLE:nt,expandKeyDecLE:qn,encrypt:pe,decrypt:Ir,encryptBlock:Vs,decryptBlock:Qs,ctrCounter:Gs,ctr32:Dt};async function Xs(t){switch(t){case o.symmetric.aes128:case o.symmetric.aes192:case o.symmetric.aes256:throw Error("Not a legacy cipher");case o.symmetric.cast5:case o.symmetric.blowfish:case o.symmetric.twofish:case o.symmetric.tripledes:{const{legacyCiphers:e}=await ge(async()=>{const{legacyCiphers:i}=await import("./legacy_ciphers.min-DU3eQIJx.js");return{legacyCiphers:i}},[],import.meta.url),r=o.read(o.symmetric,t),n=e.get(r);if(!n)throw Error("Unsupported cipher algorithm");return n}default:throw Error("Unsupported cipher algorithm")}}function gc(t){switch(t){case o.symmetric.aes128:case o.symmetric.aes192:case o.symmetric.aes256:case o.symmetric.twofish:return 16;case o.symmetric.blowfish:case o.symmetric.cast5:case o.symmetric.tripledes:return 8;default:throw Error("Unsupported cipher")}}function dc(t){switch(t){case o.symmetric.aes128:case o.symmetric.blowfish:case o.symmetric.cast5:return 16;case o.symmetric.aes192:case o.symmetric.tripledes:return 24;case o.symmetric.aes256:case o.symmetric.twofish:return 32;default:throw Error("Unsupported cipher")}}function Z(t){return{keySize:dc(t),blockSize:gc(t)}}const yt=y.getWebCrypto();async function dn(t,e,r){const{keySize:n}=Z(t);if(!y.isAES(t)||e.length!==n)throw Error("Unexpected algorithm or key size");try{const i=await yt.importKey("raw",e,{name:"AES-KW"},!1,["wrapKey"]),s=await yt.importKey("raw",r,{name:"HMAC",hash:"SHA-256"},!0,["sign"]),a=await yt.wrapKey("raw",s,i,{name:"AES-KW"});return new Uint8Array(a)}catch(i){if(i.name!=="NotSupportedError"&&(e.length!==24||i.name!=="OperationError"))throw i;y.printDebugError("Browser did not support operation: "+i.message)}return Zs(e).encrypt(r)}async function mn(t,e,r){const{keySize:n}=Z(t);if(!y.isAES(t)||e.length!==n)throw Error("Unexpected algorithm or key size");let i;try{i=await yt.importKey("raw",e,{name:"AES-KW"},!1,["unwrapKey"])}catch(s){if(s.name!=="NotSupportedError"&&(e.length!==24||s.name!=="OperationError"))throw s;return y.printDebugError("Browser did not support operation: "+s.message),Zs(e).decrypt(r)}try{const s=await yt.unwrapKey("raw",r,i,{name:"AES-KW"},{name:"HMAC",hash:"SHA-256"},!0,["sign"]);return new Uint8Array(await yt.exportKey("raw",s))}catch(s){throw s.name==="OperationError"?Error("Key Data Integrity failed"):s}}async function Nt(t,e,r,n,i){const s=y.getWebCrypto(),a=o.read(o.webHash,t);if(!a)throw Error("Hash algo not supported with HKDF");const c=await s.importKey("raw",e,"HKDF",!1,["deriveBits"]),u=await s.deriveBits({name:"HKDF",hash:a,salt:r,info:n},c,8*i);return new Uint8Array(u)}const yr={x25519:y.encodeUTF8("OpenPGP X25519"),x448:y.encodeUTF8("OpenPGP X448")};async function Wn(t){switch(t){case o.publicKey.x25519:try{const e=y.getWebCrypto(),r=await e.generateKey("X25519",!0,["deriveKey","deriveBits"]).catch((s=>{if(s.name==="OperationError"){const a=Error("Unexpected key generation issue");throw a.name="NotSupportedError",a}throw s})),n=await e.exportKey("jwk",r.privateKey),i=await e.exportKey("jwk",r.publicKey);if(n.x!==i.x){const s=Error("Unexpected mismatching public point");throw s.name="NotSupportedError",s}return{A:new Uint8Array(J(i.x)),k:J(n.d)}}catch(e){if(e.name!=="NotSupportedError")throw e;const{default:r}=await ge(async()=>{const{default:s}=await import("./nacl-fast.min-qTGi1RRO.js");return{default:s}},[],import.meta.url),{secretKey:n,publicKey:i}=r.box.keyPair();return{A:i,k:n}}case o.publicKey.x448:{const e=await y.getNobleCurve(o.publicKey.x448),{secretKey:r,publicKey:n}=e.keygen();return{A:n,k:r}}default:throw Error("Unsupported ECDH algorithm")}}async function Vn(t,e,r){switch(t){case o.publicKey.x25519:try{const{ephemeralPublicKey:n,sharedSecret:i}=await xr(t,e),s=await Tr(t,n,e,r);return y.equalsUint8Array(i,s)}catch{return!1}case o.publicKey.x448:{const n=(await y.getNobleCurve(o.publicKey.x448)).getPublicKey(r);return y.equalsUint8Array(e,n)}default:return!1}}async function mc(t,e,r){const{ephemeralPublicKey:n,sharedSecret:i}=await xr(t,r),s=y.concatUint8Array([n,r,i]);switch(t){case o.publicKey.x25519:{const a=o.symmetric.aes128,{keySize:c}=Z(a),u=await Nt(o.hash.sha256,s,new Uint8Array,yr.x25519,c);return{ephemeralPublicKey:n,wrappedKey:await dn(a,u,e)}}case o.publicKey.x448:{const a=o.symmetric.aes256,{keySize:c}=Z(o.symmetric.aes256),u=await Nt(o.hash.sha512,s,new Uint8Array,yr.x448,c);return{ephemeralPublicKey:n,wrappedKey:await dn(a,u,e)}}default:throw Error("Unsupported ECDH algorithm")}}async function wc(t,e,r,n,i){const s=await Tr(t,e,n,i),a=y.concatUint8Array([e,n,s]);switch(t){case o.publicKey.x25519:{const c=o.symmetric.aes128,{keySize:u}=Z(c);return mn(c,await Nt(o.hash.sha256,a,new Uint8Array,yr.x25519,u),r)}case o.publicKey.x448:{const c=o.symmetric.aes256,{keySize:u}=Z(o.symmetric.aes256);return mn(c,await Nt(o.hash.sha512,a,new Uint8Array,yr.x448,u),r)}default:throw Error("Unsupported ECDH algorithm")}}function Cr(t){switch(t){case o.publicKey.x25519:return 32;case o.publicKey.x448:return 56;default:throw Error("Unsupported ECDH algorithm")}}async function xr(t,e){switch(t){case o.publicKey.x25519:try{const r=y.getWebCrypto(),n=await r.generateKey("X25519",!0,["deriveKey","deriveBits"]).catch((u=>{if(u.name==="OperationError"){const l=Error("Unexpected key generation issue");throw l.name="NotSupportedError",l}throw u})),i=await r.exportKey("jwk",n.publicKey);if((await r.exportKey("jwk",n.privateKey)).x!==i.x){const u=Error("Unexpected mismatching public point");throw u.name="NotSupportedError",u}const s=wn(t,e),a=await r.importKey("jwk",s,"X25519",!1,[]),c=await r.deriveBits({name:"X25519",public:a},n.privateKey,8*Cr(t));return{sharedSecret:new Uint8Array(c),ephemeralPublicKey:new Uint8Array(J(i.x))}}catch(r){if(r.name!=="NotSupportedError")throw r;const{default:n}=await ge(async()=>{const{default:c}=await import("./nacl-fast.min-qTGi1RRO.js");return{default:c}},[],import.meta.url),{secretKey:i,publicKey:s}=n.box.keyPair(),a=n.scalarMult(i,e);return pr(a),{ephemeralPublicKey:s,sharedSecret:a}}case o.publicKey.x448:{const r=await y.getNobleCurve(o.publicKey.x448),{secretKey:n,publicKey:i}=r.keygen(),s=r.getSharedSecret(n,e);return pr(s),{ephemeralPublicKey:i,sharedSecret:s}}default:throw Error("Unsupported ECDH algorithm")}}async function Tr(t,e,r,n){switch(t){case o.publicKey.x25519:try{const i=y.getWebCrypto(),s=(function(h,p,g){if(h===o.publicKey.x25519){const f=wn(h,p);return f.d=_(g),f}throw Error("Unsupported ECDH algorithm")})(t,r,n),a=wn(t,e),c=await i.importKey("jwk",s,"X25519",!1,["deriveKey","deriveBits"]),u=await i.importKey("jwk",a,"X25519",!1,[]),l=await i.deriveBits({name:"X25519",public:u},c,8*Cr(t));return new Uint8Array(l)}catch(i){if(i.name!=="NotSupportedError")throw i;const{default:s}=await ge(async()=>{const{default:c}=await import("./nacl-fast.min-qTGi1RRO.js");return{default:c}},[],import.meta.url),a=s.scalarMult(n,e);return pr(a),a}case o.publicKey.x448:{const i=(await y.getNobleCurve(o.publicKey.x448)).getSharedSecret(n,e);return pr(i),i}default:throw Error("Unsupported ECDH algorithm")}}function pr(t){let e=0;for(let r=0;r<t.length;r++)e|=t[r];if(e===0)throw Error("Unexpected low order point")}function wn(t,e){if(t===o.publicKey.x25519)return{kty:"OKP",crv:"X25519",x:_(e),ext:!0};throw Error("Unsupported ECDH algorithm")}var bc=Object.freeze({__proto__:null,decrypt:wc,encrypt:mc,generate:Wn,generateEphemeralEncryptionMaterial:xr,getPayloadSize:Cr,recomputeSharedSecret:Tr,validateParams:Vn});const jr=y.getWebCrypto(),fr=y.getNodeCrypto(),Pe={[o.curve.nistP256]:"P-256",[o.curve.nistP384]:"P-384",[o.curve.nistP521]:"P-521"},Ue=fr?fr.getCurves():[],ve=fr?{[o.curve.secp256k1]:Ue.includes("secp256k1")?"secp256k1":void 0,[o.curve.nistP256]:Ue.includes("prime256v1")?"prime256v1":void 0,[o.curve.nistP384]:Ue.includes("secp384r1")?"secp384r1":void 0,[o.curve.nistP521]:Ue.includes("secp521r1")?"secp521r1":void 0,[o.curve.ed25519Legacy]:Ue.includes("ED25519")?"ED25519":void 0,[o.curve.curve25519Legacy]:Ue.includes("X25519")?"X25519":void 0,[o.curve.brainpoolP256r1]:Ue.includes("brainpoolP256r1")?"brainpoolP256r1":void 0,[o.curve.brainpoolP384r1]:Ue.includes("brainpoolP384r1")?"brainpoolP384r1":void 0,[o.curve.brainpoolP512r1]:Ue.includes("brainpoolP512r1")?"brainpoolP512r1":void 0}:{},Js={[o.curve.nistP256]:{oid:[6,8,42,134,72,206,61,3,1,7],keyType:o.publicKey.ecdsa,hash:o.hash.sha256,cipher:o.symmetric.aes128,node:ve[o.curve.nistP256],web:Pe[o.curve.nistP256],payloadSize:32,sharedSize:256,wireFormatLeadingByte:4},[o.curve.nistP384]:{oid:[6,5,43,129,4,0,34],keyType:o.publicKey.ecdsa,hash:o.hash.sha384,cipher:o.symmetric.aes192,node:ve[o.curve.nistP384],web:Pe[o.curve.nistP384],payloadSize:48,sharedSize:384,wireFormatLeadingByte:4},[o.curve.nistP521]:{oid:[6,5,43,129,4,0,35],keyType:o.publicKey.ecdsa,hash:o.hash.sha512,cipher:o.symmetric.aes256,node:ve[o.curve.nistP521],web:Pe[o.curve.nistP521],payloadSize:66,sharedSize:528,wireFormatLeadingByte:4},[o.curve.secp256k1]:{oid:[6,5,43,129,4,0,10],keyType:o.publicKey.ecdsa,hash:o.hash.sha256,cipher:o.symmetric.aes128,node:ve[o.curve.secp256k1],payloadSize:32,wireFormatLeadingByte:4},[o.curve.ed25519Legacy]:{oid:[6,9,43,6,1,4,1,218,71,15,1],keyType:o.publicKey.eddsaLegacy,hash:o.hash.sha512,node:!1,payloadSize:32,wireFormatLeadingByte:64},[o.curve.curve25519Legacy]:{oid:[6,10,43,6,1,4,1,151,85,1,5,1],keyType:o.publicKey.ecdh,hash:o.hash.sha256,cipher:o.symmetric.aes128,node:!1,payloadSize:32,wireFormatLeadingByte:64},[o.curve.brainpoolP256r1]:{oid:[6,9,43,36,3,3,2,8,1,1,7],keyType:o.publicKey.ecdsa,hash:o.hash.sha256,cipher:o.symmetric.aes128,node:ve[o.curve.brainpoolP256r1],payloadSize:32,wireFormatLeadingByte:4},[o.curve.brainpoolP384r1]:{oid:[6,9,43,36,3,3,2,8,1,1,11],keyType:o.publicKey.ecdsa,hash:o.hash.sha384,cipher:o.symmetric.aes192,node:ve[o.curve.brainpoolP384r1],payloadSize:48,wireFormatLeadingByte:4},[o.curve.brainpoolP512r1]:{oid:[6,9,43,36,3,3,2,8,1,1,13],keyType:o.publicKey.ecdsa,hash:o.hash.sha512,cipher:o.symmetric.aes256,node:ve[o.curve.brainpoolP512r1],payloadSize:64,wireFormatLeadingByte:4}};class le{constructor(e){try{this.name=e instanceof Te?e.getName():o.write(o.curve,e)}catch{throw new O("Unknown curve")}const r=Js[this.name];this.keyType=r.keyType,this.oid=r.oid,this.hash=r.hash,this.cipher=r.cipher,this.node=r.node,this.web=r.web,this.payloadSize=r.payloadSize,this.sharedSize=r.sharedSize,this.wireFormatLeadingByte=r.wireFormatLeadingByte,this.web&&y.getWebCrypto()?this.type="web":this.node&&y.getNodeCrypto()?this.type="node":this.name===o.curve.curve25519Legacy?this.type="curve25519Legacy":this.name===o.curve.ed25519Legacy&&(this.type="ed25519Legacy")}async genKeyPair(){switch(this.type){case"web":try{return await(async function(e,r){const n=await jr.generateKey({name:"ECDSA",namedCurve:Pe[e]},!0,["sign","verify"]),i=await jr.exportKey("jwk",n.privateKey);return{publicKey:ta(await jr.exportKey("jwk",n.publicKey),r),privateKey:J(i.d)}})(this.name,this.wireFormatLeadingByte)}catch(e){return y.printDebugError("Browser did not support generating ec key "+e.message),Ci(this.name)}case"node":return(function(e){const r=fr.createECDH(ve[e]);return r.generateKeys(),{publicKey:new Uint8Array(r.getPublicKey()),privateKey:new Uint8Array(r.getPrivateKey())}})(this.name);case"curve25519Legacy":{const{k:e,A:r}=await Wn(o.publicKey.x25519),n=e.slice().reverse();return n[0]=127&n[0]|64,n[31]&=248,{publicKey:y.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]),r]),privateKey:n}}case"ed25519Legacy":{const{seed:e,A:r}=await On(o.publicKey.ed25519);return{publicKey:y.concatUint8Array([new Uint8Array([this.wireFormatLeadingByte]),r]),privateKey:e}}default:return Ci(this.name)}}}async function Jt(t){const e=new le(t),{oid:r,hash:n,cipher:i}=e,s=await e.genKeyPair();return{oid:r,Q:s.publicKey,secret:y.leftPad(s.privateKey,e.payloadSize),hash:n,cipher:i}}function Ys(t){return Js[t.getName()].hash}async function ea(t,e,r,n){const i={[o.curve.nistP256]:!0,[o.curve.nistP384]:!0,[o.curve.nistP521]:!0,[o.curve.secp256k1]:!0,[o.curve.curve25519Legacy]:t===o.publicKey.ecdh,[o.curve.brainpoolP256r1]:!0,[o.curve.brainpoolP384r1]:!0,[o.curve.brainpoolP512r1]:!0},s=e.getName();if(!i[s])return!1;if(s===o.curve.curve25519Legacy){const c=n.slice().reverse();return!(r.length<1||r[0]!==64)&&Vn(o.publicKey.x25519,r.subarray(1),c)}const a=(await y.getNobleCurve(o.publicKey.ecdsa,s)).getPublicKey(n,!1);return!!y.equalsUint8Array(a,r)}function et(t,e){const{payloadSize:r,wireFormatLeadingByte:n,name:i}=t,s=i===o.curve.curve25519Legacy||i===o.curve.ed25519Legacy?r:2*r;if(e[0]!==n||e.length!==s+1)throw Error("Invalid point encoding")}async function Ci(t){const e=await y.getNobleCurve(o.publicKey.ecdsa,t),{secretKey:r}=e.keygen();return{publicKey:e.getPublicKey(r,!1),privateKey:r}}function ta(t,e){const r=J(t.x),n=J(t.y),i=new Uint8Array(r.length+n.length+1);return i[0]=e,i.set(r,1),i.set(n,r.length+1),i}function Br(t,e,r){const n=t,i=r.slice(1,n+1),s=r.slice(n+1,2*n+1);return{kty:"EC",crv:e,x:_(i),y:_(s),ext:!0}}function ra(t,e,r,n){const i=Br(t,e,r);return i.d=_(n),i}const gr=y.getWebCrypto(),na=y.getNodeCrypto();async function bn(t,e,r,n,i,s){const a=new le(t);if(et(a,n),r&&!y.isStream(r)){const u={publicKey:n,privateKey:i};switch(a.type){case"web":try{return await(async function(l,h,p,g){const f=l.payloadSize,d=ra(l.payloadSize,Pe[l.name],g.publicKey,g.privateKey),m=await gr.importKey("jwk",d,{name:"ECDSA",namedCurve:Pe[l.name],hash:{name:o.read(o.webHash,l.hash)}},!1,["sign"]),w=new Uint8Array(await gr.sign({name:"ECDSA",namedCurve:Pe[l.name],hash:{name:o.read(o.webHash,h)}},m,p));return{r:w.slice(0,f),s:w.slice(f,f<<1)}})(a,e,r,u)}catch(l){if(a.name!=="nistP521"&&(l.name==="DataError"||l.name==="OperationError"))throw l;y.printDebugError("Browser did not support signing: "+l.message)}break;case"node":return(function(l,h,p,g){const f=y.nodeRequire("eckey-utils"),d=y.getNodeBuffer(),{privateKey:m}=f.generateDer({curveName:ve[l.name],privateKey:d.from(g)}),w=na.createSign(o.read(o.hash,h));w.write(p),w.end();const b=new Uint8Array(w.sign({key:m,format:"der",type:"sec1",dsaEncoding:"ieee-p1363"})),k=l.payloadSize;return{r:b.subarray(0,k),s:b.subarray(k,k<<1)}})(a,e,r,i)}}const c=(await y.getNobleCurve(o.publicKey.ecdsa,a.name)).sign(s,i,{lowS:!1});return{r:q(c.r,"be",a.payloadSize),s:q(c.s,"be",a.payloadSize)}}async function kn(t,e,r,n,i,s){const a=new le(t);et(a,i);const c=async()=>s[0]===0&&xi(a,r,s.subarray(1),i);if(n&&!y.isStream(n))switch(a.type){case"web":try{return await(async function(l,h,{r:p,s:g},f,d){const m=Br(l.payloadSize,Pe[l.name],d),w=await gr.importKey("jwk",m,{name:"ECDSA",namedCurve:Pe[l.name],hash:{name:o.read(o.webHash,l.hash)}},!1,["verify"]),b=y.concatUint8Array([p,g]).buffer;return gr.verify({name:"ECDSA",namedCurve:Pe[l.name],hash:{name:o.read(o.webHash,h)}},w,b,f)})(a,e,r,n,i)||c()}catch(u){if(a.name!=="nistP521"&&(u.name==="DataError"||u.name==="OperationError"))throw u;y.printDebugError("Browser did not support verifying: "+u.message)}break;case"node":return(function(l,h,{r:p,s:g},f,d){const m=y.nodeRequire("eckey-utils"),w=y.getNodeBuffer(),{publicKey:b}=m.generateDer({curveName:ve[l.name],publicKey:w.from(d)}),k=na.createVerify(o.read(o.hash,h));k.write(f),k.end();const v=y.concatUint8Array([p,g]);try{return k.verify({key:b,format:"der",type:"spki",dsaEncoding:"ieee-p1363"},v)}catch{return!1}})(a,e,r,n,i)||c()}return await xi(a,r,s,i)||c()}async function xi(t,e,r,n){return(await y.getNobleCurve(o.publicKey.ecdsa,t.name)).verify(y.concatUint8Array([e.r,e.s]),r,n,{lowS:!1})}var kc=Object.freeze({__proto__:null,sign:bn,validateParams:async function(t,e,r){const n=new le(t);if(n.keyType!==o.publicKey.ecdsa)return!1;switch(n.type){case"web":case"node":{const i=ye(8),s=o.hash.sha256,a=await je(s,i);try{const c=await bn(t,s,i,e,r,a);return await kn(t,s,c,i,e,a)}catch{return!1}}default:return ea(o.publicKey.ecdsa,t,e,r)}},verify:kn});async function ia(t,e,r,n,i,s){if(et(new le(t),n),H(e)<H(o.hash.sha256))throw Error("Hash algorithm too weak for EdDSA.");const{RS:a}=await Nn(o.publicKey.ed25519,e,0,n.subarray(1),i,s);return{r:a.subarray(0,32),s:a.subarray(32)}}async function sa(t,e,{r,s:n},i,s,a){if(et(new le(t),s),H(e)<H(o.hash.sha256))throw Error("Hash algorithm too weak for EdDSA.");const c=y.concatUint8Array([r,n]);return Mn(o.publicKey.ed25519,e,{RS:c},0,s.subarray(1),a)}async function aa(t,e,r){return t.getName()===o.curve.ed25519Legacy&&!(e.length<1||e[0]!==64)&&Hn(o.publicKey.ed25519,e.subarray(1),r)}var vc=Object.freeze({__proto__:null,sign:ia,validateParams:aa,verify:sa});function Ac(t){const e=t.length;if(e>0){const r=t[e-1];if(r>=1){const n=t.subarray(e-r),i=new Uint8Array(r).fill(r);if(y.equalsUint8Array(n,i))return t.subarray(0,e-r)}}throw Error("Invalid padding")}function oa(t,e,r,n){return y.concatUint8Array([e.write(),new Uint8Array([t]),r.write(),y.stringToUint8Array("Anonymous Sender    "),n])}async function ca(t,e,r,n,i=!1,s=!1){let a;if(i){for(a=0;a<e.length&&e[a]===0;a++);e=e.subarray(a)}if(s){for(a=e.length-1;a>=0&&e[a]===0;a--);e=e.subarray(0,a+1)}return(await je(t,y.concatUint8Array([new Uint8Array([0,0,0,1]),e,n]))).subarray(0,r)}async function Ec(t,e){switch(t.type){case"curve25519Legacy":{const{sharedSecret:r,ephemeralPublicKey:n}=await xr(o.publicKey.x25519,e.subarray(1));return{publicKey:y.concatUint8Array([new Uint8Array([t.wireFormatLeadingByte]),n]),sharedKey:r}}case"web":if(t.web&&y.getWebCrypto())try{return await(async function(r,n){const i=y.getWebCrypto(),s=Br(r.payloadSize,r.web,n);let a=i.generateKey({name:"ECDH",namedCurve:r.web},!0,["deriveKey","deriveBits"]),c=i.importKey("jwk",s,{name:"ECDH",namedCurve:r.web},!1,[]);[a,c]=await Promise.all([a,c]);let u=i.deriveBits({name:"ECDH",namedCurve:r.web,public:c},a.privateKey,r.sharedSize),l=i.exportKey("jwk",a.publicKey);[u,l]=await Promise.all([u,l]);const h=new Uint8Array(u);return{publicKey:new Uint8Array(ta(l,r.wireFormatLeadingByte)),sharedKey:h}})(t,e)}catch(r){return y.printDebugError(r),Bi(t,e)}break;case"node":return(function(r,n){const i=y.getNodeCrypto(),s=i.createECDH(r.node);s.generateKeys();const a=new Uint8Array(s.computeSecret(n));return{publicKey:new Uint8Array(s.getPublicKey()),sharedKey:a}})(t,e);default:return Bi(t,e)}}async function Sc(t,e,r,n,i){const s=(function(g){const f=8-g.length%8,d=new Uint8Array(g.length+f).fill(f);return d.set(g),d})(r),a=new le(t);et(a,n);const{publicKey:c,sharedKey:u}=await Ec(a,n),l=oa(o.publicKey.ecdh,t,e,i),{keySize:h}=Z(e.cipher),p=await ca(e.hash,u,h,l);return{publicKey:c,wrappedKey:await dn(e.cipher,p,s)}}async function Pc(t,e,r,n){if(n.length!==t.payloadSize){const i=new Uint8Array(t.payloadSize);i.set(n,t.payloadSize-n.length),n=i}switch(t.type){case"curve25519Legacy":{const i=n.slice().reverse();return{secretKey:i,sharedKey:await Tr(o.publicKey.x25519,e.subarray(1),r.subarray(1),i)}}case"web":if(t.web&&y.getWebCrypto())try{return await(async function(i,s,a,c){const u=y.getWebCrypto(),l=ra(i.payloadSize,i.web,a,c);let h=u.importKey("jwk",l,{name:"ECDH",namedCurve:i.web},!0,["deriveKey","deriveBits"]);const p=Br(i.payloadSize,i.web,s);let g=u.importKey("jwk",p,{name:"ECDH",namedCurve:i.web},!0,[]);[h,g]=await Promise.all([h,g]);let f=u.deriveBits({name:"ECDH",namedCurve:i.web,public:g},h,i.sharedSize),d=u.exportKey("jwk",h);[f,d]=await Promise.all([f,d]);const m=new Uint8Array(f);return{secretKey:J(d.d),sharedKey:m}})(t,e,r,n)}catch(i){return y.printDebugError(i),Ti(t,e,n)}break;case"node":return(function(i,s,a){const c=y.getNodeCrypto(),u=c.createECDH(i.node);u.setPrivateKey(a);const l=new Uint8Array(u.computeSecret(s));return{secretKey:new Uint8Array(u.getPrivateKey()),sharedKey:l}})(t,e,n);default:return Ti(t,e,n)}}async function Kc(t,e,r,n,i,s,a){const c=new le(t);et(c,i),et(c,r);const{sharedKey:u}=await Pc(c,r,i,s),l=oa(o.publicKey.ecdh,t,e,a),{keySize:h}=Z(e.cipher);let p;for(let g=0;g<3;g++)try{const f=await ca(e.hash,u,h,l,g===1,g===2);return Ac(await mn(e.cipher,f,n))}catch(f){p=f}throw p}async function Ti(t,e,r){return{secretKey:r,sharedKey:(await y.getNobleCurve(o.publicKey.ecdh,t.name)).getSharedSecret(r,e).subarray(1)}}async function Bi(t,e){const r=await y.getNobleCurve(o.publicKey.ecdh,t.name),{publicKey:n,privateKey:i}=await t.genKeyPair();return{publicKey:n,sharedKey:r.getSharedSecret(i,e).subarray(1)}}var Uc=Object.freeze({__proto__:null,CurveWithOID:le,ecdh:Object.freeze({__proto__:null,decrypt:Kc,encrypt:Sc,validateParams:async function(t,e,r){return ea(o.publicKey.ecdh,t,e,r)}}),ecdhX:bc,ecdsa:kc,eddsa:cc,eddsaLegacy:vc,generate:Jt,getPreferredHashAlgo:Ys});const Yt=BigInt(0),It=BigInt(1);class ua{constructor(e){if(e){const{hash:r,cipher:n}=e;this.hash=r,this.cipher=n}else this.hash=null,this.cipher=null}read(e){if(e.length<4||e[0]!==3||e[1]!==1)throw new O("Cannot read KDFParams");return this.hash=e[2],this.cipher=e[3],4}write(){return new Uint8Array([3,1,this.hash,this.cipher])}}function Li(t,e,r){let n=0;switch(t){case o.publicKey.rsaEncrypt:case o.publicKey.rsaEncryptSign:case o.publicKey.rsaSign:{const i=y.readMPI(e.subarray(n));n+=i.length+2;const s=y.readMPI(e.subarray(n));n+=s.length+2;const a=y.readMPI(e.subarray(n));n+=a.length+2;const c=y.readMPI(e.subarray(n));return n+=c.length+2,{read:n,privateParams:{d:i,p:s,q:a,u:c}}}case o.publicKey.dsa:case o.publicKey.elgamal:{const i=y.readMPI(e.subarray(n));return n+=i.length+2,{read:n,privateParams:{x:i}}}case o.publicKey.ecdsa:case o.publicKey.ecdh:{const i=Ct(t,r.oid);let s=y.readMPI(e.subarray(n));return n+=s.length+2,s=y.leftPad(s,i),{read:n,privateParams:{d:s}}}case o.publicKey.eddsaLegacy:{const i=Ct(t,r.oid);if(r.oid.getName()!==o.curve.ed25519Legacy)throw Error("Unexpected OID for eddsaLegacy");let s=y.readMPI(e.subarray(n));return n+=s.length+2,s=y.leftPad(s,i),{read:n,privateParams:{seed:s}}}case o.publicKey.ed25519:case o.publicKey.ed448:{const i=Ct(t),s=y.readExactSubarray(e,n,n+i);return n+=s.length,{read:n,privateParams:{seed:s}}}case o.publicKey.x25519:case o.publicKey.x448:{const i=Ct(t),s=y.readExactSubarray(e,n,n+i);return n+=s.length,{read:n,privateParams:{k:s}}}default:throw new O("Unknown public key encryption algorithm.")}}function Mt(t,e){const r=new Set([o.publicKey.ed25519,o.publicKey.x25519,o.publicKey.ed448,o.publicKey.x448]),n=Object.keys(e).map((i=>{const s=e[i];return y.isUint8Array(s)?r.has(t)?s:y.uint8ArrayToMPI(s):s.write()}));return y.concatUint8Array(n)}function Dc(t,e,r){switch(t){case o.publicKey.rsaEncrypt:case o.publicKey.rsaEncryptSign:case o.publicKey.rsaSign:return(async function(n,i){if(i=BigInt(i),y.getWebCrypto()){const l={name:"RSASSA-PKCS1-v1_5",modulusLength:n,publicExponent:q(i),hash:{name:"SHA-1"}},h=await mt.generateKey(l,!0,["sign","verify"]);return Ei(await mt.exportKey("jwk",h.privateKey),i)}if(y.getNodeCrypto()){const l={modulusLength:n,publicExponent:ln(i),publicKeyEncoding:{type:"pkcs1",format:"jwk"},privateKeyEncoding:{type:"pkcs1",format:"jwk"}},h=await new Promise(((p,g)=>{Rn.generateKeyPair("rsa",l,((f,d,m)=>{f?g(f):p(m)}))}));return Ei(h,i)}let s,a,c;do a=bi(n-(n>>1),i,40),s=bi(n>>1,i,40),c=s*a;while(lt(c)!==n);const u=(s-wt)*(a-wt);return a<s&&([s,a]=[a,s]),{n:q(c),e:q(i),d:q(cr(i,u)),p:q(s),q:q(a),u:q(cr(s,a))}})(e,65537).then((({n,e:i,d:s,p:a,q:c,u})=>({privateParams:{d:s,p:a,q:c,u},publicParams:{n,e:i}})));case o.publicKey.ecdsa:return Jt(r).then((({oid:n,Q:i,secret:s})=>({privateParams:{d:s},publicParams:{oid:new Te(n),Q:i}})));case o.publicKey.eddsaLegacy:return Jt(r).then((({oid:n,Q:i,secret:s})=>({privateParams:{seed:s},publicParams:{oid:new Te(n),Q:i}})));case o.publicKey.ecdh:return Jt(r).then((({oid:n,Q:i,secret:s,hash:a,cipher:c})=>({privateParams:{d:s},publicParams:{oid:new Te(n),Q:i,kdfParams:new ua({hash:a,cipher:c})}})));case o.publicKey.ed25519:case o.publicKey.ed448:return On(t).then((({A:n,seed:i})=>({privateParams:{seed:i},publicParams:{A:n}})));case o.publicKey.x25519:case o.publicKey.x448:return Wn(t).then((({A:n,k:i})=>({privateParams:{k:i},publicParams:{A:n}})));case o.publicKey.dsa:case o.publicKey.elgamal:throw Error("Unsupported algorithm for key generation.");default:throw Error("Unknown public key algorithm.")}}async function Ic(t,e,r){if(!e||!r)throw Error("Missing key parameters");switch(t){case o.publicKey.rsaEncrypt:case o.publicKey.rsaEncryptSign:case o.publicKey.rsaSign:{const{n,e:i}=e,{d:s,p:a,q:c,u}=r;return(async function(l,h,p,g,f,d){if(l=K(l),(g=K(g))*(f=K(f))!==l)return!1;const m=BigInt(2);if(T(g*(d=K(d)),f)!==BigInt(1))return!1;h=K(h),p=K(p);const w=ht(m,m<<BigInt(Math.floor(lt(l)/3))),b=w*p*h;return!(T(b,g-wt)!==w||T(b,f-wt)!==w)})(n,i,s,a,c,u)}case o.publicKey.dsa:{const{p:n,q:i,g:s,y:a}=e,{x:c}=r;return(async function(u,l,h,p,g){const f=K(u),d=K(l),m=K(h),w=K(p);if(m<=It||m>=f||T(f-It,d)!==Yt||he(m,d,f)!==It)return!1;const b=BigInt(lt(d));if(b<BigInt(150)||!Bs(d,null,32))return!1;const k=K(g),v=BigInt(2);return w===he(m,d*ht(v<<b-It,v<<b)+k,f)})(n,i,s,a,c)}case o.publicKey.elgamal:{const{p:n,g:i,y:s}=e,{x:a}=r;return(async function(c,u,l,h){const p=K(c),g=K(u),f=K(l);if(g<=it||g>=p)return!1;const d=BigInt(lt(p));if(d<BigInt(1023)||he(g,p-it,p)!==it)return!1;let m=g,w=BigInt(1);const b=BigInt(2),k=b<<BigInt(17);for(;w<k;){if(m=T(m*g,p),m===it)return!1;w++}const v=K(h),A=ht(b<<d-it,b<<d);return f===he(g,(p-it)*A+v,p)})(n,i,s,a)}case o.publicKey.ecdsa:case o.publicKey.ecdh:{const n=Uc[o.read(o.publicKey,t)],{oid:i,Q:s}=e,{d:a}=r;return n.validateParams(i,s,a)}case o.publicKey.eddsaLegacy:{const{Q:n,oid:i}=e,{seed:s}=r;return aa(i,n,s)}case o.publicKey.ed25519:case o.publicKey.ed448:{const{A:n}=e,{seed:i}=r;return Hn(t,n,i)}case o.publicKey.x25519:case o.publicKey.x448:{const{A:n}=e,{k:i}=r;return Vn(t,n,i)}default:throw Error("Unknown public key algorithm.")}}function Gr(t){try{t.getName()}catch{throw new O("Unknown curve OID")}}function Ct(t,e){switch(t){case o.publicKey.ecdsa:case o.publicKey.ecdh:case o.publicKey.eddsaLegacy:return new le(e).payloadSize;case o.publicKey.ed25519:case o.publicKey.ed448:return Kr(t);case o.publicKey.x25519:case o.publicKey.x448:return Cr(t);default:throw Error("Unknown elliptic algo")}}const er=y.getWebCrypto(),Ht=y.getNodeCrypto(),Ve=Ht?Ht.getCiphers():[],dr={idea:Ve.includes("idea-cfb")?"idea-cfb":void 0,tripledes:Ve.includes("des-ede3-cfb")?"des-ede3-cfb":void 0,cast5:Ve.includes("cast5-cfb")?"cast5-cfb":void 0,blowfish:Ve.includes("bf-cfb")?"bf-cfb":void 0,aes128:Ve.includes("aes-128-cfb")?"aes-128-cfb":void 0,aes192:Ve.includes("aes-192-cfb")?"aes-192-cfb":void 0,aes256:Ve.includes("aes-256-cfb")?"aes-256-cfb":void 0};async function Cc(t,e,r,n,i){const s=o.read(o.symmetric,t);if(y.getNodeCrypto()&&dr[s])return(function(p,g,f,d){const m=o.read(o.symmetric,p),w=new Ht.createCipheriv(dr[m],g,d);return $(f,(b=>new Uint8Array(w.update(b))))})(t,e,r,n);if(y.isAES(t))return(async function(p,g,f,d){if(er&&await Fi.isSupported(p)){const m=new Fi(p,g,d);return y.isStream(f)?un(f,(w=>m.encryptChunk(w)),(()=>m.finish())):m.encrypt(f)}if(y.isStream(f)){const m=new la(!0,p,g,d);return un(f,(w=>m.processChunk(w)),(()=>m.finish()))}return qs(g,d).encrypt(f)})(t,e,r,n);const a=new(await Xs(t))(e),c=a.blockSize,u=n.slice();let l=new Uint8Array;const h=p=>{p&&(l=y.concatUint8Array([l,p]));const g=new Uint8Array(l.length);let f,d=0;for(;p?l.length>=c:l.length;){const m=a.encrypt(u);for(f=0;f<c;f++)u[f]=l[f]^m[f],g[d++]=u[f];l=l.subarray(c)}return g.subarray(0,d)};return $(r,h,h)}async function xc(t,e,r,n){const i=o.read(o.symmetric,t);if(Ht&&dr[i])return(function(h,p,g,f){const d=o.read(o.symmetric,h),m=new Ht.createDecipheriv(dr[d],p,f);return $(g,(w=>new Uint8Array(m.update(w))))})(t,e,r,n);if(y.isAES(t))return(function(h,p,g,f){if(y.isStream(g)){const d=new la(!1,h,p,f);return un(g,(m=>d.processChunk(m)),(()=>d.finish()))}return qs(p,f).decrypt(g)})(t,e,r,n);const s=new(await Xs(t))(e),a=s.blockSize;let c=n,u=new Uint8Array;const l=h=>{h&&(u=y.concatUint8Array([u,h]));const p=new Uint8Array(u.length);let g,f=0;for(;h?u.length>=a:u.length;){const d=s.encrypt(c);for(c=u.subarray(0,a),g=0;g<a;g++)p[f++]=c[g]^d[g];u=u.subarray(a)}return p.subarray(0,f)};return $(r,l,l)}class Fi{constructor(e,r,n){const{blockSize:i}=Z(e);this.key=r,this.prevBlock=n,this.nextBlock=new Uint8Array(i),this.i=0,this.blockSize=i,this.zeroBlock=new Uint8Array(this.blockSize)}static isSupported(e){const{keySize:r}=Z(e);return er.importKey("raw",new Uint8Array(r),"aes-cbc",!1,["encrypt"]).then((()=>!0),(()=>!1))}async _runCBC(e,r){const n="AES-CBC";this.keyRef=this.keyRef||await er.importKey("raw",this.key,n,!1,["encrypt"]);const i=await er.encrypt({name:n,iv:r||this.zeroBlock},this.keyRef,e);return new Uint8Array(i).subarray(0,e.length)}async encryptChunk(e){const r=this.nextBlock.length-this.i,n=e.subarray(0,r);if(this.nextBlock.set(n,this.i),this.i+e.length>=2*this.blockSize){const s=(e.length-r)%this.blockSize,a=y.concatUint8Array([this.nextBlock,e.subarray(r,e.length-s)]),c=y.concatUint8Array([this.prevBlock,a.subarray(0,a.length-this.blockSize)]),u=await this._runCBC(c);return qt(u,a),this.prevBlock=u.slice(-this.blockSize),s>0&&this.nextBlock.set(e.subarray(-s)),this.i=s,u}let i;if(this.i+=n.length,this.i===this.nextBlock.length){const s=this.nextBlock;i=await this._runCBC(this.prevBlock),qt(i,s),this.prevBlock=i.slice(),this.i=0;const a=e.subarray(n.length);this.nextBlock.set(a,this.i),this.i+=a.length}else i=new Uint8Array;return i}async finish(){let e;if(this.i===0)e=new Uint8Array;else{this.nextBlock=this.nextBlock.subarray(0,this.i);const r=this.nextBlock,n=await this._runCBC(this.prevBlock);qt(n,r),e=n.subarray(0,r.length)}return this.clearSensitiveData(),e}clearSensitiveData(){this.nextBlock.fill(0),this.prevBlock.fill(0),this.keyRef=null,this.key=null}async encrypt(e){const r=(await this._runCBC(y.concatUint8Array([new Uint8Array(this.blockSize),e]),this.iv)).subarray(0,e.length);return qt(r,e),this.clearSensitiveData(),r}}class la{constructor(e,r,n,i){this.forEncryption=e;const{blockSize:s}=Z(r);this.key=Ii.expandKeyLE(n),i.byteOffset%4!=0&&(i=i.slice()),this.prevBlock=qr(i),this.nextBlock=new Uint8Array(s),this.i=0,this.blockSize=s}_runCFB(e){const r=qr(e),n=new Uint8Array(e.length),i=qr(n);for(let s=0;s+4<=i.length;s+=4){const{s0:a,s1:c,s2:u,s3:l}=Ii.encrypt(this.key,this.prevBlock[0],this.prevBlock[1],this.prevBlock[2],this.prevBlock[3]);i[s+0]=r[s+0]^a,i[s+1]=r[s+1]^c,i[s+2]=r[s+2]^u,i[s+3]=r[s+3]^l,this.prevBlock=(this.forEncryption?i:r).slice(s,s+4)}return n}async processChunk(e){const r=this.nextBlock.length-this.i,n=e.subarray(0,r);if(this.nextBlock.set(n,this.i),this.i+e.length>=2*this.blockSize){const s=(e.length-r)%this.blockSize,a=y.concatUint8Array([this.nextBlock,e.subarray(r,e.length-s)]),c=this._runCFB(a);return s>0&&this.nextBlock.set(e.subarray(-s)),this.i=s,c}let i;if(this.i+=n.length,this.i===this.nextBlock.length){i=this._runCFB(this.nextBlock),this.i=0;const s=e.subarray(n.length);this.nextBlock.set(s,this.i),this.i+=s.length}else i=new Uint8Array;return i}async finish(){let e;return this.i===0?e=new Uint8Array:e=this._runCFB(this.nextBlock).subarray(0,this.i),this.clearSensitiveData(),e}clearSensitiveData(){this.nextBlock.fill(0),this.prevBlock.fill(0),this.key.fill(0)}}function qt(t,e){const r=Math.min(t.length,e.length);for(let n=0;n<r;n++)t[n]=t[n]^e[n]}const qr=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),Ri=y.getWebCrypto(),Tc=y.getNodeCrypto(),Je=16;function Oi(t,e){const r=t.length-Je;for(let n=0;n<Je;n++)t[n+r]^=e[n];return t}const tr=new Uint8Array(Je);async function Bc(t){const e=await Lc(t),r=y.double(await e(tr)),n=y.double(r);return async function(i){return(await e((function(s,a,c){if(s.length&&s.length%Je==0)return Oi(s,a);const u=new Uint8Array(s.length+(Je-s.length%Je));return u.set(s),u[s.length]=128,Oi(u,c)})(i,r,n))).subarray(-16)}}async function Lc(t){if(y.getNodeCrypto())return async function(e){const r=new Tc.createCipheriv("aes-"+8*t.length+"-cbc",t,tr).update(e);return new Uint8Array(r)};if(y.getWebCrypto())try{return t=await Ri.importKey("raw",t,{name:"AES-CBC",length:8*t.length},!1,["encrypt"]),async function(e){const r=await Ri.encrypt({name:"AES-CBC",iv:tr,length:128},t,e);return new Uint8Array(r).subarray(0,r.byteLength-Je)}}catch(e){if(e.name!=="NotSupportedError"&&(t.length!==24||e.name!=="OperationError"))throw e;y.printDebugError("Browser did not support operation: "+e.message)}return async function(e){return gn(t,tr,{disablePadding:!0}).encrypt(e)}}const Ni=y.getWebCrypto(),Fc=y.getNodeCrypto(),Rc=y.getNodeBuffer(),zt=16,rr=zt,Mi=new Uint8Array(zt),vn=new Uint8Array(zt);vn[15]=1;const An=new Uint8Array(zt);async function Oc(t){const e=await Bc(t);return function(r,n){return e(y.concatUint8Array([r,n]))}}async function Nc(t){if(y.getNodeCrypto())return async function(e,r){const n=new Fc.createCipheriv("aes-"+8*t.length+"-ctr",t,r),i=Rc.concat([n.update(e),n.final()]);return new Uint8Array(i)};if(y.getWebCrypto())try{const e=await Ni.importKey("raw",t,{name:"AES-CTR",length:8*t.length},!1,["encrypt"]);return async function(r,n){const i=await Ni.encrypt({name:"AES-CTR",counter:n,length:128},e,r);return new Uint8Array(i)}}catch(e){if(e.name!=="NotSupportedError"&&(t.length!==24||e.name!=="OperationError"))throw e;y.printDebugError("Browser did not support operation: "+e.message)}return async function(e,r){return pc(t,r).encrypt(e)}}async function xt(t,e){if(t!==o.symmetric.aes128&&t!==o.symmetric.aes192&&t!==o.symmetric.aes256)throw Error("EAX mode supports only AES cipher");const[r,n]=await Promise.all([Oc(e),Nc(e)]);return{encrypt:async function(i,s,a){const[c,u]=await Promise.all([r(Mi,s),r(vn,a)]),l=await n(i,c),h=await r(An,l);for(let p=0;p<rr;p++)h[p]^=u[p]^c[p];return y.concatUint8Array([l,h])},decrypt:async function(i,s,a){if(i.length<rr)throw Error("Invalid EAX ciphertext");const c=i.subarray(0,-16),u=i.subarray(-16),[l,h,p]=await Promise.all([r(Mi,s),r(vn,a),r(An,c)]),g=p;for(let f=0;f<rr;f++)g[f]^=h[f]^l[f];if(!y.equalsUint8Array(u,g))throw Error("Authentication tag mismatch");return await n(c,l)}}}An[15]=2,xt.getNonce=function(t,e){const r=t.slice();for(let n=0;n<e.length;n++)r[8+n]^=e[n];return r},xt.blockLength=zt,xt.ivLength=16,xt.tagLength=rr;const te=16,En=16;function Hi(t){let e=0;for(let r=1;!(t&r);r<<=1)e++;return e}function X(t,e){for(let r=0;r<t.length;r++)t[r]^=e[r];return t}function Wt(t,e){return X(t.slice(),e)}const Et=new Uint8Array(te),Mc=new Uint8Array([1]);async function Tt(t,e){const{keySize:r}=Z(t);if(!y.isAES(t)||e.length!==r)throw Error("Unexpected algorithm or key size");let n=0;const i=u=>gn(e,Et,{disablePadding:!0}).encrypt(u),s=u=>gn(e,Et,{disablePadding:!0}).decrypt(u);let a;function c(u,l,h,p){const g=l.length/te|0;(function(S,I){const x=y.nbits(Math.max(S.length,I.length)/te|0)-1;for(let U=n+1;U<=x;U++)a[U]=y.double(a[U-1]);n=x})(l,p);const f=y.concatUint8Array([Et.subarray(0,15-h.length),Mc,h]),d=63&f[15];f[15]&=192;const m=i(f),w=y.concatUint8Array([m,Wt(m.subarray(0,8),m.subarray(1,9))]),b=y.shiftRight(w.subarray(0+(d>>3),17+(d>>3)),8-(7&d)).subarray(1),k=new Uint8Array(te),v=new Uint8Array(l.length+En);let A,E=0;for(A=0;A<g;A++)X(b,a[Hi(A+1)]),v.set(X(u(Wt(b,l)),b),E),X(k,u===i?l:v.subarray(E)),l=l.subarray(te),E+=te;if(l.length){X(b,a.x);const S=i(b);v.set(Wt(l,S),E);const I=new Uint8Array(te);I.set(u===i?l:v.subarray(E,-16),0),I[l.length]=128,X(k,I),E+=l.length}const D=X(i(X(X(k,b),a.$)),(function(S){if(!S.length)return Et;const I=S.length/te|0,x=new Uint8Array(te),U=new Uint8Array(te);for(let C=0;C<I;C++)X(x,a[Hi(C+1)]),X(U,i(Wt(x,S))),S=S.subarray(te);if(S.length){X(x,a.x);const C=new Uint8Array(te);C.set(S,0),C[S.length]=128,X(C,x),X(U,i(C))}return U})(p));return v.set(D,E),v}return(function(){const u=i(Et),l=y.double(u);a=[],a[0]=y.double(l),a.x=u,a.$=l})(),{encrypt:async function(u,l,h){return c(i,u,l,h)},decrypt:async function(u,l,h){if(u.length<En)throw Error("Invalid OCB ciphertext");const p=u.subarray(-16);u=u.subarray(0,-16);const g=c(s,u,l,h);if(y.equalsUint8Array(p,g.subarray(-16)))return g.subarray(0,-16);throw Error("Authentication tag mismatch")}}}Tt.getNonce=function(t,e){const r=t.slice();for(let n=0;n<e.length;n++)r[7+n]^=e[n];return r},Tt.blockLength=te,Tt.ivLength=15,Tt.tagLength=En;const Wr=y.getWebCrypto(),$i=y.getNodeCrypto(),zi=y.getNodeBuffer(),nr=16,Vr="AES-GCM";async function ot(t,e){if(t!==o.symmetric.aes128&&t!==o.symmetric.aes192&&t!==o.symmetric.aes256)throw Error("GCM mode supports only AES cipher");if(y.getNodeCrypto())return{encrypt:async function(r,n,i=new Uint8Array){const s=new $i.createCipheriv("aes-"+8*e.length+"-gcm",e,n);s.setAAD(i);const a=zi.concat([s.update(r),s.final(),s.getAuthTag()]);return new Uint8Array(a)},decrypt:async function(r,n,i=new Uint8Array){const s=new $i.createDecipheriv("aes-"+8*e.length+"-gcm",e,n);s.setAAD(i),s.setAuthTag(r.slice(r.length-nr,r.length));const a=zi.concat([s.update(r.slice(0,r.length-nr)),s.final()]);return new Uint8Array(a)}};if(y.getWebCrypto())try{const r=await Wr.importKey("raw",e,{name:Vr},!1,["encrypt","decrypt"]),n=navigator.userAgent.match(/Version\/13\.\d(\.\d)* Safari/)||navigator.userAgent.match(/Version\/(13|14)\.\d(\.\d)* Mobile\/\S* Safari/);return{encrypt:async function(i,s,a=new Uint8Array){if(n&&!i.length)return Gt(e,s,a).encrypt(i);const c=await Wr.encrypt({name:Vr,iv:s,additionalData:a,tagLength:128},r,i);return new Uint8Array(c)},decrypt:async function(i,s,a=new Uint8Array){if(n&&i.length===nr)return Gt(e,s,a).decrypt(i);try{const c=await Wr.decrypt({name:Vr,iv:s,additionalData:a,tagLength:128},r,i);return new Uint8Array(c)}catch(c){if(c.name==="OperationError")throw Error("Authentication tag mismatch")}}}}catch(r){if(r.name!=="NotSupportedError"&&(e.length!==24||r.name!=="OperationError"))throw r;y.printDebugError("Browser did not support operation: "+r.message)}return{encrypt:async function(r,n,i){return Gt(e,n,i).encrypt(r)},decrypt:async function(r,n,i){return Gt(e,n,i).decrypt(r)}}}function Qr(t,e=!1){switch(t){case o.aead.eax:return xt;case o.aead.ocb:return Tt;case o.aead.gcm:return ot;case o.aead.experimentalGCM:if(!e)throw Error("Unexpected non-standard `experimentalGCM` AEAD algorithm provided in `config.preferredAEADAlgorithm`: use `gcm` instead");return ot;default:throw Error("Unsupported AEAD mode")}}async function Hc(t,e,r,n,i,s){switch(t){case o.publicKey.rsaEncryptSign:case o.publicKey.rsaEncrypt:case o.publicKey.rsaSign:{const{n:a,e:c}=n;return ic(e,i,y.leftPad(r.s,a.length),a,c,s)}case o.publicKey.dsa:{const{g:a,p:c,q:u,y:l}=n,{r:h,s:p}=r;return(async function(g,f,d,m,w,b,k,v){if(f=K(f),d=K(d),b=K(b),k=K(k),w=K(w),v=K(v),f<=Yt||f>=k||d<=Yt||d>=k)return y.printDebug("invalid DSA Signature"),!1;const A=T(K(m.subarray(0,xe(k))),k),E=cr(d,k);if(E===Yt)return y.printDebug("invalid DSA Signature"),!1;w=T(w,b),v=T(v,b);const D=T(A*E,k),S=T(f*E,k);return T(T(he(w,D,b)*he(v,S,b),b),k)===f})(0,h,p,s,a,c,u,l)}case o.publicKey.ecdsa:{const{oid:a,Q:c}=n,u=new le(a).payloadSize;return kn(a,e,{r:y.leftPad(r.r,u),s:y.leftPad(r.s,u)},i,c,s)}case o.publicKey.eddsaLegacy:{const{oid:a,Q:c}=n,u=new le(a).payloadSize;return sa(a,e,{r:y.leftPad(r.r,u),s:y.leftPad(r.s,u)},0,c,s)}case o.publicKey.ed25519:case o.publicKey.ed448:{const{A:a}=n;return Mn(t,e,r,0,a,s)}default:throw Error("Unknown signature algorithm.")}}async function $c(t,e,r,n,i,s){if(!r||!n)throw Error("Missing key parameters");switch(t){case o.publicKey.rsaEncryptSign:case o.publicKey.rsaEncrypt:case o.publicKey.rsaSign:{const{n:a,e:c}=r,{d:u,p:l,q:h,u:p}=n;return{s:await nc(e,i,a,c,u,l,h,p,s)}}case o.publicKey.dsa:{const{g:a,p:c,q:u}=r,{x:l}=n;return(async function(h,p,g,f,d,m){const w=BigInt(0);let b,k,v,A;f=K(f),d=K(d),g=K(g),m=K(m),g=T(g,f),m=T(m,d);const E=T(K(p.subarray(0,xe(d))),d);for(;;){if(b=ht(It,d),k=T(he(g,b,f),d),k===w)continue;const D=T(m*k,d);if(A=T(E+D,d),v=T(cr(b,d)*A,d),v!==w)break}return{r:q(k,"be",xe(f)),s:q(v,"be",xe(f))}})(0,s,a,c,u,l)}case o.publicKey.elgamal:throw Error("Signing with Elgamal is not defined in the OpenPGP standard.");case o.publicKey.ecdsa:{const{oid:a,Q:c}=r,{d:u}=n;return bn(a,e,i,c,u,s)}case o.publicKey.eddsaLegacy:{const{oid:a,Q:c}=r,{seed:u}=n;return ia(a,e,0,c,u,s)}case o.publicKey.ed25519:case o.publicKey.ed448:{const{A:a}=r,{seed:c}=n;return Nn(t,e,0,a,c,s)}default:throw Error("Unknown signature algorithm.")}}ot.getNonce=function(t,e){const r=t.slice();for(let n=0;n<e.length;n++)r[4+n]^=e[n];return r},ot.blockLength=16,ot.ivLength=12,ot.tagLength=nr;class Qn extends Error{constructor(...e){super(...e),Error.captureStackTrace&&Error.captureStackTrace(this,Qn),this.name="Argon2OutOfMemoryError"}}let Vt,St;class zc{constructor(e=P){const{passes:r,parallelism:n,memoryExponent:i}=e.s2kArgon2Params;this.type="argon2",this.salt=null,this.t=r,this.p=n,this.encodedM=i}generateSalt(){this.salt=ye(16)}read(e){let r=0;return this.salt=e.subarray(r,r+16),r+=16,this.t=e[r++],this.p=e[r++],this.encodedM=e[r++],r}write(){const e=[new Uint8Array([o.write(o.s2k,this.type)]),this.salt,new Uint8Array([this.t,this.p,this.encodedM])];return y.concatUint8Array(e)}async produceKey(e,r){const n=2<<this.encodedM-1;try{Vt=Vt||(await ge(async()=>{const{default:a}=await import("./argon2id.min-BCakvyHE.js");return{default:a}},[],import.meta.url)).default,St=St||Vt();const i=await St,s=i({version:19,type:2,password:y.encodeUTF8(e),salt:this.salt,tagLength:r,memorySize:n,parallelism:this.p,passes:this.t});return n>1048576&&(St=Vt(),St.catch((()=>{}))),s}catch(i){throw i.message&&(i.message.includes("Unable to grow instance memory")||i.message.includes("failed to grow memory")||i.message.includes("WebAssembly.Memory.grow")||i.message.includes("Out of memory"))?new Qn("Could not allocate required memory for Argon2"):i}}}class _c{constructor(e,r=P){this.algorithm=o.hash.sha256,this.type=o.read(o.s2k,e),this.c=r.s2kIterationCountByte,this.salt=null}generateSalt(){switch(this.type){case"salted":case"iterated":this.salt=ye(8)}}getCount(){return 16+(15&this.c)<<6+(this.c>>4)}read(e){let r=0;switch(this.algorithm=e[r++],this.type){case"simple":break;case"salted":this.salt=e.subarray(r,r+8),r+=8;break;case"iterated":this.salt=e.subarray(r,r+8),r+=8,this.c=e[r++];break;case"gnu":if(y.uint8ArrayToString(e.subarray(r,r+3))!=="GNU")throw new O("Unknown s2k type.");if(r+=3,1e3+e[r++]!==1001)throw new O("Unknown s2k gnu protection mode.");this.type="gnu-dummy";break;default:throw new O("Unknown s2k type.")}return r}write(){if(this.type==="gnu-dummy")return new Uint8Array([101,0,...y.stringToUint8Array("GNU"),1]);const e=[new Uint8Array([o.write(o.s2k,this.type),this.algorithm])];switch(this.type){case"simple":break;case"salted":e.push(this.salt);break;case"iterated":e.push(this.salt),e.push(new Uint8Array([this.c]));break;case"gnu":throw Error("GNU s2k type not supported.");default:throw Error("Unknown s2k type.")}return y.concatUint8Array(e)}async produceKey(e,r){e=y.encodeUTF8(e);const n=[];let i=0,s=0;for(;i<r;){let a;switch(this.type){case"simple":a=y.concatUint8Array([new Uint8Array(s),e]);break;case"salted":a=y.concatUint8Array([new Uint8Array(s),this.salt,e]);break;case"iterated":{const u=y.concatUint8Array([this.salt,e]);let l=u.length;const h=Math.max(this.getCount(),l);a=new Uint8Array(s+h),a.set(u,s);for(let p=s+l;p<h;p+=l,l*=2)a.copyWithin(p,s,p);break}case"gnu":throw Error("GNU s2k type not supported.");default:throw Error("Unknown s2k type.")}const c=await je(this.algorithm,a);n.push(c),i+=c.length,s++}return y.concatUint8Array(n).subarray(0,r)}}const jc=new Set([o.s2k.argon2,o.s2k.iterated]);function Sn(t,e=P){switch(t){case o.s2k.argon2:return new zc(e);case o.s2k.iterated:case o.s2k.gnu:case o.s2k.salted:case o.s2k.simple:return new _c(t,e);default:throw new O("Unsupported S2K type")}}function Gc(t){const{s2kType:e}=t;if(!jc.has(e))throw Error("The provided `config.s2kType` value is not allowed");return Sn(e,t)}var _t=Uint8Array,ha=Uint16Array,qc=Int32Array,Wc=new _t([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Vc=new _t([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),ya=function(t,e){for(var r=new ha(31),n=0;n<31;++n)r[n]=e+=1<<t[n-1];var i=new qc(r[30]);for(n=1;n<30;++n)for(var s=r[n];s<r[n+1];++s)i[s]=s-r[n]<<5|n;return{b:r,r:i}},pa=ya(Wc,2),Qc=pa.b,Zc=pa.r;Qc[28]=258,Zc[258]=28;for(var _i=ya(Vc,0),Fu=_i.b,Ru=_i.r,Xc=new ha(32768),R=0;R<32768;++R){var Qe=(43690&R)>>1|(21845&R)<<1;Qe=(61680&(Qe=(52428&Qe)>>2|(13107&Qe)<<2))>>4|(3855&Qe)<<4,Xc[R]=((65280&Qe)>>8|(255&Qe)<<8)>>1}var Lr=new _t(288);for(R=0;R<144;++R)Lr[R]=8;for(R=144;R<256;++R)Lr[R]=9;for(R=256;R<280;++R)Lr[R]=7;for(R=280;R<288;++R)Lr[R]=8;var Jc=new _t(32);for(R=0;R<32;++R)Jc[R]=5;var Yc=new _t(0),eu=typeof TextDecoder<"u"&&new TextDecoder;try{eu.decode(Yc,{stream:!0})}catch{}class tt{constructor(){this.bytes=""}read(e){return this.bytes=y.uint8ArrayToString(e.subarray(0,8)),this.bytes.length}write(){return y.stringToUint8Array(this.bytes)}toHex(){return y.uint8ArrayToHex(y.stringToUint8Array(this.bytes))}equals(e,r=!1){return r&&(e.isWildcard()||this.isWildcard())||this.bytes===e.bytes}isNull(){return this.bytes===""}isWildcard(){return/^0+$/.test(this.toHex())}static mapToHex(e){return e.toHex()}static fromID(e){const r=new tt;return r.read(y.hexToUint8Array(e)),r}static wildcard(){const e=new tt;return e.read(new Uint8Array(8)),e}}const Pt=Symbol("verified"),ji="salt@notations.openpgpjs.org",tu=new Set([o.signatureSubpacket.issuerKeyID,o.signatureSubpacket.issuerFingerprint,o.signatureSubpacket.embeddedSignature]);class Be{static get tag(){return o.packet.signature}constructor(){this.version=null,this.signatureType=null,this.hashAlgorithm=null,this.publicKeyAlgorithm=null,this.signatureData=null,this.unhashedSubpackets=[],this.unknownSubpackets=[],this.signedHashValue=null,this.salt=null,this.created=null,this.signatureExpirationTime=null,this.signatureNeverExpires=!0,this.exportable=null,this.trustLevel=null,this.trustAmount=null,this.regularExpression=null,this.revocable=null,this.keyExpirationTime=null,this.keyNeverExpires=null,this.preferredSymmetricAlgorithms=null,this.revocationKeyClass=null,this.revocationKeyAlgorithm=null,this.revocationKeyFingerprint=null,this.issuerKeyID=new tt,this.rawNotations=[],this.notations={},this.preferredHashAlgorithms=null,this.preferredCompressionAlgorithms=null,this.keyServerPreferences=null,this.preferredKeyServer=null,this.isPrimaryUserID=null,this.policyURI=null,this.keyFlags=null,this.signersUserID=null,this.reasonForRevocationFlag=null,this.reasonForRevocationString=null,this.features=null,this.signatureTargetPublicKeyAlgorithm=null,this.signatureTargetHashAlgorithm=null,this.signatureTargetHash=null,this.embeddedSignature=null,this.issuerKeyVersion=null,this.issuerFingerprint=null,this.preferredAEADAlgorithms=null,this.preferredCipherSuites=null,this.revoked=null,this[Pt]=null}read(e,r=P){let n=0;if(this.version=e[n++],this.version===5&&!r.enableParsingV5Entities)throw new O("Support for v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed");if(this.version!==4&&this.version!==5&&this.version!==6)throw new O(`Version ${this.version} of the signature packet is unsupported.`);if(this.signatureType=e[n++],this.publicKeyAlgorithm=e[n++],this.hashAlgorithm=e[n++],n+=this.readSubPackets(e.subarray(n,e.length),!0),!this.created)throw Error("Missing signature creation time subpacket.");if(this.signatureData=e.subarray(0,n),n+=this.readSubPackets(e.subarray(n,e.length),!1),this.signedHashValue=e.subarray(n,n+2),n+=2,this.version===6){const c=e[n++];this.salt=e.subarray(n,n+c),n+=c}const i=e.subarray(n,e.length),{read:s,signatureParams:a}=(function(c,u){let l=0;switch(c){case o.publicKey.rsaEncryptSign:case o.publicKey.rsaEncrypt:case o.publicKey.rsaSign:{const h=y.readMPI(u.subarray(l));return l+=h.length+2,{read:l,signatureParams:{s:h}}}case o.publicKey.dsa:case o.publicKey.ecdsa:{const h=y.readMPI(u.subarray(l));l+=h.length+2;const p=y.readMPI(u.subarray(l));return l+=p.length+2,{read:l,signatureParams:{r:h,s:p}}}case o.publicKey.eddsaLegacy:{const h=y.readMPI(u.subarray(l));l+=h.length+2;const p=y.readMPI(u.subarray(l));return l+=p.length+2,{read:l,signatureParams:{r:h,s:p}}}case o.publicKey.ed25519:case o.publicKey.ed448:{const h=2*Kr(c),p=y.readExactSubarray(u,l,l+h);return l+=p.length,{read:l,signatureParams:{RS:p}}}default:throw new O("Unknown signature algorithm.")}})(this.publicKeyAlgorithm,i);if(s<i.length)throw Error("Error reading MPIs");this.params=a}writeParams(){return this.params instanceof Promise?Ln((async()=>Mt(this.publicKeyAlgorithm,await this.params))):Mt(this.publicKeyAlgorithm,this.params)}write(){const e=[];return e.push(this.signatureData),e.push(this.writeUnhashedSubPackets()),e.push(this.signedHashValue),this.version===6&&(e.push(new Uint8Array([this.salt.length])),e.push(this.salt)),e.push(this.writeParams()),y.concat(e)}async sign(e,r,n=new Date,i=!1,s){this.version=e.version,this.created=y.normalizeDate(n),this.issuerKeyVersion=e.version,this.issuerFingerprint=e.getFingerprintBytes(),this.issuerKeyID=e.getKeyID();const a=[new Uint8Array([this.version,this.signatureType,this.publicKeyAlgorithm,this.hashAlgorithm])];if(this.version===6){const h=Zr(this.hashAlgorithm);if(this.salt===null)this.salt=ye(h);else if(h!==this.salt.length)throw Error("Provided salt does not have the required length")}else if(s.nonDeterministicSignaturesViaNotation){if(this.rawNotations.filter((({name:h})=>h===ji)).length!==0)throw Error("Unexpected existing salt notation");{const h=ye(Zr(this.hashAlgorithm));this.rawNotations.push({name:ji,value:h,humanReadable:!1,critical:!1})}}a.push(this.writeHashedSubPackets()),this.unhashedSubpackets=[],this.signatureData=y.concat(a);const c=this.toHash(this.signatureType,r,i),u=await this.hash(this.signatureType,r,c,i);this.signedHashValue=ie(sr(u),0,2);const l=async()=>$c(this.publicKeyAlgorithm,this.hashAlgorithm,e.publicParams,e.privateParams,c,await gt(u));y.isStream(u)?this.params=l():(this.params=await l(),this[Pt]=!0)}writeHashedSubPackets(){const e=o.signatureSubpacket,r=[];let n;if(this.created===null)throw Error("Missing signature creation time");r.push(B(e.signatureCreationTime,!0,y.writeDate(this.created))),this.signatureExpirationTime!==null&&r.push(B(e.signatureExpirationTime,!0,y.writeNumber(this.signatureExpirationTime,4))),this.exportable!==null&&r.push(B(e.exportableCertification,!0,new Uint8Array([this.exportable?1:0]))),this.trustLevel!==null&&(n=new Uint8Array([this.trustLevel,this.trustAmount]),r.push(B(e.trustSignature,!0,n))),this.regularExpression!==null&&r.push(B(e.regularExpression,!0,this.regularExpression)),this.revocable!==null&&r.push(B(e.revocable,!0,new Uint8Array([this.revocable?1:0]))),this.keyExpirationTime!==null&&r.push(B(e.keyExpirationTime,!0,y.writeNumber(this.keyExpirationTime,4))),this.preferredSymmetricAlgorithms!==null&&(n=y.stringToUint8Array(y.uint8ArrayToString(this.preferredSymmetricAlgorithms)),r.push(B(e.preferredSymmetricAlgorithms,!1,n))),this.revocationKeyClass!==null&&(n=new Uint8Array([this.revocationKeyClass,this.revocationKeyAlgorithm]),n=y.concat([n,this.revocationKeyFingerprint]),r.push(B(e.revocationKey,!1,n))),!this.issuerKeyID.isNull()&&this.issuerKeyVersion<5&&r.push(B(e.issuerKeyID,!1,this.issuerKeyID.write())),this.rawNotations.forEach((({name:a,value:c,humanReadable:u,critical:l})=>{n=[new Uint8Array([u?128:0,0,0,0])];const h=y.encodeUTF8(a);n.push(y.writeNumber(h.length,2)),n.push(y.writeNumber(c.length,2)),n.push(h),n.push(c),n=y.concat(n),r.push(B(e.notationData,l,n))})),this.preferredHashAlgorithms!==null&&(n=y.stringToUint8Array(y.uint8ArrayToString(this.preferredHashAlgorithms)),r.push(B(e.preferredHashAlgorithms,!1,n))),this.preferredCompressionAlgorithms!==null&&(n=y.stringToUint8Array(y.uint8ArrayToString(this.preferredCompressionAlgorithms)),r.push(B(e.preferredCompressionAlgorithms,!1,n))),this.keyServerPreferences!==null&&(n=y.stringToUint8Array(y.uint8ArrayToString(this.keyServerPreferences)),r.push(B(e.keyServerPreferences,!1,n))),this.preferredKeyServer!==null&&r.push(B(e.preferredKeyServer,!1,y.encodeUTF8(this.preferredKeyServer))),this.isPrimaryUserID!==null&&r.push(B(e.primaryUserID,!1,new Uint8Array([this.isPrimaryUserID?1:0]))),this.policyURI!==null&&r.push(B(e.policyURI,!1,y.encodeUTF8(this.policyURI))),this.keyFlags!==null&&(n=y.stringToUint8Array(y.uint8ArrayToString(this.keyFlags)),r.push(B(e.keyFlags,!0,n))),this.signersUserID!==null&&r.push(B(e.signersUserID,!1,y.encodeUTF8(this.signersUserID))),this.reasonForRevocationFlag!==null&&(n=y.stringToUint8Array(String.fromCharCode(this.reasonForRevocationFlag)+this.reasonForRevocationString),r.push(B(e.reasonForRevocation,!0,n))),this.features!==null&&(n=y.stringToUint8Array(y.uint8ArrayToString(this.features)),r.push(B(e.features,!1,n))),this.signatureTargetPublicKeyAlgorithm!==null&&(n=[new Uint8Array([this.signatureTargetPublicKeyAlgorithm,this.signatureTargetHashAlgorithm])],n.push(y.stringToUint8Array(this.signatureTargetHash)),n=y.concat(n),r.push(B(e.signatureTarget,!0,n))),this.embeddedSignature!==null&&r.push(B(e.embeddedSignature,!0,this.embeddedSignature.write())),this.issuerFingerprint!==null&&(n=[new Uint8Array([this.issuerKeyVersion]),this.issuerFingerprint],n=y.concat(n),r.push(B(e.issuerFingerprint,this.version>=5,n))),this.preferredAEADAlgorithms!==null&&(n=y.stringToUint8Array(y.uint8ArrayToString(this.preferredAEADAlgorithms)),r.push(B(e.preferredAEADAlgorithms,!1,n))),this.preferredCipherSuites!==null&&(n=new Uint8Array([].concat(...this.preferredCipherSuites)),r.push(B(e.preferredCipherSuites,!1,n)));const i=y.concat(r),s=y.writeNumber(i.length,this.version===6?4:2);return y.concat([s,i])}writeUnhashedSubPackets(){const e=this.unhashedSubpackets.map((({type:i,critical:s,body:a})=>B(i,s,a))),r=y.concat(e),n=y.writeNumber(r.length,this.version===6?4:2);return y.concat([n,r])}readSubPacket(e,r=!0){let n=0;const i=!!(128&e[n]),s=127&e[n];if(n++,r||(this.unhashedSubpackets.push({type:s,critical:i,body:e.subarray(n,e.length)}),tu.has(s)))switch(s){case o.signatureSubpacket.signatureCreationTime:this.created=y.readDate(e.subarray(n,e.length));break;case o.signatureSubpacket.signatureExpirationTime:{const a=y.readNumber(e.subarray(n,e.length));this.signatureNeverExpires=a===0,this.signatureExpirationTime=a;break}case o.signatureSubpacket.exportableCertification:this.exportable=e[n++]===1;break;case o.signatureSubpacket.trustSignature:this.trustLevel=e[n++],this.trustAmount=e[n++];break;case o.signatureSubpacket.regularExpression:this.regularExpression=e[n];break;case o.signatureSubpacket.revocable:this.revocable=e[n++]===1;break;case o.signatureSubpacket.keyExpirationTime:{const a=y.readNumber(e.subarray(n,e.length));this.keyExpirationTime=a,this.keyNeverExpires=a===0;break}case o.signatureSubpacket.preferredSymmetricAlgorithms:this.preferredSymmetricAlgorithms=[...e.subarray(n,e.length)];break;case o.signatureSubpacket.revocationKey:this.revocationKeyClass=e[n++],this.revocationKeyAlgorithm=e[n++],this.revocationKeyFingerprint=e.subarray(n,n+20);break;case o.signatureSubpacket.issuerKeyID:if(this.version===4)this.issuerKeyID.read(e.subarray(n,e.length));else if(r)throw Error("Unexpected Issuer Key ID subpacket");break;case o.signatureSubpacket.notationData:{const a=!!(128&e[n]);n+=4;const c=y.readNumber(e.subarray(n,n+2));n+=2;const u=y.readNumber(e.subarray(n,n+2));n+=2;const l=y.decodeUTF8(e.subarray(n,n+c)),h=e.subarray(n+c,n+c+u);this.rawNotations.push({name:l,humanReadable:a,value:h,critical:i}),a&&(this.notations[l]=y.decodeUTF8(h));break}case o.signatureSubpacket.preferredHashAlgorithms:this.preferredHashAlgorithms=[...e.subarray(n,e.length)];break;case o.signatureSubpacket.preferredCompressionAlgorithms:this.preferredCompressionAlgorithms=[...e.subarray(n,e.length)];break;case o.signatureSubpacket.keyServerPreferences:this.keyServerPreferences=[...e.subarray(n,e.length)];break;case o.signatureSubpacket.preferredKeyServer:this.preferredKeyServer=y.decodeUTF8(e.subarray(n,e.length));break;case o.signatureSubpacket.primaryUserID:this.isPrimaryUserID=e[n++]!==0;break;case o.signatureSubpacket.policyURI:this.policyURI=y.decodeUTF8(e.subarray(n,e.length));break;case o.signatureSubpacket.keyFlags:this.keyFlags=[...e.subarray(n,e.length)];break;case o.signatureSubpacket.signersUserID:this.signersUserID=y.decodeUTF8(e.subarray(n,e.length));break;case o.signatureSubpacket.reasonForRevocation:this.reasonForRevocationFlag=e[n++],this.reasonForRevocationString=y.decodeUTF8(e.subarray(n,e.length));break;case o.signatureSubpacket.features:this.features=[...e.subarray(n,e.length)];break;case o.signatureSubpacket.signatureTarget:{this.signatureTargetPublicKeyAlgorithm=e[n++],this.signatureTargetHashAlgorithm=e[n++];const a=H(this.signatureTargetHashAlgorithm);this.signatureTargetHash=y.uint8ArrayToString(e.subarray(n,n+a));break}case o.signatureSubpacket.embeddedSignature:this.embeddedSignature=new Be,this.embeddedSignature.read(e.subarray(n,e.length));break;case o.signatureSubpacket.issuerFingerprint:this.issuerKeyVersion=e[n++],this.issuerFingerprint=e.subarray(n,e.length),this.issuerKeyVersion>=5?this.issuerKeyID.read(this.issuerFingerprint):this.issuerKeyID.read(this.issuerFingerprint.subarray(-8));break;case o.signatureSubpacket.preferredAEADAlgorithms:this.preferredAEADAlgorithms=[...e.subarray(n,e.length)];break;case o.signatureSubpacket.preferredCipherSuites:this.preferredCipherSuites=[];for(let a=n;a<e.length;a+=2)this.preferredCipherSuites.push([e[a],e[a+1]]);break;default:this.unknownSubpackets.push({type:s,critical:i,body:e.subarray(n,e.length)})}}readSubPackets(e,r=!0,n){const i=this.version===6?4:2,s=y.readNumber(e.subarray(0,i));let a=i;for(;a<2+s;){const c=Fs(e.subarray(a,e.length));a+=c.offset,this.readSubPacket(e.subarray(a,a+c.len),r,n),a+=c.len}return a}toSign(e,r){const n=o.signature;switch(e){case n.binary:return r.text!==null?y.encodeUTF8(r.getText(!0)):r.getBytes(!0);case n.text:{const i=r.getBytes(!0);return y.canonicalizeEOL(i)}case n.standalone:return new Uint8Array(0);case n.certGeneric:case n.certPersona:case n.certCasual:case n.certPositive:case n.certRevocation:{let i,s;if(r.userID)s=180,i=r.userID;else{if(!r.userAttribute)throw Error("Either a userID or userAttribute packet needs to be supplied for certification.");s=209,i=r.userAttribute}const a=i.write();return y.concat([this.toSign(n.key,r),new Uint8Array([s]),y.writeNumber(a.length,4),a])}case n.subkeyBinding:case n.subkeyRevocation:case n.keyBinding:return y.concat([this.toSign(n.key,r),this.toSign(n.key,{key:r.bind})]);case n.key:if(r.key===void 0)throw Error("Key packet is required for this signature.");return r.key.writeForHash(this.version);case n.keyRevocation:return this.toSign(n.key,r);case n.timestamp:return new Uint8Array(0);case n.thirdParty:throw Error("Not implemented");default:throw Error("Unknown signature type.")}}calculateTrailer(e,r){let n=0;return $(sr(this.signatureData),(i=>{n+=i.length}),(()=>{const i=[];return this.version!==5||this.signatureType!==o.signature.binary&&this.signatureType!==o.signature.text||(r?i.push(new Uint8Array(6)):i.push(e.writeHeader())),i.push(new Uint8Array([this.version,255])),this.version===5&&i.push(new Uint8Array(4)),i.push(y.writeNumber(n,4)),y.concat(i)}))}toHash(e,r,n=!1){const i=this.toSign(e,r);return y.concat([this.salt||new Uint8Array,i,this.signatureData,this.calculateTrailer(r,n)])}async hash(e,r,n,i=!1){if(this.version===6&&this.salt.length!==Zr(this.hashAlgorithm))throw Error("Signature salt does not have the expected length");return n||(n=this.toHash(e,r,i)),je(this.hashAlgorithm,n)}async verify(e,r,n,i=new Date,s=!1,a=P){if(!this.issuerKeyID.equals(e.getKeyID()))throw Error("Signature was not issued by the given public key");if(this.publicKeyAlgorithm!==e.algorithm)throw Error("Public key algorithm used to sign signature does not match issuer key algorithm.");const c=r===o.signature.binary||r===o.signature.text;if(!(this[Pt]&&!c)){let l,h;if(this.hashed?h=await this.hashed:(l=this.toHash(r,n,s),h=await this.hash(r,n,l)),h=await gt(h),this.signedHashValue[0]!==h[0]||this.signedHashValue[1]!==h[1])throw Error("Signed digest did not match");if(this.params=await this.params,this[Pt]=await Hc(this.publicKeyAlgorithm,this.hashAlgorithm,this.params,e.publicParams,l,h),!this[Pt])throw Error("Signature verification failed")}const u=y.normalizeDate(i);if(u&&this.created>u)throw Error("Signature creation time is in the future");if(u&&u>=this.getExpirationTime())throw Error("Signature is expired");if(a.rejectHashAlgorithms.has(this.hashAlgorithm))throw Error("Insecure hash algorithm: "+o.read(o.hash,this.hashAlgorithm).toUpperCase());if(a.rejectMessageHashAlgorithms.has(this.hashAlgorithm)&&[o.signature.binary,o.signature.text].includes(this.signatureType))throw Error("Insecure message hash algorithm: "+o.read(o.hash,this.hashAlgorithm).toUpperCase());if(this.unknownSubpackets.forEach((({type:l,critical:h})=>{if(h)throw Error("Unknown critical signature subpacket type "+l)})),this.rawNotations.forEach((({name:l,critical:h})=>{if(h&&a.knownNotations.indexOf(l)<0)throw Error("Unknown critical notation: "+l)})),this.revocationKeyClass!==null)throw Error("This key is intended to be revoked with an authorized key, which OpenPGP.js does not support.")}isExpired(e=new Date){const r=y.normalizeDate(e);return r!==null&&!(this.created<=r&&r<this.getExpirationTime())}getExpirationTime(){return this.signatureNeverExpires?1/0:new Date(this.created.getTime()+1e3*this.signatureExpirationTime)}}function B(t,e,r){const n=[];return n.push(Pr(r.length+1)),n.push(new Uint8Array([(e?128:0)|t])),n.push(r),y.concat(n)}function Zr(t){switch(t){case o.hash.sha256:return 16;case o.hash.sha384:return 24;case o.hash.sha512:return 32;case o.hash.sha224:case o.hash.sha3_256:return 16;case o.hash.sha3_512:return 32;default:throw Error("Unsupported hash function")}}class Bt{static get tag(){return o.packet.onePassSignature}static fromSignaturePacket(e,r){const n=new Bt;return n.version=e.version===6?6:3,n.signatureType=e.signatureType,n.hashAlgorithm=e.hashAlgorithm,n.publicKeyAlgorithm=e.publicKeyAlgorithm,n.issuerKeyID=e.issuerKeyID,n.salt=e.salt,n.issuerFingerprint=e.issuerFingerprint,n.flags=r?1:0,n}constructor(){this.version=null,this.signatureType=null,this.hashAlgorithm=null,this.publicKeyAlgorithm=null,this.salt=null,this.issuerKeyID=null,this.issuerFingerprint=null,this.flags=null}read(e){let r=0;if(this.version=e[r++],this.version!==3&&this.version!==6)throw new O(`Version ${this.version} of the one-pass signature packet is unsupported.`);if(this.signatureType=e[r++],this.hashAlgorithm=e[r++],this.publicKeyAlgorithm=e[r++],this.version===6){const n=e[r++];this.salt=e.subarray(r,r+n),r+=n,this.issuerFingerprint=e.subarray(r,r+32),r+=32,this.issuerKeyID=new tt,this.issuerKeyID.read(this.issuerFingerprint)}else this.issuerKeyID=new tt,this.issuerKeyID.read(e.subarray(r,r+8)),r+=8;return this.flags=e[r++],this}write(){const e=[new Uint8Array([this.version,this.signatureType,this.hashAlgorithm,this.publicKeyAlgorithm])];return this.version===6?e.push(new Uint8Array([this.salt.length]),this.salt,this.issuerFingerprint):e.push(this.issuerKeyID.write()),e.push(new Uint8Array([this.flags])),y.concatUint8Array(e)}calculateTrailer(...e){return Ln((async()=>Be.prototype.calculateTrailer.apply(await this.correspondingSig,e)))}async verify(){const e=await this.correspondingSig;if(!e||e.constructor.tag!==o.packet.signature)throw Error("Corresponding signature packet missing");if(e.signatureType!==this.signatureType||e.hashAlgorithm!==this.hashAlgorithm||e.publicKeyAlgorithm!==this.publicKeyAlgorithm||!e.issuerKeyID.equals(this.issuerKeyID)||this.version===3&&e.version===6||this.version===6&&e.version!==6||this.version===6&&!y.equalsUint8Array(e.issuerFingerprint,this.issuerFingerprint)||this.version===6&&!y.equalsUint8Array(e.salt,this.salt))throw Error("Corresponding signature packet does not match one-pass signature packet");return e.hashed=this.hashed,e.verify.apply(e,arguments)}}function ru(t,e){if(!e[t]){let r;try{r=o.read(o.packet,t)}catch{throw new Xt("Unknown packet type with tag: "+t)}throw Error("Packet not allowed in this context: "+r)}return new e[t]}Bt.prototype.hash=Be.prototype.hash,Bt.prototype.toHash=Be.prototype.toHash,Bt.prototype.toSign=Be.prototype.toSign;class ue extends Array{static async fromBinary(e,r,n=P,i=null,s=!1){const a=new ue;return await a.read(e,r,n,i,s),a}async read(e,r,n=P,i=null,s=!1){let a;n.additionalAllowedPackets.length&&(a=y.constructAllowedPackets(n.additionalAllowedPackets),r={...r,...a}),this.stream=Sr(e,(async(u,l)=>{const h=dt(u),p=Ke(l);try{let g=y.isStream(u);for(;;){let f,d;if(await p.ready,await oc(h,g,(async w=>{try{if(w.tag===o.packet.marker||w.tag===o.packet.trust||w.tag===o.packet.padding)return;const b=ru(w.tag,r);try{i?.recordPacket(w.tag,a)}catch(k){if(n.enforceGrammar)throw k;y.printDebugError(k)}b.packets=new ue,b.fromStream=y.isStream(w.packet),d=b.fromStream;try{await b.read(w.packet,n)}catch(k){throw k instanceof O?k:y.wrapError(new zr(`Parsing ${b.constructor.name} failed`),k)}await p.write(b)}catch(b){const k=b instanceof Xt&&w.tag<=39,v=b instanceof O&&!(b instanceof Xt)&&!n.ignoreUnsupportedPackets,A=b instanceof zr&&!n.ignoreMalformedPackets,E=Zt(w.tag);if(k||v||A||E||!(b instanceof Xt||b instanceof O||b instanceof zr))s?f=b:await p.abort(b);else{const D=new hn(w.tag,w.packet);await p.write(D)}y.printDebugError(b)}})),d&&(g=null),f)throw await h.readToEnd(),f;const m=await h.peekBytes(2);if(!m||!m.length){try{i?.recordEnd()}catch(w){if(n.enforceGrammar)throw w;y.printDebugError(w)}return await p.ready,void await p.close()}}}catch(g){await p.abort(g)}}));const c=dt(this.stream);for(;;){const{done:u,value:l}=await c.read();if(u?this.stream=null:this.push(l),u||Zt(l.constructor.tag))break}c.releaseLock()}write(){const e=[];for(let r=0;r<this.length;r++){const n=this[r]instanceof hn?this[r].tag:this[r].constructor.tag,i=this[r].write();if(y.isStream(i)&&Zt(this[r].constructor.tag)){let s=[],a=0;const c=512;e.push(lr(n)),e.push($(i,(u=>{if(s.push(u),a+=u.length,a>=c){const l=Math.min(Math.log(a)/Math.LN2|0,30),h=2**l,p=y.concat([ac(l)].concat(s));return s=[p.subarray(1+h)],a=s[0].length,p.subarray(0,1+h)}}),(()=>y.concat([Pr(a)].concat(s)))))}else{if(y.isStream(i)){let s=0;e.push($(sr(i),(a=>{s+=a.length}),(()=>Si(n,s))))}else e.push(Si(n,i.length));e.push(i)}}return y.concat(e)}filterByTag(...e){const r=new ue,n=i=>s=>i===s;for(let i=0;i<this.length;i++)e.some(n(this[i].constructor.tag))&&r.push(this[i]);return r}findPacket(e){return this.find((r=>r.constructor.tag===e))}indexOfTag(...e){const r=[],n=this,i=s=>a=>s===a;for(let s=0;s<this.length;s++)e.some(i(n[s].constructor.tag))&&r.push(s);return r}}var Gi;(function(t){t[t.EmptyMessage=0]="EmptyMessage",t[t.PlaintextOrEncryptedData=1]="PlaintextOrEncryptedData",t[t.EncryptedSessionKeys=2]="EncryptedSessionKeys",t[t.StandaloneAdditionalAllowedData=3]="StandaloneAdditionalAllowedData"})(Gi||(Gi={}));class Se{static get tag(){return o.packet.publicKey}constructor(e=new Date,r=P){this.version=r.v6Keys?6:4,this.created=y.normalizeDate(e),this.algorithm=null,this.publicParams=null,this.expirationTimeV3=0,this.fingerprint=null,this.keyID=null}static fromSecretKeyPacket(e){const r=new Se,{version:n,created:i,algorithm:s,publicParams:a,keyID:c,fingerprint:u}=e;return r.version=n,r.created=i,r.algorithm=s,r.publicParams=a,r.keyID=c,r.fingerprint=u,r}async read(e,r=P){let n=0;if(this.version=e[n++],this.version===5&&!r.enableParsingV5Entities)throw new O("Support for parsing v5 entities is disabled; turn on `config.enableParsingV5Entities` if needed");if(this.version===4||this.version===5||this.version===6){this.created=y.readDate(e.subarray(n,n+4)),n+=4,this.algorithm=e[n++],this.version>=5&&(n+=4);const{read:i,publicParams:s}=(function(a,c){let u=0;switch(a){case o.publicKey.rsaEncrypt:case o.publicKey.rsaEncryptSign:case o.publicKey.rsaSign:{const l=y.readMPI(c.subarray(u));u+=l.length+2;const h=y.readMPI(c.subarray(u));return u+=h.length+2,{read:u,publicParams:{n:l,e:h}}}case o.publicKey.dsa:{const l=y.readMPI(c.subarray(u));u+=l.length+2;const h=y.readMPI(c.subarray(u));u+=h.length+2;const p=y.readMPI(c.subarray(u));u+=p.length+2;const g=y.readMPI(c.subarray(u));return u+=g.length+2,{read:u,publicParams:{p:l,q:h,g:p,y:g}}}case o.publicKey.elgamal:{const l=y.readMPI(c.subarray(u));u+=l.length+2;const h=y.readMPI(c.subarray(u));u+=h.length+2;const p=y.readMPI(c.subarray(u));return u+=p.length+2,{read:u,publicParams:{p:l,g:h,y:p}}}case o.publicKey.ecdsa:{const l=new Te;u+=l.read(c),Gr(l);const h=y.readMPI(c.subarray(u));return u+=h.length+2,{read:u,publicParams:{oid:l,Q:h}}}case o.publicKey.eddsaLegacy:{const l=new Te;if(u+=l.read(c),Gr(l),l.getName()!==o.curve.ed25519Legacy)throw Error("Unexpected OID for eddsaLegacy");let h=y.readMPI(c.subarray(u));return u+=h.length+2,h=y.leftPad(h,33),{read:u,publicParams:{oid:l,Q:h}}}case o.publicKey.ecdh:{const l=new Te;u+=l.read(c),Gr(l);const h=y.readMPI(c.subarray(u));u+=h.length+2;const p=new ua;return u+=p.read(c.subarray(u)),{read:u,publicParams:{oid:l,Q:h,kdfParams:p}}}case o.publicKey.ed25519:case o.publicKey.ed448:case o.publicKey.x25519:case o.publicKey.x448:{const l=y.readExactSubarray(c,u,u+Ct(a));return u+=l.length,{read:u,publicParams:{A:l}}}default:throw new O("Unknown public key encryption algorithm.")}})(this.algorithm,e.subarray(n));if(this.version===6&&s.oid&&(s.oid.getName()===o.curve.curve25519Legacy||s.oid.getName()===o.curve.ed25519Legacy))throw Error("Legacy curve25519 cannot be used with v6 keys");return this.publicParams=s,n+=i,await this.computeFingerprintAndKeyID(),n}throw new O(`Version ${this.version} of the key packet is unsupported.`)}write(){const e=[];e.push(new Uint8Array([this.version])),e.push(y.writeDate(this.created)),e.push(new Uint8Array([this.algorithm]));const r=Mt(this.algorithm,this.publicParams);return this.version>=5&&e.push(y.writeNumber(r.length,4)),e.push(r),y.concatUint8Array(e)}writeForHash(e){const r=this.writePublicKey(),n=149+e,i=e>=5?4:2;return y.concatUint8Array([new Uint8Array([n]),y.writeNumber(r.length,i),r])}isDecrypted(){return null}getCreationTime(){return this.created}getKeyID(){return this.keyID}async computeFingerprintAndKeyID(){if(await this.computeFingerprint(),this.keyID=new tt,this.version>=5)this.keyID.read(this.fingerprint.subarray(0,8));else{if(this.version!==4)throw Error("Unsupported key version");this.keyID.read(this.fingerprint.subarray(12,20))}}async computeFingerprint(){const e=this.writeForHash(this.version);if(this.version>=5)this.fingerprint=await je(o.hash.sha256,e);else{if(this.version!==4)throw Error("Unsupported key version");this.fingerprint=await je(o.hash.sha1,e)}}getFingerprintBytes(){return this.fingerprint}getFingerprint(){return y.uint8ArrayToHex(this.getFingerprintBytes())}hasSameFingerprintAs(e){return this.version===e.version&&y.equalsUint8Array(this.writePublicKey(),e.writePublicKey())}getAlgorithmInfo(){const e={};e.algorithm=o.read(o.publicKey,this.algorithm);const r=this.publicParams.n||this.publicParams.p;return r?e.bits=y.uint8ArrayBitLength(r):this.publicParams.oid&&(e.curve=this.publicParams.oid.getName()),e}}Se.prototype.readPublicKey=Se.prototype.read,Se.prototype.writePublicKey=Se.prototype.write;class Fr extends Se{static get tag(){return o.packet.publicSubkey}constructor(e,r){super(e,r)}static fromSecretSubkeyPacket(e){const r=new Fr,{version:n,created:i,algorithm:s,publicParams:a,keyID:c,fingerprint:u}=e;return r.version=n,r.created=i,r.algorithm=s,r.publicParams=a,r.keyID=c,r.fingerprint=u,r}}class Zn{static get tag(){return o.packet.userAttribute}constructor(){this.attributes=[]}read(e){let r=0;for(;r<e.length;){const n=Fs(e.subarray(r,e.length));r+=n.offset,this.attributes.push(y.uint8ArrayToString(e.subarray(r,r+n.len))),r+=n.len}}write(){const e=[];for(let r=0;r<this.attributes.length;r++)e.push(Pr(this.attributes[r].length)),e.push(y.stringToUint8Array(this.attributes[r]));return y.concatUint8Array(e)}equals(e){return!!(e&&e instanceof Zn)&&this.attributes.every((function(r,n){return r===e.attributes[n]}))}}class Xn extends Se{static get tag(){return o.packet.secretKey}constructor(e=new Date,r=P){super(e,r),this.keyMaterial=null,this.isEncrypted=null,this.s2kUsage=0,this.s2k=null,this.symmetric=null,this.aead=null,this.isLegacyAEAD=null,this.privateParams=null,this.usedModernAEAD=null}async read(e,r=P){let n=await this.readPublicKey(e,r);const i=n;this.s2kUsage=e[n++],this.version===5&&n++,this.version===6&&this.s2kUsage&&n++;try{if(this.s2kUsage===255||this.s2kUsage===254||this.s2kUsage===253){this.symmetric=e[n++],this.s2kUsage===253&&(this.aead=e[n++]),this.version===6&&n++;const s=e[n++];if(this.s2k=Sn(s),n+=this.s2k.read(e.subarray(n,e.length)),this.s2k.type==="gnu-dummy")return}else this.s2kUsage&&(this.symmetric=this.s2kUsage);this.s2kUsage&&(this.isLegacyAEAD=this.s2kUsage===253&&(this.version===5||this.version===4&&r.parseAEADEncryptedV4KeysAsLegacy),this.s2kUsage!==253||this.isLegacyAEAD?(this.iv=e.subarray(n,n+Z(this.symmetric).blockSize),this.usedModernAEAD=!1):(this.iv=e.subarray(n,n+Qr(this.aead).ivLength),this.usedModernAEAD=!0),n+=this.iv.length)}catch(s){if(!this.s2kUsage)throw s;this.unparseableKeyMaterial=e.subarray(i),this.isEncrypted=!0}if(this.version===5&&(n+=4),this.keyMaterial=e.subarray(n),this.isEncrypted=!!this.s2kUsage,!this.isEncrypted){let s;if(this.version===6)s=this.keyMaterial;else if(s=this.keyMaterial.subarray(0,-2),!y.equalsUint8Array(y.writeChecksum(s),this.keyMaterial.subarray(-2)))throw Error("Key checksum mismatch");try{const{read:a,privateParams:c}=Li(this.algorithm,s,this.publicParams);if(a<s.length)throw Error("Error reading MPIs");this.privateParams=c}catch(a){throw a instanceof O?a:Error("Error reading MPIs")}}}write(){const e=this.writePublicKey();if(this.unparseableKeyMaterial)return y.concatUint8Array([e,this.unparseableKeyMaterial]);const r=[e];r.push(new Uint8Array([this.s2kUsage]));const n=[];if(this.s2kUsage===255||this.s2kUsage===254||this.s2kUsage===253){n.push(this.symmetric),this.s2kUsage===253&&n.push(this.aead);const i=this.s2k.write();this.version===6&&n.push(i.length),n.push(...i)}return this.s2kUsage&&this.s2k.type!=="gnu-dummy"&&n.push(...this.iv),(this.version===5||this.version===6&&this.s2kUsage)&&r.push(new Uint8Array([n.length])),r.push(new Uint8Array(n)),this.isDummy()||(this.s2kUsage||(this.keyMaterial=Mt(this.algorithm,this.privateParams)),this.version===5&&r.push(y.writeNumber(this.keyMaterial.length,4)),r.push(this.keyMaterial),this.s2kUsage||this.version===6||r.push(y.writeChecksum(this.keyMaterial))),y.concatUint8Array(r)}isDecrypted(){return this.isEncrypted===!1}isMissingSecretKeyMaterial(){return this.unparseableKeyMaterial!==void 0||this.isDummy()}isDummy(){return!(!this.s2k||this.s2k.type!=="gnu-dummy")}makeDummy(e=P){this.isDummy()||(this.isDecrypted()&&this.clearPrivateParams(),delete this.unparseableKeyMaterial,this.isEncrypted=null,this.keyMaterial=null,this.s2k=Sn(o.s2k.gnu,e),this.s2k.algorithm=0,this.s2k.c=0,this.s2k.type="gnu-dummy",this.s2kUsage=254,this.symmetric=o.symmetric.aes256,this.isLegacyAEAD=null,this.usedModernAEAD=null)}async encrypt(e,r=P){if(this.isDummy())return;if(!this.isDecrypted())throw Error("Key packet is already encrypted");if(!e)throw Error("A non-empty passphrase is required for key encryption.");this.s2k=Gc(r),this.s2k.generateSalt();const n=Mt(this.algorithm,this.privateParams);this.symmetric=o.symmetric.aes256;const{blockSize:i}=Z(this.symmetric);if(r.aeadProtect){this.s2kUsage=253,this.aead=r.preferredAEADAlgorithm;const s=Qr(this.aead);this.isLegacyAEAD=this.version===5,this.usedModernAEAD=!this.isLegacyAEAD;const a=lr(this.constructor.tag),c=await Xr(this.version,this.s2k,e,this.symmetric,this.aead,a,this.isLegacyAEAD),u=await s(this.symmetric,c);this.iv=this.isLegacyAEAD?ye(i):ye(s.ivLength);const l=this.isLegacyAEAD?new Uint8Array:y.concatUint8Array([a,this.writePublicKey()]);this.keyMaterial=await u.encrypt(n,this.iv.subarray(0,s.ivLength),l)}else{this.s2kUsage=254,this.usedModernAEAD=!1;const s=await Xr(this.version,this.s2k,e,this.symmetric);this.iv=ye(i),this.keyMaterial=await Cc(this.symmetric,s,y.concatUint8Array([n,await je(o.hash.sha1,n)]),this.iv)}}async decrypt(e){if(this.isDummy())return!1;if(this.unparseableKeyMaterial)throw Error("Key packet cannot be decrypted: unsupported S2K or cipher algo");if(this.isDecrypted())throw Error("Key packet is already decrypted.");let r;const n=lr(this.constructor.tag);if(this.s2kUsage!==254&&this.s2kUsage!==253)throw this.s2kUsage===255?Error("Encrypted private key is authenticated using an insecure two-byte hash"):Error("Private key is encrypted using an insecure S2K function: unsalted MD5");let i;if(r=await Xr(this.version,this.s2k,e,this.symmetric,this.aead,n,this.isLegacyAEAD),this.s2kUsage===253){const s=Qr(this.aead,!0),a=await s(this.symmetric,r);try{const c=this.isLegacyAEAD?new Uint8Array:y.concatUint8Array([n,this.writePublicKey()]);i=await a.decrypt(this.keyMaterial,this.iv.subarray(0,s.ivLength),c)}catch(c){throw c.message==="Authentication tag mismatch"?Error("Incorrect key passphrase: "+c.message):c}}else{const s=await xc(this.symmetric,r,this.keyMaterial,this.iv);i=s.subarray(0,-20);const a=await je(o.hash.sha1,i);if(!y.equalsUint8Array(a,s.subarray(-20)))throw Error("Incorrect key passphrase")}try{const{privateParams:s}=Li(this.algorithm,i,this.publicParams);this.privateParams=s}catch{throw Error("Error reading MPIs")}this.isEncrypted=!1,this.keyMaterial=null,this.s2kUsage=0,this.aead=null,this.symmetric=null,this.isLegacyAEAD=null}async validate(){if(this.isDummy())return;if(!this.isDecrypted())throw Error("Key is not decrypted");if(this.usedModernAEAD)return;let e;try{e=await Ic(this.algorithm,this.publicParams,this.privateParams)}catch{e=!1}if(!e)throw Error("Key is invalid")}async generate(e,r){if(this.version===6&&(this.algorithm===o.publicKey.ecdh&&r===o.curve.curve25519Legacy||this.algorithm===o.publicKey.eddsaLegacy))throw Error(`Cannot generate v6 keys of type 'ecc' with curve ${r}. Generate a key of type 'curve25519' instead`);const{privateParams:n,publicParams:i}=await Dc(this.algorithm,e,r);this.privateParams=n,this.publicParams=i,this.isEncrypted=!1}clearPrivateParams(){this.isMissingSecretKeyMaterial()||(Object.keys(this.privateParams).forEach((e=>{this.privateParams[e].fill(0),delete this.privateParams[e]})),this.privateParams=null,this.isEncrypted=!0)}}async function Xr(t,e,r,n,i,s,a){if(e.type==="argon2"&&!i)throw Error("Using Argon2 S2K without AEAD is not allowed");if(e.type==="simple"&&t===6)throw Error("Using Simple S2K with version 6 keys is not allowed");const{keySize:c}=Z(n),u=await e.produceKey(r,c);if(!i||t===5||a)return u;const l=y.concatUint8Array([s,new Uint8Array([t,n,i])]);return Nt(o.hash.sha256,u,new Uint8Array,l,c)}class Rr{static get tag(){return o.packet.userID}constructor(){this.userID="",this.name="",this.email="",this.comment=""}static fromObject(e){if(y.isString(e)||e.name&&!y.isString(e.name)||e.email&&!y.isEmailAddress(e.email)||e.comment&&!y.isString(e.comment))throw Error("Invalid user ID format");const r=new Rr;Object.assign(r,e);const n=[];return r.name&&n.push(r.name),r.comment&&n.push(`(${r.comment})`),r.email&&n.push(`<${r.email}>`),r.userID=n.join(" "),r}read(e,r=P){const n=y.decodeUTF8(e);if(n.length>r.maxUserIDLength)throw Error("User ID string is too long");const i=c=>/^[^\s@]+@[^\s@]+$/.test(c),s=n.indexOf("<"),a=n.lastIndexOf(">");if(s!==-1&&a!==-1&&a>s){const c=n.substring(s+1,a);if(i(c)){this.email=c;const u=n.substring(0,s).trim(),l=u.indexOf("("),h=u.lastIndexOf(")");l!==-1&&h!==-1&&h>l?(this.comment=u.substring(l+1,h).trim(),this.name=u.substring(0,l).trim()):(this.name=u,this.comment="")}}else i(n.trim())&&(this.email=n.trim(),this.name="",this.comment="");this.userID=n}write(){return y.encodeUTF8(this.userID)}equals(e){return e&&e.userID===this.userID}}class Jn extends Xn{static get tag(){return o.packet.secretSubkey}constructor(e=new Date,r=P){super(e,r)}}async function fa(t,e){const r=new Jn(t.date,e);return r.packets=null,r.algorithm=o.write(o.publicKey,t.algorithm),await r.generate(t.rsaBits,t.curve),await r.computeFingerprintAndKeyID(),r}async function nu(t,e){const r=new Xn(t.date,e);return r.packets=null,r.algorithm=o.write(o.publicKey,t.algorithm),await r.generate(t.rsaBits,t.curve,t.config),await r.computeFingerprintAndKeyID(),r}async function ae(t,e,r,n,i=new Date,s){let a,c;for(let u=t.length-1;u>=0;u--)try{(!a||t[u].created>=a.created)&&(await t[u].verify(e,r,n,i,void 0,s),a=t[u])}catch(l){c=l}if(!a)throw y.wrapError(`Could not find valid ${o.read(o.signature,r)} signature in key ${e.getKeyID().toHex()}`.replace("certGeneric ","self-").replace(/([a-z])([A-Z])/g,((u,l,h)=>l+" "+h.toLowerCase())),c);return a}function Pn(t,e,r=new Date){const n=y.normalizeDate(r);if(n!==null){const i=mr(t,e);return!(t.created<=n&&n<i)}return!1}async function ga(t,e,r,n){const i={};i.key=e,i.bind=t;const s={signatureType:o.signature.subkeyBinding};return r.sign?(s.keyFlags=[o.keyFlags.signData],s.embeddedSignature=await Le(i,[],t,{signatureType:o.signature.keyBinding},r.date,void 0,void 0,void 0,n)):s.keyFlags=[o.keyFlags.encryptCommunication|o.keyFlags.encryptStorage],r.keyExpirationTime>0&&(s.keyExpirationTime=r.keyExpirationTime,s.keyNeverExpires=!1),await Le(i,[],e,s,r.date,void 0,void 0,void 0,n)}async function iu(t,e,r=new Date,n=[],i){const s=o.hash.sha256,a=i.preferredHashAlgorithm,c=await Promise.all(t.map((async(p,g)=>(await p.getPrimarySelfSignature(r,n[g],i)).preferredHashAlgorithms||[]))),u=new Map;for(const p of c)for(const g of p)try{const f=o.write(o.hash,g);u.set(f,u.has(f)?u.get(f)+1:1)}catch{}const l=p=>t.length===0||u.get(p)===t.length||p===s,h=()=>{if(u.size===0)return s;const p=Array.from(u.keys()).filter((g=>l(g))).sort(((g,f)=>H(g)-H(f)))[0];return H(p)>=H(s)?p:s};if(new Set([o.publicKey.ecdsa,o.publicKey.eddsaLegacy,o.publicKey.ed25519,o.publicKey.ed448]).has(e.algorithm)){const p=(function(d,m){switch(d){case o.publicKey.ecdsa:case o.publicKey.eddsaLegacy:return Ys(m);case o.publicKey.ed25519:case o.publicKey.ed448:return Ur(d);default:throw Error("Unknown elliptic signing algo")}})(e.algorithm,e.publicParams.oid),g=l(a),f=H(a)>=H(p);if(g&&f)return a;{const d=h();return H(d)>=H(p)?d:p}}return l(a)?a:h()}async function Le(t,e,r,n,i,s,a=[],c=!1,u){if(r.isDummy())throw Error("Cannot sign with a gnu-dummy key.");if(!r.isDecrypted())throw Error("Signing key is not decrypted.");const l=new Be;return Object.assign(l,n),l.publicKeyAlgorithm=r.algorithm,l.hashAlgorithm=await iu(e,r,i,s,u),l.rawNotations=[...a],await l.sign(r,t,i,c,u),l}async function Ye(t,e,r,n=new Date,i){(t=t[r])&&(e[r].length?await Promise.all(t.map((async function(s){s.isExpired(n)||i&&!await i(s)||e[r].some((function(a){return y.equalsUint8Array(a.writeParams(),s.writeParams())}))||e[r].push(s)}))):e[r]=t)}async function bt(t,e,r,n,i,s,a=new Date,c){s=s||t;const u=[];return await Promise.all(n.map((async function(l){try{if(!i||l.issuerKeyID.equals(i.issuerKeyID)){const h=![o.reasonForRevocation.keyRetired,o.reasonForRevocation.keySuperseded,o.reasonForRevocation.userIDInvalid].includes(l.reasonForRevocationFlag);await l.verify(s,e,r,h?null:a,!1,c),u.push(l.issuerKeyID)}}catch{}}))),i?(i.revoked=!!u.some((l=>l.equals(i.issuerKeyID)))||i.revoked||!1,i.revoked):u.length>0}function mr(t,e){let r;return e.keyNeverExpires===!1&&(r=t.created.getTime()+1e3*e.keyExpirationTime),r?new Date(r):1/0}function Kn(t,e={}){switch(t.type=t.type||e.type,t.curve=t.curve||e.curve,t.rsaBits=t.rsaBits||e.rsaBits,t.keyExpirationTime=t.keyExpirationTime!==void 0?t.keyExpirationTime:e.keyExpirationTime,t.passphrase=y.isString(t.passphrase)?t.passphrase:e.passphrase,t.date=t.date||e.date,t.sign=t.sign||!1,t.type){case"ecc":try{t.curve=o.write(o.curve,t.curve)}catch{throw Error("Unknown curve")}t.curve!==o.curve.ed25519Legacy&&t.curve!==o.curve.curve25519Legacy&&t.curve!=="ed25519"&&t.curve!=="curve25519"||(t.curve=t.sign?o.curve.ed25519Legacy:o.curve.curve25519Legacy),t.sign?t.algorithm=t.curve===o.curve.ed25519Legacy?o.publicKey.eddsaLegacy:o.publicKey.ecdsa:t.algorithm=o.publicKey.ecdh;break;case"curve25519":t.algorithm=t.sign?o.publicKey.ed25519:o.publicKey.x25519;break;case"curve448":t.algorithm=t.sign?o.publicKey.ed448:o.publicKey.x448;break;case"rsa":t.algorithm=o.publicKey.rsaEncryptSign;break;default:throw Error("Unsupported key type "+t.type)}return t}function qi(t,e,r){switch(t.algorithm){case o.publicKey.rsaEncryptSign:case o.publicKey.rsaSign:case o.publicKey.dsa:case o.publicKey.ecdsa:case o.publicKey.eddsaLegacy:case o.publicKey.ed25519:case o.publicKey.ed448:if(!e.keyFlags&&!r.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");return!e.keyFlags||!!(e.keyFlags[0]&o.keyFlags.signData);default:return!1}}function Wi(t,e,r){switch(t.algorithm){case o.publicKey.rsaEncryptSign:case o.publicKey.rsaEncrypt:case o.publicKey.elgamal:case o.publicKey.ecdh:case o.publicKey.x25519:case o.publicKey.x448:if(!e.keyFlags&&!r.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");return!e.keyFlags||!!(e.keyFlags[0]&o.keyFlags.encryptCommunication)||!!(e.keyFlags[0]&o.keyFlags.encryptStorage);default:return!1}}function Vi(t,e,r){if(!e.keyFlags&&!r.allowMissingKeyFlags)throw Error("None of the key flags is set: consider passing `config.allowMissingKeyFlags`");switch(t.algorithm){case o.publicKey.rsaEncryptSign:case o.publicKey.rsaEncrypt:case o.publicKey.elgamal:case o.publicKey.ecdh:case o.publicKey.x25519:case o.publicKey.x448:return!(!(!e.keyFlags||e.keyFlags[0]&o.keyFlags.signData)||!r.allowInsecureDecryptionWithSigningKeys)||!e.keyFlags||!!(e.keyFlags[0]&o.keyFlags.encryptCommunication)||!!(e.keyFlags[0]&o.keyFlags.encryptStorage);default:return!1}}function He(t,e){const r=o.write(o.publicKey,t.algorithm),n=t.getAlgorithmInfo();if(e.rejectPublicKeyAlgorithms.has(r))throw Error(n.algorithm+" keys are considered too weak.");switch(r){case o.publicKey.rsaEncryptSign:case o.publicKey.rsaSign:case o.publicKey.rsaEncrypt:if(n.bits<e.minRSABits)throw Error(`RSA keys shorter than ${e.minRSABits} bits are considered too weak.`);break;case o.publicKey.ecdsa:case o.publicKey.eddsaLegacy:case o.publicKey.ecdh:if(e.rejectCurves.has(n.curve))throw Error(`Support for ${n.algorithm} keys using curve ${n.curve} is disabled.`)}}class Lt{constructor(e,r){this.userID=e.constructor.tag===o.packet.userID?e:null,this.userAttribute=e.constructor.tag===o.packet.userAttribute?e:null,this.selfCertifications=[],this.otherCertifications=[],this.revocationSignatures=[],this.mainKey=r}toPacketList(){const e=new ue;return e.push(this.userID||this.userAttribute),e.push(...this.revocationSignatures),e.push(...this.selfCertifications),e.push(...this.otherCertifications),e}clone(){const e=new Lt(this.userID||this.userAttribute,this.mainKey);return e.selfCertifications=[...this.selfCertifications],e.otherCertifications=[...this.otherCertifications],e.revocationSignatures=[...this.revocationSignatures],e}async certify(e,r,n){const i=this.mainKey.keyPacket,s={userID:this.userID,userAttribute:this.userAttribute,key:i},a=new Lt(s.userID||s.userAttribute,this.mainKey);return a.otherCertifications=await Promise.all(e.map((async function(c){if(!c.isPrivate())throw Error("Need private key for signing");if(c.hasSameFingerprintAs(i))throw Error("The user's own key can only be used for self-certifications");const u=await c.getSigningKey(void 0,r,void 0,n);return Le(s,[c],u.keyPacket,{signatureType:o.signature.certGeneric,keyFlags:[o.keyFlags.certifyKeys|o.keyFlags.signData]},r,void 0,void 0,void 0,n)}))),await a.update(this,r,n),a}async isRevoked(e,r,n=new Date,i=P){const s=this.mainKey.keyPacket;return bt(s,o.signature.certRevocation,{key:s,userID:this.userID,userAttribute:this.userAttribute},this.revocationSignatures,e,r,n,i)}async verifyCertificate(e,r,n=new Date,i){const s=this,a=this.mainKey.keyPacket,c={userID:this.userID,userAttribute:this.userAttribute,key:a},{issuerKeyID:u}=e,l=r.filter((h=>h.getKeys(u).length>0));return l.length===0?null:(await Promise.all(l.map((async h=>{const p=await h.getSigningKey(u,e.created,void 0,i);if(e.revoked||await s.isRevoked(e,p.keyPacket,n,i))throw Error("User certificate is revoked");try{await e.verify(p.keyPacket,o.signature.certGeneric,c,n,void 0,i)}catch(g){throw y.wrapError("User certificate is invalid",g)}}))),!0)}async verifyAllCertifications(e,r=new Date,n){const i=this,s=this.selfCertifications.concat(this.otherCertifications);return Promise.all(s.map((async a=>({keyID:a.issuerKeyID,valid:await i.verifyCertificate(a,e,r,n).catch((()=>!1))}))))}async verify(e=new Date,r){if(!this.selfCertifications.length)throw Error("No self-certifications found");const n=this,i=this.mainKey.keyPacket,s={userID:this.userID,userAttribute:this.userAttribute,key:i};let a;for(let c=this.selfCertifications.length-1;c>=0;c--)try{const u=this.selfCertifications[c];if(u.revoked||await n.isRevoked(u,void 0,e,r))throw Error("Self-certification is revoked");try{await u.verify(i,o.signature.certGeneric,s,e,void 0,r)}catch(l){throw y.wrapError("Self-certification is invalid",l)}return!0}catch(u){a=u}throw a}async update(e,r,n){const i=this.mainKey.keyPacket,s={userID:this.userID,userAttribute:this.userAttribute,key:i};await Ye(e,this,"selfCertifications",r,(async function(a){try{return await a.verify(i,o.signature.certGeneric,s,r,!1,n),!0}catch{return!1}})),await Ye(e,this,"otherCertifications",r),await Ye(e,this,"revocationSignatures",r,(function(a){return bt(i,o.signature.certRevocation,s,[a],void 0,void 0,r,n)}))}async revoke(e,{flag:r=o.reasonForRevocation.noReason,string:n=""}={},i=new Date,s=P){const a={userID:this.userID,userAttribute:this.userAttribute,key:e},c=new Lt(a.userID||a.userAttribute,this.mainKey);return c.revocationSignatures.push(await Le(a,[],e,{signatureType:o.signature.certRevocation,reasonForRevocationFlag:o.write(o.reasonForRevocation,r),reasonForRevocationString:n},i,void 0,void 0,!1,s)),await c.update(this),c}}class rt{constructor(e,r){this.keyPacket=e,this.bindingSignatures=[],this.revocationSignatures=[],this.mainKey=r}toPacketList(){const e=new ue;return e.push(this.keyPacket),e.push(...this.revocationSignatures),e.push(...this.bindingSignatures),e}clone(){const e=new rt(this.keyPacket,this.mainKey);return e.bindingSignatures=[...this.bindingSignatures],e.revocationSignatures=[...this.revocationSignatures],e}async isRevoked(e,r,n=new Date,i=P){const s=this.mainKey.keyPacket;return bt(s,o.signature.subkeyRevocation,{key:s,bind:this.keyPacket},this.revocationSignatures,e,r,n,i)}async verify(e=new Date,r=P){const n=this.mainKey.keyPacket,i={key:n,bind:this.keyPacket},s=await ae(this.bindingSignatures,n,o.signature.subkeyBinding,i,e,r);if(s.revoked||await this.isRevoked(s,null,e,r))throw Error("Subkey is revoked");if(Pn(this.keyPacket,s,e))throw Error("Subkey is expired");return s}async getExpirationTime(e=new Date,r=P){const n=this.mainKey.keyPacket,i={key:n,bind:this.keyPacket};let s;try{s=await ae(this.bindingSignatures,n,o.signature.subkeyBinding,i,e,r)}catch{return null}const a=mr(this.keyPacket,s),c=s.getExpirationTime();return a<c?a:c}async update(e,r=new Date,n=P){const i=this.mainKey.keyPacket;if(!this.hasSameFingerprintAs(e))throw Error("Subkey update method: fingerprints of subkeys not equal");this.keyPacket.constructor.tag===o.packet.publicSubkey&&e.keyPacket.constructor.tag===o.packet.secretSubkey&&(this.keyPacket=e.keyPacket);const s=this,a={key:i,bind:s.keyPacket};await Ye(e,this,"bindingSignatures",r,(async function(c){for(let u=0;u<s.bindingSignatures.length;u++)if(s.bindingSignatures[u].issuerKeyID.equals(c.issuerKeyID))return c.created>s.bindingSignatures[u].created&&(s.bindingSignatures[u]=c),!1;try{return await c.verify(i,o.signature.subkeyBinding,a,r,void 0,n),!0}catch{return!1}})),await Ye(e,this,"revocationSignatures",r,(function(c){return bt(i,o.signature.subkeyRevocation,a,[c],void 0,void 0,r,n)}))}async revoke(e,{flag:r=o.reasonForRevocation.noReason,string:n=""}={},i=new Date,s=P){const a={key:e,bind:this.keyPacket},c=new rt(this.keyPacket,this.mainKey);return c.revocationSignatures.push(await Le(a,[],e,{signatureType:o.signature.subkeyRevocation,reasonForRevocationFlag:o.write(o.reasonForRevocation,r),reasonForRevocationString:n},i,void 0,void 0,!1,s)),await c.update(this),c}hasSameFingerprintAs(e){return this.keyPacket.hasSameFingerprintAs(e.keyPacket||e)}}["getKeyID","getFingerprint","getAlgorithmInfo","getCreationTime","isDecrypted"].forEach((t=>{rt.prototype[t]=function(){return this.keyPacket[t]()}}));const su=y.constructAllowedPackets([Be]),Qi=new Set([o.packet.publicKey,o.packet.privateKey]),Zi=new Set([o.packet.publicKey,o.packet.privateKey,o.packet.publicSubkey,o.packet.privateSubkey]);class da{packetListToStructure(e,r=new Set){let n,i,s,a;for(const c of e){if(c instanceof hn){Zi.has(c.tag)&&!a&&(a=Qi.has(c.tag)?Qi:Zi);continue}const u=c.constructor.tag;if(a){if(!a.has(u))continue;a=null}if(r.has(u))throw Error("Unexpected packet type: "+u);switch(u){case o.packet.publicKey:case o.packet.secretKey:if(this.keyPacket)throw Error("Key block contains multiple keys");if(this.keyPacket=c,i=this.getKeyID(),!i)throw Error("Missing Key ID");break;case o.packet.userID:case o.packet.userAttribute:n=new Lt(c,this),this.users.push(n);break;case o.packet.publicSubkey:case o.packet.secretSubkey:n=null,s=new rt(c,this),this.subkeys.push(s);break;case o.packet.signature:switch(c.signatureType){case o.signature.certGeneric:case o.signature.certPersona:case o.signature.certCasual:case o.signature.certPositive:if(!n){y.printDebug("Dropping certification signatures without preceding user packet");continue}c.issuerKeyID.equals(i)?n.selfCertifications.push(c):n.otherCertifications.push(c);break;case o.signature.certRevocation:n?n.revocationSignatures.push(c):this.directSignatures.push(c);break;case o.signature.key:this.directSignatures.push(c);break;case o.signature.subkeyBinding:if(!s){y.printDebug("Dropping subkey binding signature without preceding subkey packet");continue}s.bindingSignatures.push(c);break;case o.signature.keyRevocation:this.revocationSignatures.push(c);break;case o.signature.subkeyRevocation:if(!s){y.printDebug("Dropping subkey revocation signature without preceding subkey packet");continue}s.revocationSignatures.push(c)}}}}toPacketList(){const e=new ue;return e.push(this.keyPacket),e.push(...this.revocationSignatures),e.push(...this.directSignatures),this.users.map((r=>e.push(...r.toPacketList()))),this.subkeys.map((r=>e.push(...r.toPacketList()))),e}clone(e=!1){const r=new this.constructor(this.toPacketList());return e&&r.getKeys().forEach((n=>{if(n.keyPacket=Object.create(Object.getPrototypeOf(n.keyPacket),Object.getOwnPropertyDescriptors(n.keyPacket)),!n.keyPacket.isDecrypted())return;const i={};Object.keys(n.keyPacket.privateParams).forEach((s=>{i[s]=new Uint8Array(n.keyPacket.privateParams[s])})),n.keyPacket.privateParams=i})),r}getSubkeys(e=null){return this.subkeys.filter((r=>!e||r.getKeyID().equals(e,!0)))}getKeys(e=null){const r=[];return e&&!this.getKeyID().equals(e,!0)||r.push(this),r.concat(this.getSubkeys(e))}getKeyIDs(){return this.getKeys().map((e=>e.getKeyID()))}getUserIDs(){return this.users.map((e=>e.userID?e.userID.userID:null)).filter((e=>e!==null))}write(){return this.toPacketList().write()}async getSigningKey(e=null,r=new Date,n={},i=P){await this.verifyPrimaryKey(r,n,i);const s=this.keyPacket;try{He(s,i)}catch(u){throw y.wrapError("Could not verify primary key",u)}const a=this.subkeys.slice().sort(((u,l)=>l.keyPacket.created-u.keyPacket.created||l.keyPacket.algorithm-u.keyPacket.algorithm));let c;for(const u of a)if(!e||u.getKeyID().equals(e))try{await u.verify(r,i);const l={key:s,bind:u.keyPacket},h=await ae(u.bindingSignatures,s,o.signature.subkeyBinding,l,r,i);if(!qi(u.keyPacket,h,i))continue;if(!h.embeddedSignature)throw Error("Missing embedded signature");return await ae([h.embeddedSignature],u.keyPacket,o.signature.keyBinding,l,r,i),He(u.keyPacket,i),u}catch(l){c=l}try{const u=await this.getPrimarySelfSignature(r,n,i);if((!e||s.getKeyID().equals(e))&&qi(s,u,i))return He(s,i),this}catch(u){c=u}throw y.wrapError("Could not find valid signing key packet in key "+this.getKeyID().toHex(),c)}async getEncryptionKey(e,r=new Date,n={},i=P){await this.verifyPrimaryKey(r,n,i);const s=this.keyPacket;try{He(s,i)}catch(u){throw y.wrapError("Could not verify primary key",u)}const a=this.subkeys.slice().sort(((u,l)=>l.keyPacket.created-u.keyPacket.created||l.keyPacket.algorithm-u.keyPacket.algorithm));let c;for(const u of a)if(!e||u.getKeyID().equals(e))try{await u.verify(r,i);const l={key:s,bind:u.keyPacket},h=await ae(u.bindingSignatures,s,o.signature.subkeyBinding,l,r,i);if(Wi(u.keyPacket,h,i))return He(u.keyPacket,i),u}catch(l){c=l}try{const u=await this.getPrimarySelfSignature(r,n,i);if((!e||s.getKeyID().equals(e))&&Wi(s,u,i))return He(s,i),this}catch(u){c=u}throw y.wrapError("Could not find valid encryption key packet in key "+this.getKeyID().toHex(),c)}async isRevoked(e,r,n=new Date,i=P){return bt(this.keyPacket,o.signature.keyRevocation,{key:this.keyPacket},this.revocationSignatures,e,r,n,i)}async verifyPrimaryKey(e=new Date,r={},n=P){const i=this.keyPacket;if(await this.isRevoked(null,null,e,n))throw Error("Primary key is revoked");if(Pn(i,await this.getPrimarySelfSignature(e,r,n),e))throw Error("Primary key is expired");if(i.version!==6){const s=await ae(this.directSignatures,i,o.signature.key,{key:i},e,n).catch((()=>{}));if(s&&Pn(i,s,e))throw Error("Primary key is expired")}}async getExpirationTime(e,r=P){let n;try{const i=await this.getPrimarySelfSignature(null,e,r),s=mr(this.keyPacket,i),a=i.getExpirationTime(),c=this.keyPacket.version!==6&&await ae(this.directSignatures,this.keyPacket,o.signature.key,{key:this.keyPacket},null,r).catch((()=>{}));if(c){const u=mr(this.keyPacket,c);n=Math.min(s,a,u)}else n=s<a?s:a}catch{n=null}return y.normalizeDate(n)}async getPrimarySelfSignature(e=new Date,r={},n=P){const i=this.keyPacket;if(i.version===6)return ae(this.directSignatures,i,o.signature.key,{key:i},e,n);const{selfCertification:s}=await this.getPrimaryUser(e,r,n);return s}async getPrimaryUser(e=new Date,r={},n=P){const i=this.keyPacket,s=[];let a;for(let h=0;h<this.users.length;h++)try{const p=this.users[h];if(!p.userID)continue;if(r.name!==void 0&&p.userID.name!==r.name||r.email!==void 0&&p.userID.email!==r.email||r.comment!==void 0&&p.userID.comment!==r.comment)throw Error("Could not find user that matches that user ID");const g={userID:p.userID,key:i},f=await ae(p.selfCertifications,i,o.signature.certGeneric,g,e,n);s.push({index:h,user:p,selfCertification:f})}catch(p){a=p}if(!s.length)throw a||Error("Could not find primary user");await Promise.all(s.map((async h=>{h.selfCertification.revoked||await h.user.isRevoked(h.selfCertification,null,e,n)})));const c=s.sort((function(h,p){const g=h.selfCertification,f=p.selfCertification;return f.revoked-g.revoked||g.isPrimaryUserID-f.isPrimaryUserID||g.created-f.created})).pop(),{user:u,selfCertification:l}=c;if(l.revoked||await u.isRevoked(l,null,e,n))throw Error("Primary user is revoked");return c}async update(e,r=new Date,n=P){if(!this.hasSameFingerprintAs(e))throw Error("Primary key fingerprints must be equal to update the key");if(!this.isPrivate()&&e.isPrivate()){if(!(this.subkeys.length===e.subkeys.length&&this.subkeys.every((s=>e.subkeys.some((a=>s.hasSameFingerprintAs(a)))))))throw Error("Cannot update public key with private key if subkeys mismatch");return e.update(this,n)}const i=this.clone();return await Ye(e,i,"revocationSignatures",r,(s=>bt(i.keyPacket,o.signature.keyRevocation,i,[s],null,e.keyPacket,r,n))),await Ye(e,i,"directSignatures",r),await Promise.all(e.users.map((async s=>{const a=i.users.filter((c=>s.userID&&s.userID.equals(c.userID)||s.userAttribute&&s.userAttribute.equals(c.userAttribute)));if(a.length>0)await Promise.all(a.map((c=>c.update(s,r,n))));else{const c=s.clone();c.mainKey=i,i.users.push(c)}}))),await Promise.all(e.subkeys.map((async s=>{const a=i.subkeys.filter((c=>c.hasSameFingerprintAs(s)));if(a.length>0)await Promise.all(a.map((c=>c.update(s,r,n))));else{const c=s.clone();c.mainKey=i,i.subkeys.push(c)}}))),i}async getRevocationCertificate(e=new Date,r=P){const n={key:this.keyPacket},i=await ae(this.revocationSignatures,this.keyPacket,o.signature.keyRevocation,n,e,r),s=new ue;s.push(i);const a=this.keyPacket.version!==6;return Fn(o.armor.publicKey,s.write(),null,null,"This is a revocation certificate",a,r)}async applyRevocationCertificate(e,r=new Date,n=P){const i=await Ts(e),s=(await ue.fromBinary(i.data,su,n)).findPacket(o.packet.signature);if(!s||s.signatureType!==o.signature.keyRevocation)throw Error("Could not find revocation signature packet");if(!s.issuerKeyID.equals(this.getKeyID()))throw Error("Revocation signature does not match key");try{await s.verify(this.keyPacket,o.signature.keyRevocation,{key:this.keyPacket},r,void 0,n)}catch(c){throw y.wrapError("Could not verify revocation signature",c)}const a=this.clone();return a.revocationSignatures.push(s),a}async signPrimaryUser(e,r,n,i=P){const{index:s,user:a}=await this.getPrimaryUser(r,n,i),c=await a.certify(e,r,i),u=this.clone();return u.users[s]=c,u}async signAllUsers(e,r=new Date,n=P){const i=this.clone();return i.users=await Promise.all(this.users.map((function(s){return s.certify(e,r,n)}))),i}async verifyPrimaryUser(e,r=new Date,n,i=P){const s=this.keyPacket,{user:a}=await this.getPrimaryUser(r,n,i);return e?await a.verifyAllCertifications(e,r,i):[{keyID:s.getKeyID(),valid:await a.verify(r,i).catch((()=>!1))}]}async verifyAllUsers(e,r=new Date,n=P){const i=this.keyPacket,s=[];return await Promise.all(this.users.map((async a=>{const c=e?await a.verifyAllCertifications(e,r,n):[{keyID:i.getKeyID(),valid:await a.verify(r,n).catch((()=>!1))}];s.push(...c.map((u=>({userID:a.userID?a.userID.userID:null,userAttribute:a.userAttribute,keyID:u.keyID,valid:u.valid}))))}))),s}}["getKeyID","getFingerprint","getAlgorithmInfo","getCreationTime","hasSameFingerprintAs"].forEach((t=>{da.prototype[t]=rt.prototype[t]}));class Xi extends da{constructor(e){if(super(),this.keyPacket=null,this.revocationSignatures=[],this.directSignatures=[],this.users=[],this.subkeys=[],e&&(this.packetListToStructure(e,new Set([o.packet.secretKey,o.packet.secretSubkey])),!this.keyPacket))throw Error("Invalid key: missing public-key packet")}isPrivate(){return!1}toPublic(){return this}armor(e=P){const r=this.keyPacket.version!==6;return Fn(o.armor.publicKey,this.toPacketList().write(),void 0,void 0,void 0,r,e)}}class Or extends Xi{constructor(e){if(super(),this.packetListToStructure(e,new Set([o.packet.publicKey,o.packet.publicSubkey])),!this.keyPacket)throw Error("Invalid key: missing private-key packet")}isPrivate(){return!0}toPublic(){const e=new ue,r=this.toPacketList();for(const n of r)switch(n.constructor.tag){case o.packet.secretKey:{const i=Se.fromSecretKeyPacket(n);e.push(i);break}case o.packet.secretSubkey:{const i=Fr.fromSecretSubkeyPacket(n);e.push(i);break}default:e.push(n)}return new Xi(e)}armor(e=P){const r=this.keyPacket.version!==6;return Fn(o.armor.privateKey,this.toPacketList().write(),void 0,void 0,void 0,r,e)}async getDecryptionKeys(e,r=new Date,n={},i=P){const s=this.keyPacket,a=[];let c=null;for(let l=0;l<this.subkeys.length;l++)if(!e||this.subkeys[l].getKeyID().equals(e,!0)){if(this.subkeys[l].keyPacket.isDummy()){c=c||Error("Gnu-dummy key packets cannot be used for decryption");continue}try{const h={key:s,bind:this.subkeys[l].keyPacket},p=await ae(this.subkeys[l].bindingSignatures,s,o.signature.subkeyBinding,h,r,i);Vi(this.subkeys[l].keyPacket,p,i)&&a.push(this.subkeys[l])}catch(h){c=h}}const u=await this.getPrimarySelfSignature(r,n,i);if(e&&!s.getKeyID().equals(e,!0)||!Vi(s,u,i)||(s.isDummy()?c=c||Error("Gnu-dummy key packets cannot be used for decryption"):a.push(this)),a.length===0)throw c||Error("No decryption key packets found");return a}isDecrypted(){return this.getKeys().some((({keyPacket:e})=>e.isDecrypted()))}async validate(e=P){if(!this.isPrivate())throw Error("Cannot validate a public key");let r;if(this.keyPacket.isDummy()){const n=await this.getSigningKey(null,null,void 0,{...e,rejectPublicKeyAlgorithms:new Set,minRSABits:0});n&&!n.keyPacket.isDummy()&&(r=n.keyPacket)}else r=this.keyPacket;if(r)return r.validate();{const n=this.getKeys();if(n.map((i=>i.keyPacket.isDummy())).every(Boolean))throw Error("Cannot validate an all-gnu-dummy key");return Promise.all(n.map((i=>i.keyPacket.validate())))}}clearPrivateParams(){this.getKeys().forEach((({keyPacket:e})=>{e.isDecrypted()&&e.clearPrivateParams()}))}async revoke({flag:e=o.reasonForRevocation.noReason,string:r=""}={},n=new Date,i=P){if(!this.isPrivate())throw Error("Need private key for revoking");const s={key:this.keyPacket},a=this.clone();return a.revocationSignatures.push(await Le(s,[],this.keyPacket,{signatureType:o.signature.keyRevocation,reasonForRevocationFlag:o.write(o.reasonForRevocation,e),reasonForRevocationString:r},n,void 0,void 0,void 0,i)),a}async addSubkey(e={}){const r={...P,...e.config};if(e.passphrase)throw Error("Subkey could not be encrypted here, please encrypt whole key");if(e.rsaBits<r.minRSABits)throw Error(`rsaBits should be at least ${r.minRSABits}, got: ${e.rsaBits}`);const n=this.keyPacket;if(n.isDummy())throw Error("Cannot add subkey to gnu-dummy primary key");if(!n.isDecrypted())throw Error("Key is not decrypted");const i=n.getAlgorithmInfo();i.type=(function(u){switch(o.write(o.publicKey,u)){case o.publicKey.rsaEncrypt:case o.publicKey.rsaEncryptSign:case o.publicKey.rsaSign:case o.publicKey.dsa:return"rsa";case o.publicKey.ecdsa:case o.publicKey.eddsaLegacy:return"ecc";case o.publicKey.ed25519:return"curve25519";case o.publicKey.ed448:return"curve448";default:throw Error("Unsupported algorithm")}})(i.algorithm),i.rsaBits=i.bits||4096,i.curve=i.curve||"curve25519Legacy",e=Kn(e,i);const s=await fa(e,{...r,v6Keys:this.keyPacket.version===6});He(s,r);const a=await ga(s,n,e,r),c=this.toPacketList();return c.push(s,a),new Or(c)}}const au=y.constructAllowedPackets([Se,Fr,Xn,Jn,Rr,Zn,Be]);async function ma(t,e,r,n){r.passphrase&&await t.encrypt(r.passphrase,n),await Promise.all(e.map((async function(u,l){const h=r.subkeys[l].passphrase;h&&await u.encrypt(h,n)})));const i=new ue;function s(u,l){return[l,...u.filter((h=>h!==l))]}function a(){const u={};u.keyFlags=[o.keyFlags.certifyKeys|o.keyFlags.signData];const l=s([o.symmetric.aes256,o.symmetric.aes128],n.preferredSymmetricAlgorithm);if(u.preferredSymmetricAlgorithms=l,n.aeadProtect){const h=s([o.aead.gcm,o.aead.eax,o.aead.ocb],n.preferredAEADAlgorithm);u.preferredCipherSuites=h.flatMap((p=>l.map((g=>[g,p]))))}return u.preferredHashAlgorithms=s([o.hash.sha512,o.hash.sha256,o.hash.sha3_512,o.hash.sha3_256],n.preferredHashAlgorithm),u.preferredCompressionAlgorithms=s([o.compression.uncompressed,o.compression.zlib,o.compression.zip],n.preferredCompressionAlgorithm),u.features=[0],u.features[0]|=o.features.modificationDetection,n.aeadProtect&&(u.features[0]|=o.features.seipdv2),r.keyExpirationTime>0&&(u.keyExpirationTime=r.keyExpirationTime,u.keyNeverExpires=!1),u}if(i.push(t),t.version===6){const u={key:t},l=a();l.signatureType=o.signature.key;const h=await Le(u,[],t,l,r.date,void 0,void 0,void 0,n);i.push(h)}await Promise.all(r.userIDs.map((async function(u,l){const h=Rr.fromObject(u),p={userID:h,key:t},g=t.version!==6?a():{};return g.signatureType=o.signature.certPositive,l===0&&(g.isPrimaryUserID=!0),{userIDPacket:h,signaturePacket:await Le(p,[],t,g,r.date,void 0,void 0,void 0,n)}}))).then((u=>{u.forEach((({userIDPacket:l,signaturePacket:h})=>{i.push(l),i.push(h)}))})),await Promise.all(e.map((async function(u,l){const h=r.subkeys[l];return{secretSubkeyPacket:u,subkeySignaturePacket:await ga(u,t,h,n)}}))).then((u=>{u.forEach((({secretSubkeyPacket:l,subkeySignaturePacket:h})=>{i.push(l),i.push(h)}))}));const c={key:t};return i.push(await Le(c,[],t,{signatureType:o.signature.keyRevocation,reasonForRevocationFlag:o.reasonForRevocation.noReason,reasonForRevocationString:""},r.date,void 0,void 0,void 0,n)),r.passphrase&&t.clearPrivateParams(),e.map((function(u,l){r.subkeys[l].passphrase&&u.clearPrivateParams()})),new Or(i)}async function wa({armoredKey:t,binaryKey:e,config:r,...n}){if(r={...P,...r},!t&&!e)throw Error("readPrivateKey: must pass options object containing `armoredKey` or `binaryKey`");if(t&&!y.isString(t))throw Error("readPrivateKey: options.armoredKey must be a string");if(e&&!y.isUint8Array(e))throw Error("readPrivateKey: options.binaryKey must be a Uint8Array");const i=Object.keys(n);if(i.length>0)throw Error("Unknown option: "+i.join(", "));let s;if(t){const{type:u,data:l}=await Ts(t);if(u!==o.armor.privateKey)throw Error("Armored text not of type private key");s=l}else s=e;const a=await ue.fromBinary(s,au,r),c=a.indexOfTag(o.packet.publicKey,o.packet.secretKey);for(let u=0;u<c.length;u++){if(a[c[u]].constructor.tag===o.packet.publicKey)continue;const l=a.slice(c[u],c[u+1]);return new Or(l)}throw Error("No secret key packet found")}async function ou({userIDs:t=[],passphrase:e,type:r,curve:n,rsaBits:i=4096,keyExpirationTime:s=0,date:a=new Date,subkeys:c=[{}],format:u="armored",config:l,...h}){ka(l={...P,...l}),r||n?(r=r||"ecc",n=n||"curve25519Legacy"):(r=l.v6Keys?"curve25519":"ecc",n="curve25519Legacy"),t=va(t);const p=Object.keys(h);if(p.length>0)throw Error("Unknown option: "+p.join(", "));if(t.length===0&&!l.v6Keys)throw Error("UserIDs are required for V4 keys");if(r==="rsa"&&i<l.minRSABits)throw Error(`rsaBits should be at least ${l.minRSABits}, got: ${i}`);const g={userIDs:t,passphrase:e,type:r,rsaBits:i,curve:n,keyExpirationTime:s,date:a,subkeys:c};try{const{key:f,revocationCertificate:d}=await(async function(m,w){m.sign=!0,(m=Kn(m)).subkeys=m.subkeys.map(((E,D)=>Kn(m.subkeys[D],m)));let b=[nu(m,w)];b=b.concat(m.subkeys.map((E=>fa(E,w))));const k=await Promise.all(b),v=await ma(k[0],k.slice(1),m,w),A=await v.getRevocationCertificate(m.date,w);return v.revocationSignatures=[],{key:v,revocationCertificate:A}})(g,l);return f.getKeys().forEach((({keyPacket:m})=>He(m,l))),{privateKey:wr(f,u,l),publicKey:wr(f.toPublic(),u,l),revocationCertificate:d}}catch(f){throw y.wrapError("Error generating keypair",f)}}async function ba({privateKey:t,userIDs:e=[],passphrase:r,keyExpirationTime:n=0,date:i,format:s="armored",config:a,...c}){ka(a={...P,...a}),e=va(e);const u=Object.keys(c);if(u.length>0)throw Error("Unknown option: "+u.join(", "));if(e.length===0&&t.keyPacket.version!==6)throw Error("UserIDs are required for V4 keys");const l={privateKey:t,userIDs:e,passphrase:r,keyExpirationTime:n,date:i};try{const{key:h,revocationCertificate:p}=await(async function(g,f){g=v(g);const{privateKey:d}=g;if(!d.isPrivate())throw Error("Cannot reformat a public key");if(d.keyPacket.isDummy())throw Error("Cannot reformat a gnu-dummy primary key");if(!d.getKeys().every((({keyPacket:A})=>A.isDecrypted())))throw Error("Key is not decrypted");const m=d.keyPacket;g.subkeys||(g.subkeys=await Promise.all(d.subkeys.map((async A=>{const E=A.keyPacket,D={key:m,bind:E},S=await ae(A.bindingSignatures,m,o.signature.subkeyBinding,D,null,f).catch((()=>({})));return{sign:S.keyFlags&&S.keyFlags[0]&o.keyFlags.signData}}))));const w=d.subkeys.map((A=>A.keyPacket));if(g.subkeys.length!==w.length)throw Error("Number of subkey options does not match number of subkeys");g.subkeys=g.subkeys.map((A=>v(A,g)));const b=await ma(m,w,g,f),k=await b.getRevocationCertificate(g.date,f);return b.revocationSignatures=[],{key:b,revocationCertificate:k};function v(A,E={}){return A.keyExpirationTime=A.keyExpirationTime||E.keyExpirationTime,A.passphrase=y.isString(A.passphrase)?A.passphrase:E.passphrase,A.date=A.date||E.date,A}})(l,a);return{privateKey:wr(h,s,a),publicKey:wr(h.toPublic(),s,a),revocationCertificate:p}}catch(h){throw y.wrapError("Error reformatting keypair",h)}}const cu=Object.keys(P).length;function ka(t){const e=Object.keys(t);if(e.length!==cu){for(const r of e)if(P[r]===void 0)throw Error("Unknown config property: "+r)}}function va(t){return t&&!y.isArray(t)&&(t=[t]),t}function wr(t,e,r){switch(e){case"object":return t;case"armored":return t.armor(r);case"binary":return t.write();default:throw Error("Unsupported format "+e)}}const uu=new TextEncoder,Aa=t=>uu.encode(t);new TextDecoder;function lu(t){return typeof t=="string"?Aa(t).buffer:t instanceof ArrayBuffer?t:ArrayBuffer.isView(t)?new Uint8Array(t).buffer:t.arrayBuffer()}let Un=(function(t){return t[t.File=0]="File",t[t.Dir=53]="Dir",t})({});class hu{#e;constructor(){this.#e=[]}addFile(e,r,n){const i=lu(r),s=i.byteLength??r.size,a={name:e,type:Un.File,data:i,size:s,opts:n};this.#e.push(a)}addFolder(e,r){this.#e.push({name:e,type:Un.Dir,data:null,size:0,opts:r})}async write(){const e=yu(this.#e),r=new Uint8Array(e);let n=0;for(const i of this.#e){pu(e,i.name,n),fu(e,i.type,n),gu(e,i.size,n),Eu(e,n,i.opts,i.type),Au(e,n);const s=await i.data;if(s){const a=new Uint8Array(s);r.set(a,n+512)}n+=512+512*Math.floor((i.size+511)/512)}return new Blob([e],{type:"application/x-tar"})}}function yu(t){const e=t.reduce((n,i)=>n+512+512*Math.floor((i.size+511)/512),0),r=10240*Math.floor((e+10240-1)/10240);return new ArrayBuffer(r)}function fe(t,e,r,n){const i=Aa(e),s=new Uint8Array(t,r,n);for(let a=0;a<n;a+=1)s[a]=a<i.length?i[a]:0}function pu(t,e,r){fe(t,e,r,100)}function fu(t,e,r){const n=new Uint8Array(t,r+156,1);n[0]=e}function gu(t,e,r){const n=e.toString(8).padStart(11,"0");fe(t,n,r+124,12)}function du(t,e,r){fe(t,e.toString(8).padStart(7,"0"),r+100,8)}function mu(t,e,r){fe(t,e.toString(8).padStart(7,"0"),r+108,8)}function wu(t,e,r){fe(t,e.toString(8).padStart(7,"0"),r+116,8)}function bu(t,e,r){fe(t,e.toString(8).padStart(11,"0"),r+136,12)}function ku(t,e,r){fe(t,e,r+265,32)}function vu(t,e,r){fe(t,e,r+297,32)}function Au(t,e){const r=new Uint8Array(t,e,512);for(let i=0;i<8;i+=1)r[148+i]=32;let n=0;for(let i=0;i<512;i+=1)n+=r[i];fe(t,n.toString(8).padEnd(8," "),e+148,8)}function Eu(t,e,r,n){const{uid:i,gid:s,mode:a,mtime:c,user:u,group:l}={uid:1e3,gid:1e3,mode:n===Un.File?436:509,mtime:~~(Date.now()/1e3),user:"gera2ld",group:"tarjs",...r};du(t,a,e),mu(t,i,e),wu(t,s,e),bu(t,c,e),fe(t,"ustar",e+257,6),fe(t,"00",e+263,2),ku(t,u,e),vu(t,l,e)}const Su=`#version 300 es
in vec4 pos;void main(){gl_Position=pos;}`,Pu=`#version 300 es
precision highp float;precision highp int;
#define ROTL(x,n)(((x)<<(n))|((x)>>(32-(n))))
#define __INJECTS__
#ifdef __INJECTS__
#define LENGTH (0)
#define FILTER(h)(false)
#endif
uniform uint width,height,iteration,hashData[LENGTH];out vec4 outColor;void main(){uint i[LENGTH];for(int f=0;f<LENGTH;f++)i[f]=hashData[f];uint u=i[1],f=width*height;for(uint h=0u;h<iteration;h++){i[1]=u-h*f-uint(gl_FragCoord.x)-uint(gl_FragCoord.y)*width;if(i[1]>u)break;uint n[]=uint[](1732584193u,4023233417u,2562383102u,271733878u,3285377520u);for(int f=0;f<LENGTH/16;f++){uint h[80];for(int n=0;n<16;n++)h[n]=i[f*16+n];for(int f=16;f<80;f++)h[f]=ROTL(h[f-3]^h[f-8]^h[f-14]^h[f-16],1);uint u=n[0],t=n[1],R=n[2],r=n[3],v=n[4],x,C,H;for(int f=0;f<80;f++)C=f<20?x=r^t&(R^r),1518500249u:f<40?x=t^R^r,1859775393u:f<60?x=t&R|t&r|R&r,2400959708u:(x=t^R^r,3395469782u),H=ROTL(u,5)+x+v+C+h[f],v=r,r=R,R=ROTL(t,30),t=u,u=H;n[0]+=u;n[1]+=t;n[2]+=R;n[3]+=r;n[4]+=v;}if(FILTER(n)){outColor=vec4(float(i[1]>>0&255u)/255.,float(i[1]>>8&255u)/255.,float(i[1]>>16&255u)/255.,float(i[1]>>24&255u)/255.);return;}}outColor=vec4(0);}`,Ku=async(t,e)=>(t=await wa({armoredKey:t.armor()}),await Promise.all([t.keyPacket,...t.subkeys.map(r=>r.keyPacket)].map(r=>(r.created=e,r.computeFingerprintAndKeyID()))),await ba({privateKey:t,userIDs:t.users.map(r=>r.userID),date:e,format:"object"})),Uu=t=>((t&255)<<24|(t&65280)<<8|t>>8&65280|t>>24&255)>>>0,Ji=t=>{if(t=t.replaceAll(" ",""),t.length!=40)throw new Error("Invalid pattern");return[...[0,8,16,24,32].map((e,r)=>{const n=t.substring(e,e+8);let i="",s="",a=!1;for(let c=0;c<8;c++)n[c].match(/[\da-f]/gi)?(i+="F",s+=n[c].toUpperCase(),a=!0):(i+="0",s+="0");return a?`(h[${r}] & 0x${i}u) == 0x${s}u`:""}),...t.split("").map((e,r)=>e.toUpperCase()==="X"?r:null).filter(Boolean).reduce((e,r,n,i)=>{const s=Math.floor(i[n-1]/8),a=Math.floor(r/8),c=7-i[n-1]%8,u=7-r%8;return n&&e.push(`((h[${s}] ${u>c?"<<":">>"} ${Math.abs(u-c)*4}) & 0xF${"0".repeat(u)}u) == (h[${a}] & 0xF${"0".repeat(u)}u)`),e},[])].filter(Boolean).join(" && ")||"true"},Du=async(t,e,r,n,i=()=>{},s=()=>!1,a=!1)=>{const c=Math.round(Math.sqrt(r)),u=new OffscreenCanvas(c,c),l=u.getContext("webgl2");let h=!1,p,g,f=new Uint8Array,d=new Uint8Array,m=new ArrayBuffer(0),w=new Uint8Array,b=new Uint32Array;const k=new ArrayBuffer(u.width*u.height*4),v=new Uint8Array(k),A=new Uint32Array(k);let E=0;const D=performance.now();return await new Promise((S,I)=>{const x=async()=>{try{if(l.isContextLost())throw new Error("WebGL context lost");const U=await ou({...t,format:"object"});if(f=(a?U.publicKey.subkeys[0]:U.publicKey).keyPacket.write(),!h){d=new Uint8Array(f.length+3),d[0]=153,m=new ArrayBuffer(Math.ceil((d.length+1+8)/64)*64),w=new Uint8Array(m),b=new Uint32Array(m);const M=l.createShader(l.VERTEX_SHADER),Q=l.createShader(l.FRAGMENT_SHADER);l.shaderSource(M,Su),l.shaderSource(Q,Pu.replaceAll("#define __INJECTS__",Object.entries({"FILTER(h)":e,LENGTH:b.length}).map(([me,Ea])=>`#define ${me} (${Ea})`).join(`
`))),l.compileShader(M),l.compileShader(Q),p=l.createProgram(),l.attachShader(p,M),l.attachShader(p,Q),l.linkProgram(p),l.useProgram(p),l.uniform1ui(l.getUniformLocation(p,"width"),u.width),l.uniform1ui(l.getUniformLocation(p,"height"),u.height),l.uniform1ui(l.getUniformLocation(p,"iteration"),n),g=l.getUniformLocation(p,"hashData");const de=l.getAttribLocation(p,"pos");l.enableVertexAttribArray(de),l.bindBuffer(l.ARRAY_BUFFER,l.createBuffer()),l.bufferData(l.ARRAY_BUFFER,new Float32Array([-1,-1,1,-1,-1,1,-1,1,1,-1,1,1]),l.STATIC_DRAW),l.vertexAttribPointer(de,2,l.FLOAT,!1,0,0),l.clearColor(0,0,0,0),l.clear(l.COLOR_BUFFER_BIT),h=!0}d.set([f.length>>8&255,f.length&255],1),d.set(f,3),b[d.length>>2]=0,w.set(d),w[d.length]=128;for(let M=0;M<b.length;M++)b[M]=Uu(b[M]);b[b.length-1]=d.length*8,l.uniform1uiv(g,b);let C=0;l.drawArrays(l.TRIANGLES,0,6),l.readPixels(0,0,u.width,u.height,l.RGBA,l.UNSIGNED_BYTE,v);for(let M=0;M<A.length;M++)if(A[M]){C=A[M];break}E+=Math.min(Math.floor(Date.now()/1e3),c*c*n),i(E,performance.now()-D),C?S(await Ku(U.privateKey,new Date(C*1e3))):s(E,performance.now()-D)?S(void 0):setTimeout(x,0)}catch(U){I(U)}};setTimeout(x,0)})},Iu="data:audio/ogg;base64,T2dnUwACAAAAAAAAAACINwAAAAAAACdKrQABE09wdXNIZWFkAQI4AUSsAAAAAABPZ2dTAAAAAAAAAAAAAIg3AAABAAAAIhsOmgFPT3B1c1RhZ3M/AAAAbGlib3B1cyAxLjMuMS0xNTgtZ2JjZTFmMzkyLCBsaWJvcHVzZW5jIDAuMi4xLTE0LWdmNTFjM2FhLWRpcnR5AAAAAE9nZ1MAAIC7AAAAAAAAiDcAAAIAAACCtYTOMg4gJy0SFCoqJCgnICkgIyEiIyMhHSMeIyQiHSAfJCEeIR0cIyAgICEeHSMgIB0eIxkbaAvkwTbsxY2MSUhCbNBIgAJ/wFoICGrVNJtHGCG/y4s/cumjd1AWCabaS3AFEEiI7GedO4W8JnSetfb2Fj6YqIF6R51/9u27fA2k5e6CLlI3jOuB4UiJGwo1HXqrfyG9u5taxt7BQQrzkNEA+2yDZ/EErNUcegIwdV/qPHZ8IG31UEiHODQDlzIIkEtVbiIYnIxXgEiAFKWvb3VlJyWmK55ukQUS8siASJZQ6mX5ZBEnKZqAchhAj5K3bP7JpfBvNOX/bY/3lq6EdUxUhmEHOFvoSJbwjXoxmahW3m+vwOgqId2wwcyyhJQ3DG2IY6ORVhva3OqfwAJA52rASLv4jqS7JF1eh8COgxXe+HVhNXu/25Qg6YKyIqx187oD6HZoSLvtJdwp6y3+Gbh6LFzr1lBdqjMtOyL+k+mFClHYtD5akgrRY/o8QEi6adWe9/jbxJnMPWqrbpZJpkModt26Uhphz4M0SHPqEHWQnawzgEi4ogZwIJ2aIKXW5K9BYctvIjgscm2cMqOLdtn4NUpNSL/SG1iVDV1Q5ZIrrk0uLAoZmEnQV8pD+/FkfrUb4WAfzm1QQ5m+/41IvFvSWCFZ++zIrDyiWWMXyz/JE5q3nef/sVCJPIo5gEi8dV7hVX+rOCf+nw4RVvpbnmgNp67qWON8M3TOykJAERTwSLxx7HehY+s2BJEbMDrOaGBwq/VtMwJ2eNPoNeCaoF0WSLxLuxN6OiutnkZLsttnLVMd+gKFFJheKSoDY39S+Ur47ki8S7ggGj1AGmwm21DBm0yL+h0+3M10k2rO10evE+9c4qkoSLxPwFSoTHqnDwchwB6lxMoSwr4tLqXD2PsNVD7WUMsuUBRIvErhwhRm6UnUgkl3d6KBtnHkI2sSuWNP0LXQCMWF3YBIvCt9njPNoJlRKkRpPqitu1diIoH9pI4Izg6UqUi8JBWSpaHnjpLew2HHmiKvO2+P3h5vpoFAoDe+OjpEFyiASLwiAdx0xx+AWE6BngXUIseW3ufd8HPCEcThRnqsSLwiF/IcPciRVNPuT6t+wh0tchO8dhwVQS2pC5j056dMj3BIvDHM2EsjmAWx5Bd6R0pF+TUdMAp2NSOsVLto8W773mv+KoBIvCIYQwp79V2avQIZObZT6IuN8b2a2H/YDPBya+OTY99NSLwrih5EQhPMMqLNxhO4jVqJSlskqmmDIDjlIOBIvFAUr4lFBtcggWnjv/cnlEhVXPCoyG+6AeolrzLDfUi8Th2MEP1gTcKxYD313QqIAcxP0LlXbqOCCys1mVZIvCgeVsJkOxJl+Nu5TCe7xoyRZ4hVaoUpuRBV7Yi0OfmyOEBIvHflNd2ykBP8d1rbL7+dlicbCZic0GPibE7g4ak6LCNIvGvwr3ntZE9w5nmitSy4u9OUNVoQxwPQ1daaAPBIvE5GwQK7d22cloq84jsYdsrB0i6gbbgzGsqVxONHhfBIvEJJApUlCeozT9ShtB+7FmB4qXrff+lXwmNhIEi8GGhC5uyW/+iwMB2PW3NEvm4NYCVoIDkIuw5Iu/57jlP/ZlbAxQ5x26Mcxwpp9PvGPQm0WCn4ZDCw/lnFwEi8HcMkULO43Jq53iwK+o5rZvm4ZDlnApocvrMOd+zCSLv6u44YqwupV4XiU/hS3MRQpEipmzZTIjEvlOW2FqBIvAJna9BV3OJVLGNvsLFua34r/tsZ9AoEwOO9grSneEi8S8EcTZlNBMeayUhkk2xEz+QX1mEs9ZbmPI8g3UyOgEi8S6bhKGlLpnE+dd2M4jTZKEQ+lQkp44aKEK6gY0i8Tba7Sg65V+MjINqFVzL7ceGuLjw7wULabOVBSLwiHzAOaZaW980wBzeoimhz7EfA882H7+GVvrwab/BbIUBIvCIcERJBxXzXAARu/lQNQbERkTH+AdEaKYqX9yvLqEi8IxygSkDqYCOJV5VkbpqzjpwUT0dov7w65yIcKDCgSLxQMdxSAmH+Pbr3koPtirGcnRsuEK8w7ZOAHIBIvEF1AXg/YrvJcwjpU2RleoJUzZBXwebcg5ZiY7BIvCu1zlAiUaXI/2Iwpbyt6H8ojAdk1cJSdlYqTqfaUcmaoEi8S9MNXyC6XVYU4HAcsswsMQpLdHJieohIvFCTCkMbBXWhc06BC9N+EbiEpN6rI70uLYBPZ2dTAAAAdwEAAAAAAIg3AAADAAAAVUNZajIdHCAdHiYmIRseHhwaGBoaFRkbGRkZGhkYGR0bGRoWFR4fHRkYFx0eFxcdGx0bHRwbG0i8S+AJ1YNHGkB/rROH1RzNcEwtukN8YlHgqKQuSLxHSSEHpgpJbnaHER+A3EpmGHx0r7PjSGU+fki8HeQJHpx7BGoQI/Ur+dXmF20W7ATVbKQLhbgMb5xgSLwiRZAiY7BDZ6o8YVy9ySMXP3om2fd4tbBbJfBIvCIj6QfzFT56ZEY2UCHSa7agw/Fh4WzQNyhls/BIvB6zYtAiOYIVZ1MkaTrbo3K0sjfB9A030j32RFAtOnM4kgFL4Ei/5ih3I1nHW9Sl5g2H10XtXxH6XJL4OpGnUwPa4Tx+cUkG/irOSLv+78hYVMXaL/4bf0QXSI8BSj1vZrfqCv9f1hKekFRISLxKV3a8X+qbIwW2ubQdiDOMKchuv42xYGkISLxL7+4eYl+H9JQPVDGpc4ocoPqhH5zKdXbfkuqASLwkzYiKSU9js0zmRnS3ovGHg3ZimtC0Zqw7eSgqSLwetqQIEZaIHfT/0oC5KxK6vsDhk4E4qqZlgEi77f3pBVeXfPKVnaNR/JN6o0yP+oEF8A7wSD+ApyWqTYzneLbed/DizaBNxmkR1MxESD94UZrBB59OrAwFS5aQnBQqt5GtXOi8H/BIP2nLNNvz17azdjyGb/NPqf+VjiDqNqf6wEg/VHaNXTEYcZ5e5+rQGSPjOC/8mEg/CXOQZMDpytlxjiCwe172SZf4YtY+SExIPrFnCg60l4lWzdbEWV8X04eru5M48WbO3e5IPiPKx90OVfkrW2gQgmdOsKy8B5ZEBr6ASD4ZRkUtO3/WTkOwJCt9XpMmoHoH0EbigEg9rn3HtGWTiH/DETt0U/DbY53Si7gKOoRIPLkpj+ruwjftHf9MSWvOctNAsWM6USJIwEg8O++4TARIF/KvN8FuLmi6vR8V9m6ODxNIPMiw9FKj03weP4jSThzS6mhoSonfDgxIPLgCQuPPN3pxAUdJiIDAWjm4GEz/lVTASDtfaKHy5zwKZIlJ3SsHKLEl/lB4eH16IsgsyJBIO2bQdEwvtgLlFb+3yG8g+oYUbyuISCL6x8hIOyBm8yPLYnL/gTpOVYxRgRBazT+bGbecSDmymi/OHBHBRnL0vc8cCTLyl87x6L4YJkhIBcxHLswsDgIauQBzcknhE/StkwwwSAXgLDdG9SMHEceBY18p1PxS+2yASDmYPLCXcjgkBN2K9Oi20nV09a3kKe1a2Iqs3sOASDm+h+wQ6Huvqn+2jP5zUXYORq1dv7QI9M0LUuOmhEg5p1QlIaB/AA5T8eVCL5eer3GDNm336Jcw9gj8SDjKmdYIurFxvATlpsDd1hz98LCpL40w0kg4Hafp+MpFlOunKQ/Gh8FmuheQxAhr6Eg4E3JlF+DCAw9jnqVBhPOti+Uh0TNwSDfT61sN+etsM2AGTy60hsCTOrFatV+cOdUJQYBINohm6uWU6YZ20umfpv3cJpkfztJo6ZfU8l1JXoBINzjPJwzCxgwKLnSu6Kd0vduZemMrYEg2c86Hr9U0/WORW0esI3W823Ivm+hASDYxZX7ER7vX/ZmfoQC0fhO6CpYq++zERcmACmxIMT3LPBmH2/jaKRbkTqvo9VJnOL/0L0UE2iVIL0Q/Y6kG+U8hqUAPDWGQW8ASm5mKD4bi4ObgoEguti/CVXygO6NtNB3O3KvO5fJzTd/9bKlgakgrM7C5ZLivbOiNbSkp4hJgMfW/UPYfHqcImmCgSCmwP6QO52uQssOm2dG8gTD7DIYx9O9h8EByNEgnYehILZSQvVAu8nbmOeiTMFiK3UJiqXKg2EgkjosHKHOc8AmOYZHhcvRcL9H1Is2QN4+4eE9nZ1MABGapAQAAAAAAiDcAAAQAAACp+OkrDhMVEA0LCw8PDQ0OFxMTSB5QrQsQij6OfsmueZFvkWEGaEgXbZzAw6O0RN/9PHbeQPTuwJryMEgM4J0hLqjQM35diZguxlxICnmWD+LrTKQ2qSlQSAp5wjhcl1l9hZdICnmNzNyMcyecoEgKeZYPteQPaakwPtmduUgKeb8pWO+1pVlOVFtfZEgKeoRz6CHXHnEPFIBICnqZ8csaOpHWGFaASAp6dFHZJX0LUpaksyhoCi6eQgRL8gZ39ARZfa6zXOyILjsQOmgHyXnIyVfA/sgrO5VSIDJ6WcBoB8l5yMlXwP7IKz564iAyelnE",Cu="data:audio/ogg;base64,T2dnUwACAAAAAAAAAAAAAAAAAAAAAGS5xGoBE09wdXNIZWFkAQE4AUAfAAAAAABPZ2dTAAAAAAAAAAAAAAAAAAABAAAA88vQ2wEWT3B1c1RhZ3MGAAAAZmZtcGVnAAAAAE9nZ1MAAIC7AAAAAAAAAAAAAAIAAAC2VBw+MgoLCgsLCwoLCQoJCgoKCgwKCwoMCgoMCgsKDAoKDAoKCgsMCgsMCgoLCQoKCgwKCwoLCBbP6DOOu0lxQAg5MrclO8vjGojYCDtq4OKFyV1LGAg8O1DiYEBmNzeACDzDZbbqoXqqmIAIPMNltuqheqqYgAg8w2W26p3dR5gIPMNltuqheqqYgAg8w2W26pGf4Ag8rK3nGSvqu0AIO+wUQL5PPvAIOneJrh5RIn+ACDl4SOArl/gswAg3I3wSEVzTq6gIMJBdCfSbRlzACCPwrXc/hmBF9vzgCCpEn/qQ9hOpYgg2wWclMuJauH6ICDkKwsV8Arku1Ag6mnDiTc5jg4e3eAg7auDicvT9VCgIPCL7IEMqwmIgCDzDZbZZA+psYseACDzNd4nR3Unmigg9GaW2WOunv1zACD0ZpbZX99OUbQg9GaW2WQPqbGLHgAg9GaW2uaSJPXgIPRmltlj6Yeb4CD0ZpbZZA+psYseACD0Zpba5pGFKaAg9GaW2WOuXW0AIPRmltljrl1tACD0C7eb26uEdm+AIPLjIgDf8PwxFmVgIPAlUiBuv/mIwCDsZKOAYJxN6zOgIOXhI4BgxTXVtrCQINyQ5J8gt4zxYCDCQXQny/b31DAghH4SVYktK6Yh4CCoA6rM5pRrQCDbBZyU7yyzOkAg5CsLFjnbilvwIOppw4oXJXUr0CDtq4OJzjedlXWh4CDwi+yGjILbD4Ag8w2W26qF6qpiACDzNd4nZp/XZ6gg9GaW26qF6qpiAT2dnUwAEuLwAAAAAAAAAAAAAAwAAAFYTyTUBCQg9FUY1cWxXpQ==",xu=new Audio(Iu),br=new Audio(Cu);br.volume=.01;br.loop=!0;const Tu={keyType:"curve25519Legacy",userIDInput:{name:"",email:""},userID:[],thread:1048576,iteration:512,pattern:"",patternNumber:"0123456789ABCDEFXXXX"[Math.floor(Math.random()*20)],patternLength:6+Math.floor(Math.random()*3),filter:"",vanitySubkey:!1,notification:{sfx:!1,ntfy:!1,ntfyTopic:""},nonstopMode:!1,saveToDirectory:!1,saveToDirectoryHandle:void 0,get backTime(){return this.thread*this.iteration},get estimatedHashCount(){let t=0,e=0;for(const r of this.pattern.toUpperCase())"0123456789ABCDEF".includes(r)?t++:r==="X"&&e++;return 16n**BigInt(t+(e?e-1:0))},subkeyCombinerArmoredA:"",subkeyCombinerArmoredB:"",running:!1,generatedKey:void 0,generatedKeyHistory:[],hashCount:0,runningTime:0,formatFingerprint(t){return t.toUpperCase().match(/[^]{1,4}/g).join(" ")},mounted(){this.patternHelper(),/iPhone|iPad|iPod|Android/i.test(navigator.userAgent)&&(this.thread=1024,this.iteration=256)},addUserID(){!this.userIDInput.name||!this.userIDInput.email||(this.userID.push({...this.userIDInput}),this.userIDInput.name=this.userIDInput.email="")},patternHelper(){this.pattern=this.formatFingerprint("*".repeat(40-this.patternLength)+this.patternNumber.repeat(this.patternLength))},async setSaveDirectory(){if(!window.showDirectoryPicker)return alert(` File System Access API
https://caniuse.com/native-filesystem-api`);this.saveToDirectoryHandle=await window.showDirectoryPicker({mode:"readwrite"}).catch(()=>{})},showAutoFilter(){alert(Ji(this.pattern))},async bulkDownload(){if(!this.generatedKeyHistory.length)return;const t=new hu;this.generatedKeyHistory.forEach(r=>t.addFile(`${r.privateKey.getFingerprint().toUpperCase()}-sec.asc`,r.privateKey.armor()));const e=document.createElement("a");e.href=URL.createObjectURL(await t.write()),e.download="vanity-keys.tar",e.click(),URL.revokeObjectURL(e.href)},async toggleKeygen(){if(this.running){this.running=!1;return}this.userID.length||(!this.userIDInput.name&&!this.userIDInput.email&&(this.userIDInput.name="Dummy",this.userIDInput.email="dummy@example.com"),this.addUserID()),this.hashCount=0,this.runningTime=0,this.running=!0,br.play();try{const t={userIDs:this.userID};switch(this.keyType){case"curve25519Legacy":case"nistP256":case"nistP384":case"nistP521":case"brainpoolP256r1":case"brainpoolP384r1":case"brainpoolP512r1":t.type="ecc",t.curve=this.keyType;break;case"2048":case"3072":case"4096":t.type="rsa",t.rsaBits=parseInt(this.keyType);break}do{const e=await Du(t,this.filter.replaceAll(`
`," ")||Ji(this.pattern),this.thread,this.iteration,(r,n)=>{this.hashCount=r,this.runningTime=n},()=>!this.running,this.vanitySubkey);if(e&&(this.generatedKey=e,this.generatedKeyHistory.push(e),this.notification.sfx&&xu.play(),this.notification.ntfy&&this.notification.ntfyTopic&&fetch("https://ntfy.sh/",{method:"POST",body:JSON.stringify({topic:this.notification.ntfyTopic,markdown:!0,title:"webgl-vanity-gpg ",message:"Fingerprint: `"+this.formatFingerprint(e.publicKey.getFingerprint())+`\`

Created: `+e.publicKey.getCreationTime().toISOString()+`

 webgl-vanity-gpg /`})}),this.saveToDirectory&&this.saveToDirectoryHandle)){const n=await(await this.saveToDirectoryHandle.getFileHandle(`${e.privateKey.getFingerprint().toUpperCase()}-sec.asc`,{create:!0})).createWritable();await n.write(new Blob([e.privateKey.armor()])),await n.close()}}while(this.running&&this.nonstopMode)}catch(t){alert(t)}finally{this.running=!1,br.pause()}},async subkeyCombine(){try{const[t,e]=await Promise.all([this.subkeyCombinerArmoredA,this.subkeyCombinerArmoredB].map(i=>wa({armoredKey:i})));t.subkeys.push(new rt(Object.assign(new Jn,e.keyPacket),t.toPublic()),...e.subkeys);const r=await ba({privateKey:t,userIDs:t.users.map(i=>i.userID),date:t.keyPacket.created,format:"object"}),n=document.createElement("a");n.href=`data:text/plain;charset=utf-8,${encodeURIComponent(r.privateKey.armor())}`,n.download=`${r.privateKey.getFingerprint().toUpperCase()}-sec.asc`,n.click()}catch(t){alert(t)}}};Es(Tu).mount();
